[
  {
    "id": "Swift_001",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "What is the primary difference between let and var in Swift?",
    "options": [
      "let declares an immutable value, var declares a mutable value",
      "let allocates memory on the stack, var on the heap",
      "let is thread-safe, var is not",
      "let is used for reference types, var for value types"
    ],
    "correctAnswerIndex": 0,
    "explanation": "let creates a constant that cannot be reassigned, while var allows reassignment."
  },
  {
    "id": "Swift_002",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "Which Swift type is used to represent the absence of a value?",
    "options": [
      "Optional",
      "NilType",
      "Void",
      "None"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Optional wraps a value that may be nil, making absence explicit and type-safe."
  },
  {
    "id": "Swift_003",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Normal",
    "questionText": "What does the guard statement primarily improve in Swift code?",
    "options": [
      "Early exit and readability",
      "Runtime performance",
      "Memory allocation",
      "Thread synchronization"
    ],
    "correctAnswerIndex": 0,
    "explanation": "guard enforces required conditions early and exits the scope if they fail."
  },
  {
    "id": "Swift_004",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "Which keyword allows a function to throw an error?",
    "options": [
      "throws",
      "catch",
      "error",
      "fail"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Functions marked with throws can propagate errors to the caller."
  },
  {
    "id": "Swift_005",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "What is the default access level in Swift?",
    "options": [
      "internal",
      "private",
      "public",
      "fileprivate"
    ],
    "correctAnswerIndex": 0,
    "explanation": "internal allows access within the same module and is the default."
  },
  {
    "id": "Swift_006",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Normal",
    "questionText": "Which type is a value type in Swift?",
    "options": [
      "Struct",
      "Class",
      "Actor",
      "Closure"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Structs are value types and are copied on assignment."
  },
  {
    "id": "Swift_007",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "What does nil represent in Swift?",
    "options": [
      "Absence of a value",
      "Zero memory address",
      "An empty object",
      "A default value"
    ],
    "correctAnswerIndex": 0,
    "explanation": "nil indicates that an Optional currently has no value."
  },
  {
    "id": "Swift_008",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "Which keyword is used to define a protocol?",
    "options": [
      "protocol",
      "interface",
      "contract",
      "trait"
    ],
    "correctAnswerIndex": 0,
    "explanation": "protocol defines a blueprint of methods and properties."
  },
  {
    "id": "Swift_009",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Normal",
    "questionText": "What happens when you assign a struct to another variable?",
    "options": [
      "A copy of the value is created",
      "Both variables reference the same instance",
      "ARC increases reference count",
      "Memory is shared until mutation"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Value types are copied on assignment, preserving immutability semantics."
  },
  {
    "id": "Swift_010",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "Which feature prevents null pointer exceptions in Swift?",
    "options": [
      "Optionals",
      "Type inference",
      "ARC",
      "Closures"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Optionals force explicit handling of nil values at compile time."
  },
  {
    "id": "Swift_011",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "How does ARC determine when to deallocate an object?",
    "options": [
      "When reference count reaches zero",
      "When scope ends",
      "When memory pressure increases",
      "When autorelease pool drains"
    ],
    "correctAnswerIndex": 0,
    "explanation": "ARC deallocates an object when no strong references remain."
  },
  {
    "id": "Swift_012",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "Which reference type can cause a retain cycle?",
    "options": [
      "Strong reference",
      "Weak reference",
      "Unowned reference",
      "Optional reference"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Strong references increase reference count and can form cycles."
  },
  {
    "id": "Swift_013",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Hard",
    "questionText": "When should unowned be preferred over weak?",
    "options": [
      "When the referenced object is guaranteed to outlive the owner",
      "When reference can become nil",
      "When avoiding optional unwrapping",
      "When thread safety is required"
    ],
    "correctAnswerIndex": 0,
    "explanation": "unowned assumes the reference will never be nil during access."
  },
  {
    "id": "Swift_014",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "What is the role of AnyCancellable in Combine?",
    "options": [
      "Manages the lifecycle of a subscription",
      "Publishes values",
      "Transforms streams",
      "Handles backpressure"
    ],
    "correctAnswerIndex": 0,
    "explanation": "AnyCancellable cancels the subscription when deallocated."
  },
  {
    "id": "Swift_015",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "Which Combine operator transforms values synchronously?",
    "options": [
      "map",
      "flatMap",
      "switchToLatest",
      "debounce"
    ],
    "correctAnswerIndex": 0,
    "explanation": "map applies a synchronous transformation to each emitted value."
  },
  {
    "id": "Swift_016",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "What does async/await primarily improve?",
    "options": [
      "Readability of asynchronous code",
      "Thread creation speed",
      "Memory allocation",
      "Compile-time performance"
    ],
    "correctAnswerIndex": 0,
    "explanation": "async/await makes asynchronous code look and behave like synchronous code."
  },
  {
    "id": "Swift_017",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Hard",
    "questionText": "What is the purpose of Task in Swift concurrency?",
    "options": [
      "To create a new concurrent unit of work",
      "To block the current thread",
      "To synchronize access to memory",
      "To replace DispatchQueue"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Task starts an asynchronous unit of work managed by Swift concurrency."
  },
  {
    "id": "Swift_018",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "Why are actors used in Swift concurrency?",
    "options": [
      "To protect mutable state from data races",
      "To improve rendering performance",
      "To manage memory allocation",
      "To replace protocols"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Actors ensure isolated access to their mutable state."
  },
  {
    "id": "Swift_019",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "What problem do protocols with associated types solve?",
    "options": [
      "Allow generic behavior in protocols",
      "Improve runtime polymorphism",
      "Reduce memory usage",
      "Enable reflection"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Associated types let protocols express placeholder types."
  },
  {
    "id": "Swift_020",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "Why can protocols with associated types not be used as concrete types?",
    "options": [
      "The compiler cannot infer the associated type",
      "They are reference types",
      "They require ARC",
      "They are dynamically dispatched"
    ],
    "correctAnswerIndex": 0,
    "explanation": "The concrete associated type must be known at compile time."
  },
  {
    "id": "Swift_021",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "What happens if an unowned reference is accessed after deallocation?",
    "options": [
      "A runtime crash occurs",
      "It returns nil",
      "ARC recreates the object",
      "The access is ignored"
    ],
    "correctAnswerIndex": 0,
    "explanation": "unowned does not become nil and accessing it causes a crash."
  },
  {
    "id": "Swift_022",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "Why is flatMap often used instead of map in Combine?",
    "options": [
      "To transform values into new publishers",
      "To improve memory usage",
      "To enforce type erasure",
      "To debounce values"
    ],
    "correctAnswerIndex": 0,
    "explanation": "flatMap handles transformations that return publishers."
  },
  {
    "id": "Swift_023",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "What is a major difference between Task and Task.detached?",
    "options": [
      "Detached tasks do not inherit actor context",
      "Detached tasks always run on the main thread",
      "Task cannot be cancelled",
      "Detached tasks block execution"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Detached tasks run independently of the current actor context."
  },
  {
    "id": "Swift_024",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "Why is Sendable important in Swift concurrency?",
    "options": [
      "It ensures values can be safely passed across concurrency domains",
      "It improves ARC performance",
      "It enables async functions",
      "It replaces Codable"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Sendable enforces thread-safe value transfer between tasks."
  },
  {
    "id": "Swift_025",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "What issue does capture list solve in closures?",
    "options": [
      "Controls reference ownership and avoids retain cycles",
      "Improves execution speed",
      "Adds thread safety",
      "Enables generics"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Capture lists define how values are captured, often weakly."
  },
  {
    "id": "Swift_026",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "Why are value types preferred in Swift concurrency?",
    "options": [
      "They avoid shared mutable state",
      "They reduce ARC overhead",
      "They support inheritance",
      "They require actors"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Value types prevent data races by avoiding shared mutation."
  },
  {
    "id": "Swift_027",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "What is the main cost of excessive use of weak references?",
    "options": [
      "Optional unwrapping and potential logic complexity",
      "Higher memory consumption",
      "ARC deallocation delays",
      "Thread contention"
    ],
    "correctAnswerIndex": 0,
    "explanation": "weak references require optional handling and careful logic."
  },
  {
    "id": "Swift_028",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "What Combine concept enables multiple subscribers to receive the same values?",
    "options": [
      "Multicast",
      "Merge",
      "Zip",
      "ReplaceError"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Multicast shares a single upstream publisher with multiple subscribers."
  },
  {
    "id": "Swift_029",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "Why does Swift prefer static dispatch for structs?",
    "options": [
      "Better performance and compile-time optimization",
      "Improved ARC handling",
      "Dynamic flexibility",
      "Protocol conformance"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Static dispatch enables faster calls and better optimizations."
  },
  {
    "id": "Swift_030",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "What risk arises when using force unwrap in async code?",
    "options": [
      "Unexpected runtime crashes",
      "Deadlocks",
      "Memory leaks",
      "Lost tasks"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Async timing can change state, making force unwrap unsafe."
  },
  {
    "id": "Swift_031",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "Which keyword marks a function as asynchronous?",
    "options": [
      "async",
      "await",
      "concurrent",
      "background"
    ],
    "correctAnswerIndex": 0,
    "explanation": "async declares that a function can suspend and resume."
  },
  {
    "id": "Swift_032",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Normal",
    "questionText": "What does await indicate in Swift?",
    "options": [
      "A suspension point in asynchronous execution",
      "A thread lock",
      "A synchronous call",
      "An actor boundary"
    ],
    "correctAnswerIndex": 0,
    "explanation": "await marks where an async function may suspend."
  },
  {
    "id": "Swift_033",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "Which collection guarantees unique elements?",
    "options": [
      "Set",
      "Array",
      "Dictionary",
      "Tuple"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Set enforces uniqueness of its elements."
  },
  {
    "id": "Swift_034",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "What does Codable primarily provide?",
    "options": [
      "Automatic encoding and decoding",
      "Thread safety",
      "Memory management",
      "Protocol inheritance"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Codable simplifies serialization to and from formats like JSON."
  },
  {
    "id": "Swift_035",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Normal",
    "questionText": "Which Swift feature enables default method implementations?",
    "options": [
      "Protocol extensions",
      "Class inheritance",
      "Generics",
      "Actors"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Protocol extensions allow shared default behavior."
  },
  {
    "id": "Swift_036",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "Why is AnyPublisher commonly used?",
    "options": [
      "To erase publisher type details",
      "To improve performance",
      "To handle errors",
      "To schedule work"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Type erasure hides complex publisher chains."
  },
  {
    "id": "Swift_037",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Hard",
    "questionText": "What is a key benefit of protocol-oriented programming in Swift?",
    "options": [
      "Composition over inheritance",
      "Faster ARC deallocation",
      "Dynamic dispatch everywhere",
      "Reduced binary size"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Protocols enable flexible composition instead of deep class hierarchies."
  },
  {
    "id": "Swift_038",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "Why must async functions be called from an async context?",
    "options": [
      "They may suspend execution",
      "They allocate memory differently",
      "They require ARC",
      "They run on background threads"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Only async contexts can handle suspension points."
  },
  {
    "id": "Swift_039",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "What problem does rethrows solve?",
    "options": [
      "Allows functions to throw only if their parameters throw",
      "Improves error performance",
      "Eliminates do-catch blocks",
      "Supports async errors"
    ],
    "correctAnswerIndex": 0,
    "explanation": "rethrows limits error propagation to throwing parameters."
  },
  {
    "id": "Swift_040",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "Why is @MainActor commonly used in UI-related async code?",
    "options": [
      "UI updates must occur on the main thread",
      "It improves rendering speed",
      "It prevents memory leaks",
      "It enables Combine integration"
    ],
    "correctAnswerIndex": 0,
    "explanation": "UI frameworks require main-thread execution."
  },
  {
    "id": "Swift_041",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "What does the ?? operator do?",
    "options": [
      "Provides a default value for nil Optionals",
      "Forces unwrap",
      "Casts types",
      "Compares Optionals"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Nil-coalescing returns a default if the Optional is nil."
  },
  {
    "id": "Swift_042",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "Why are enums with associated values powerful?",
    "options": [
      "They model state with related data",
      "They improve memory alignment",
      "They reduce ARC calls",
      "They enable inheritance"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Associated values allow enums to carry contextual data."
  },
  {
    "id": "Swift_043",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Hard",
    "questionText": "What is the main downside of massive protocol inheritance chains?",
    "options": [
      "Increased complexity and coupling",
      "Memory leaks",
      "ARC overhead",
      "Thread blocking"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Over-composition can reduce clarity and maintainability."
  },
  {
    "id": "Swift_044",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "Why is actor reentrancy important to understand?",
    "options": [
      "Actor methods can interleave at suspension points",
      "Actors run only once",
      "Actors block threads",
      "Actors disable async calls"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Reentrancy allows other tasks to execute while awaiting."
  },
  {
    "id": "Swift_045",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "What Combine operator controls execution context?",
    "options": [
      "receive(on:)",
      "map",
      "filter",
      "scan"
    ],
    "correctAnswerIndex": 0,
    "explanation": "receive(on:) specifies the scheduler for downstream work."
  },
  {
    "id": "Swift_046",
    "category": "Swift",
    "baseDifficulty": "Easy",
    "targetLevel": "Easy",
    "questionText": "Which keyword defines a computed property?",
    "options": [
      "var",
      "let",
      "func",
      "lazy"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Computed properties must be declared with var."
  },
  {
    "id": "Swift_047",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Normal",
    "questionText": "Why does Swift discourage force casting?",
    "options": [
      "It can cause runtime crashes",
      "It slows performance",
      "It increases memory usage",
      "It disables ARC"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Force casts fail at runtime if the type is incorrect."
  },
  {
    "id": "Swift_048",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "What is the key benefit of structured concurrency?",
    "options": [
      "Predictable task lifetimes",
      "Faster thread execution",
      "Automatic memory deallocation",
      "Reduced code size"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Structured concurrency ties tasks to a clear lifecycle."
  },
  {
    "id": "Swift_049",
    "category": "Swift",
    "baseDifficulty": "Normal",
    "targetLevel": "Hard",
    "questionText": "Why are escaping closures dangerous in ARC?",
    "options": [
      "They can outlive their capture context",
      "They block threads",
      "They prevent async execution",
      "They disable value semantics"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Escaping closures may retain objects longer than expected."
  },
  {
    "id": "Swift_050",
    "category": "Swift",
    "baseDifficulty": "Hard",
    "targetLevel": "Hard",
    "questionText": "What problem does type erasure primarily solve?",
    "options": [
      "Hides concrete generic types behind a uniform interface",
      "Improves runtime speed",
      "Removes protocol requirements",
      "Enables inheritance"
    ],
    "correctAnswerIndex": 0,
    "explanation": "Type erasure simplifies APIs by hiding generic complexity."
  },
    {
      "id": "Swift_051",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "Which Swift feature allows a property to be initialized only once when first accessed?",
      "options": ["lazy", "static", "computed", "final"],
      "correctAnswerIndex": 0,
      "explanation": "lazy properties are initialized on first access and only once."
    },
    {
      "id": "Swift_052",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "What keyword prevents a class from being subclassed?",
      "options": ["final", "sealed", "private", "static"],
      "correctAnswerIndex": 0,
      "explanation": "final stops inheritance and enables compiler optimizations."
    },
    {
      "id": "Swift_053",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Normal",
      "questionText": "What does the as? operator do in Swift?",
      "options": ["Performs safe type casting", "Forces a type cast", "Checks protocol conformance", "Creates a copy"],
      "correctAnswerIndex": 0,
      "explanation": "as? returns an Optional and fails safely if the cast is invalid."
    },
    {
      "id": "Swift_054",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "Which collection type maps unique keys to values?",
      "options": ["Dictionary", "Array", "Set", "Tuple"],
      "correctAnswerIndex": 0,
      "explanation": "Dictionary stores key–value pairs with unique keys."
    },
    {
      "id": "Swift_055",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "What does the defer statement guarantee?",
      "options": ["Execution at scope exit", "Execution before return", "Async execution", "Thread synchronization"],
      "correctAnswerIndex": 0,
      "explanation": "defer runs when the current scope exits, regardless of path."
    },
    {
      "id": "Swift_056",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Normal",
      "questionText": "Which keyword is used to override a superclass method?",
      "options": ["override", "extend", "mutating", "open"],
      "correctAnswerIndex": 0,
      "explanation": "override explicitly marks method overriding."
    },
    {
      "id": "Swift_057",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "What does the mutating keyword indicate?",
      "options": ["A value type method modifies self", "A reference is reassigned", "Thread-safe mutation", "ARC mutation"],
      "correctAnswerIndex": 0,
      "explanation": "mutating allows structs/enums to modify their properties."
    },
    {
      "id": "Swift_058",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "Which Swift type represents a sequence of Unicode characters?",
      "options": ["String", "CharacterSet", "Array<Character>", "Text"],
      "correctAnswerIndex": 0,
      "explanation": "String is a collection of Characters with Unicode support."
    },
    {
      "id": "Swift_059",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Normal",
      "questionText": "What does Equatable conformance provide?",
      "options": ["Ability to compare values with ==", "Hashing support", "Sorting behavior", "Identity comparison"],
      "correctAnswerIndex": 0,
      "explanation": "Equatable enables == to compare value equality."
    },
    {
      "id": "Swift_060",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "Which keyword exposes a declaration outside the module?",
      "options": ["public", "internal", "fileprivate", "private"],
      "correctAnswerIndex": 0,
      "explanation": "public allows access from other modules."
    },

    {
      "id": "Swift_061",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "Why are weak references always Optional?",
      "options": ["They are set to nil on deallocation", "They don’t increase retain count", "They require runtime checks", "They are lazily loaded"],
      "correctAnswerIndex": 0,
      "explanation": "weak references become nil automatically when the object deallocates."
    },
    {
      "id": "Swift_062",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "What does withCheckedContinuation help with?",
      "options": ["Bridging callback APIs to async/await", "Creating detached tasks", "Blocking threads safely", "Actor isolation"],
      "correctAnswerIndex": 0,
      "explanation": "It converts callback-based code into async functions."
    },
    {
      "id": "Swift_063",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Hard",
      "questionText": "What is the main benefit of using async let?",
      "options": ["Run child tasks concurrently with structured lifetime", "Detach background work", "Guarantee main-thread execution", "Avoid awaiting results"],
      "correctAnswerIndex": 0,
      "explanation": "async let starts concurrent child tasks within the same scope."
    },
    {
      "id": "Swift_064",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "What does the Combine operator debounce do?",
      "options": ["Delays emissions until inactivity", "Buffers values indefinitely", "Merges streams", "Switches publishers"],
      "correctAnswerIndex": 0,
      "explanation": "debounce emits values only after a quiet period."
    },
    {
      "id": "Swift_065",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "Why is eraseToAnyPublisher commonly used?",
      "options": ["To hide complex publisher chains", "To improve throughput", "To add scheduling", "To handle failures"],
      "correctAnswerIndex": 0,
      "explanation": "Type erasure simplifies exposed APIs."
    },
    {
      "id": "Swift_066",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "What does Task.cancel() do?",
      "options": ["Requests cooperative cancellation", "Immediately stops execution", "Kills the thread", "Releases memory"],
      "correctAnswerIndex": 0,
      "explanation": "Cancellation is cooperative; tasks must check for it."
    },
    {
      "id": "Swift_067",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Hard",
      "questionText": "Why should long-running work avoid @MainActor?",
      "options": ["It can block UI responsiveness", "It increases memory usage", "It disables async", "It causes retain cycles"],
      "correctAnswerIndex": 0,
      "explanation": "Main actor work runs on the main thread and can block UI."
    },
    {
      "id": "Swift_068",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "What does Hashable conformance enable?",
      "options": ["Use as Dictionary keys or Set elements", "Sorting collections", "Equality checks only", "Reference comparison"],
      "correctAnswerIndex": 0,
      "explanation": "Hashable provides a hash value for hashed collections."
    },
    {
      "id": "Swift_069",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "What is the role of Result type?",
      "options": ["Encapsulate success or failure", "Replace throwing functions", "Handle concurrency", "Manage memory"],
      "correctAnswerIndex": 0,
      "explanation": "Result represents either success with a value or failure with an error."
    },
    {
      "id": "Swift_070",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "Why are structs preferred for models in Swift?",
      "options": ["Value semantics and safety", "ARC optimization", "Dynamic dispatch", "Inheritance support"],
      "correctAnswerIndex": 0,
      "explanation": "Value semantics avoid shared mutable state."
    },

    {
      "id": "Swift_071",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "What risk exists when using nonisolated in actors?",
      "options": ["Potential data races if misused", "Memory leaks", "Deadlocks", "Task cancellation"],
      "correctAnswerIndex": 0,
      "explanation": "nonisolated bypasses actor isolation guarantees."
    },
    {
      "id": "Swift_072",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "Why is withUnsafeContinuation considered dangerous?",
      "options": ["Incorrect resumption can crash or hang", "It blocks threads", "It disables ARC", "It leaks memory"],
      "correctAnswerIndex": 0,
      "explanation": "Continuations must be resumed exactly once."
    },
    {
      "id": "Swift_073",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "What is the downside of excessive type erasure?",
      "options": ["Loss of static type information", "Slower ARC", "More memory leaks", "Thread contention"],
      "correctAnswerIndex": 0,
      "explanation": "Type erasure can hide useful compile-time guarantees."
    },
    {
      "id": "Swift_074",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "Why can actor methods be reentrant?",
      "options": ["They can suspend at await points", "They run on multiple threads", "They share memory", "They block execution"],
      "correctAnswerIndex": 0,
      "explanation": "Suspension allows other tasks to enter the actor."
    },
    {
      "id": "Swift_075",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "What does @Sendable enforce for closures?",
      "options": ["Safe use across concurrency domains", "Main-thread execution", "Reference-only captures", "Synchronous execution"],
      "correctAnswerIndex": 0,
      "explanation": "@Sendable restricts captures to be concurrency-safe."
    },
    {
      "id": "Swift_076",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "Why is dynamic member lookup risky?",
      "options": ["Loss of compile-time safety", "Higher memory usage", "ARC instability", "Deadlocks"],
      "correctAnswerIndex": 0,
      "explanation": "Dynamic lookup defers errors to runtime."
    },
    {
      "id": "Swift_077",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "What issue can arise from nested async Tasks?",
      "options": ["Unclear task ownership and cancellation", "Guaranteed deadlocks", "Memory corruption", "Thread starvation"],
      "correctAnswerIndex": 0,
      "explanation": "Detached or nested tasks can escape structured lifetimes."
    },
    {
      "id": "Swift_078",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "Why should continuations not be stored?",
      "options": ["They may be resumed multiple times", "They block threads", "They increase retain count", "They cancel tasks"],
      "correctAnswerIndex": 0,
      "explanation": "Misuse breaks async correctness guarantees."
    },
    {
      "id": "Swift_079",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "What is the cost of heavy protocol witness tables?",
      "options": ["Potential runtime dispatch overhead", "ARC memory leaks", "Compile errors", "Thread blocking"],
      "correctAnswerIndex": 0,
      "explanation": "Dynamic dispatch via protocols can incur overhead."
    },
    {
      "id": "Swift_080",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "Why can generic specialization improve performance?",
      "options": ["Concrete types enable optimization", "ARC skips reference counting", "Threads are reused", "Actors are bypassed"],
      "correctAnswerIndex": 0,
      "explanation": "Specialization allows the compiler to optimize concrete paths."
    },

    {
      "id": "Swift_081",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "Which keyword declares a type alias?",
      "options": ["typealias", "alias", "typedef", "using"],
      "correctAnswerIndex": 0,
      "explanation": "typealias creates an alternate name for a type."
    },
    {
      "id": "Swift_082",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "What does the count property return for collections?",
      "options": ["Number of elements", "Capacity", "Last index", "Memory size"],
      "correctAnswerIndex": 0,
      "explanation": "count returns the number of stored elements."
    },
    {
      "id": "Swift_083",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Normal",
      "questionText": "What does map do on an Optional?",
      "options": ["Transforms the wrapped value if present", "Unwraps forcibly", "Filters nils", "Creates a copy"],
      "correctAnswerIndex": 0,
      "explanation": "map applies a transform only when a value exists."
    },
    {
      "id": "Swift_084",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "Which keyword allows subclassing outside the module?",
      "options": ["open", "public", "internal", "final"],
      "correctAnswerIndex": 0,
      "explanation": "open permits subclassing and overriding across modules."
    },
    {
      "id": "Swift_085",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "What does the dropFirst() method do?",
      "options": ["Returns a collection without the first element", "Removes all elements", "Deletes in-place", "Reverses order"],
      "correctAnswerIndex": 0,
      "explanation": "dropFirst returns a subsequence skipping the first element."
    },
    {
      "id": "Swift_086",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "Why is AnyObject used in protocol constraints?",
      "options": ["To restrict conformance to class types", "To enable generics", "To enforce Sendable", "To allow structs"],
      "correctAnswerIndex": 0,
      "explanation": "AnyObject limits protocols to reference types."
    },
    {
      "id": "Swift_087",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Hard",
      "questionText": "What problem does covariance solve?",
      "options": ["Allowing subtype substitution", "Improving ARC", "Reducing memory usage", "Avoiding optionals"],
      "correctAnswerIndex": 0,
      "explanation": "Covariance allows flexible type substitution."
    },
    {
      "id": "Swift_088",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "Why can excessive async boundaries hurt performance?",
      "options": ["Context switching overhead", "Memory leaks", "ARC failures", "Deadlocks"],
      "correctAnswerIndex": 0,
      "explanation": "Too many suspension points add scheduling overhead."
    },
    {
      "id": "Swift_089",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "What does the prefix operator ! do?",
      "options": ["Logical negation", "Force unwrap", "Optional mapping", "Bitwise inversion"],
      "correctAnswerIndex": 0,
      "explanation": "! negates Boolean values."
    },
    {
      "id": "Swift_090",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "Why should reference cycles be harder to detect with closures?",
      "options": ["Closures capture values implicitly", "ARC ignores closures", "They are thread-local", "They use value semantics"],
      "correctAnswerIndex": 0,
      "explanation": "Implicit captures can hide strong reference cycles."
    },

    {
      "id": "Swift_091",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "Which method checks if a collection is empty?",
      "options": ["isEmpty", "count == 0", "hasElements", "none"],
      "correctAnswerIndex": 0,
      "explanation": "isEmpty is the idiomatic and efficient check."
    },
    {
      "id": "Swift_092",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "Why prefer isEmpty over count == 0?",
      "options": ["It can be more efficient", "It avoids ARC", "It improves readability only", "It prevents crashes"],
      "correctAnswerIndex": 0,
      "explanation": "Some collections compute count in O(n)."
    },
    {
      "id": "Swift_093",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Hard",
      "questionText": "What is the risk of using force try?",
      "options": ["Runtime crash on thrown error", "Compile-time failure", "Silent failure", "Deadlock"],
      "correctAnswerIndex": 0,
      "explanation": "force try crashes if an error is thrown."
    },
    {
      "id": "Swift_094",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "Why is backpressure important in Combine?",
      "options": ["Prevents overwhelming subscribers", "Improves ARC", "Ensures ordering", "Handles cancellation"],
      "correctAnswerIndex": 0,
      "explanation": "Backpressure controls demand between publishers and subscribers."
    },
    {
      "id": "Swift_095",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "What problem arises from sharing mutable reference types across tasks?",
      "options": ["Data races", "Memory leaks", "Deadlocks always", "ARC crashes"],
      "correctAnswerIndex": 0,
      "explanation": "Concurrent mutation without isolation causes data races."
    },
    {
      "id": "Swift_096",
      "category": "Swift",
      "baseDifficulty": "Easy",
      "targetLevel": "Easy",
      "questionText": "Which operator unwraps an Optional safely with a default?",
      "options": ["??", "!", "as?", "try?"],
      "correctAnswerIndex": 0,
      "explanation": "?? returns a fallback value if nil."
    },
    {
      "id": "Swift_097",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Normal",
      "questionText": "Why are throwing functions preferred over returning error codes?",
      "options": ["Clear error propagation", "Faster execution", "Lower memory usage", "Simpler syntax"],
      "correctAnswerIndex": 0,
      "explanation": "Errors are explicit and enforced by the compiler."
    },
    {
      "id": "Swift_098",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "Why is isolation inheritance important for actors?",
      "options": ["Prevents accidental shared state", "Improves ARC", "Enables dynamic dispatch", "Avoids deadlocks"],
      "correctAnswerIndex": 0,
      "explanation": "Isolation inheritance maintains concurrency safety across calls."
    },
    {
      "id": "Swift_099",
      "category": "Swift",
      "baseDifficulty": "Normal",
      "targetLevel": "Hard",
      "questionText": "What issue can arise with async property getters?",
      "options": ["Unexpected suspension points", "Memory leaks", "Compile errors", "Deadlocks"],
      "correctAnswerIndex": 0,
      "explanation": "Async getters may suspend in places callers don’t expect."
    },
    {
      "id": "Swift_100",
      "category": "Swift",
      "baseDifficulty": "Hard",
      "targetLevel": "Hard",
      "questionText": "What is the main benefit of separating API and implementation with protocols?",
      "options": ["Testability and decoupling", "ARC optimization", "Thread safety", "Faster compilation"],
      "correctAnswerIndex": 0,
      "explanation": "Protocols enable mocking and loose coupling."
    },
      {
        "id": "Swift_101",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "Which keyword defines a stored property with an initial value inside a type?",
        "options": ["var", "init", "set", "property"],
        "correctAnswerIndex": 0,
        "explanation": "Stored properties are declared with var (or let) inside a type."
      },
      {
        "id": "Swift_102",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "What does try? return when an error is thrown?",
        "options": ["nil", "A default value", "A thrown error", "A Result.failure"],
        "correctAnswerIndex": 0,
        "explanation": "try? converts a thrown error into nil instead of propagating it."
      },
      {
        "id": "Swift_103",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Normal",
        "questionText": "What is the main purpose of an initializer (init) in Swift?",
        "options": [
          "To ensure all stored properties are initialized",
          "To allocate an object on the stack",
          "To increase ARC reference count",
          "To register a type with the runtime"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Swift requires stored properties to be initialized before use."
      },
      {
        "id": "Swift_104",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "Which operator combines two Boolean conditions and returns true only if both are true?",
        "options": ["&&", "||", "??", "&"],
        "correctAnswerIndex": 0,
        "explanation": "&& is the logical AND operator."
      },
      {
        "id": "Swift_105",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "What does the self keyword refer to inside an instance method?",
        "options": ["The current instance", "The superclass", "The module", "The current thread"],
        "correctAnswerIndex": 0,
        "explanation": "self refers to the instance the method is called on."
      },
      {
        "id": "Swift_106",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Normal",
        "questionText": "What does compactMap do compared to map?",
        "options": [
          "Maps and removes nil results",
          "Maps and keeps nil results",
          "Flattens nested arrays only",
          "Sorts the mapped output"
        ],
        "correctAnswerIndex": 0,
        "explanation": "compactMap filters out nils from a transformation that returns optionals."
      },
      {
        "id": "Swift_107",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "Which statement is used to loop over a range in Swift?",
        "options": ["for-in", "repeat-while", "switch", "guard"],
        "correctAnswerIndex": 0,
        "explanation": "for-in iterates over sequences such as ranges and arrays."
      },
      {
        "id": "Swift_108",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "Which Swift feature allows adding functionality to existing types without subclassing?",
        "options": ["Extension", "Override", "Generic", "Operator"],
        "correctAnswerIndex": 0,
        "explanation": "Extensions add methods/properties to existing types."
      },
      {
        "id": "Swift_109",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Normal",
        "questionText": "What does the keyword inout indicate for a function parameter?",
        "options": [
          "The parameter can be modified in-place",
          "The parameter is passed by reference always",
          "The parameter is immutable",
          "The parameter is captured by closure"
        ],
        "correctAnswerIndex": 0,
        "explanation": "inout allows a function to modify the caller’s variable."
      },
      {
        "id": "Swift_110",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "Which statement is used to handle multiple cases for a value?",
        "options": ["switch", "if", "guard", "defer"],
        "correctAnswerIndex": 0,
        "explanation": "switch matches a value against multiple patterns/cases."
      },

      {
        "id": "Swift_111",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "Why can capturing self strongly in an escaping closure be problematic?",
        "options": [
          "It can create a retain cycle",
          "It always causes a crash",
          "It makes self non-Optional",
          "It prevents compilation"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Escaping closures may outlive the scope and keep self retained."
      },
      {
        "id": "Swift_112",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "What does Combine's subscribe(on:) affect?",
        "options": [
          "Where upstream work is performed",
          "Where downstream receives values",
          "How errors are mapped",
          "How demand is calculated"
        ],
        "correctAnswerIndex": 0,
        "explanation": "subscribe(on:) sets the scheduler for upstream operations."
      },
      {
        "id": "Swift_113",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Hard",
        "questionText": "Why might receive(on:) be preferred over DispatchQueue.main.async in Combine pipelines?",
        "options": [
          "It integrates scheduling into the pipeline explicitly",
          "It guarantees no backpressure issues",
          "It prevents retain cycles automatically",
          "It makes publishers synchronous"
        ],
        "correctAnswerIndex": 0,
        "explanation": "receive(on:) makes scheduling part of the declarative stream."
      },
      {
        "id": "Swift_114",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "What is the primary role of a Publisher in Combine?",
        "options": [
          "Emit values over time and optionally complete",
          "Store values persistently",
          "Synchronize threads",
          "Manage object lifetimes"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Publishers produce a stream of values and completion events."
      },
      {
        "id": "Swift_115",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "What does the keyword some indicate in a return type (opaque type)?",
        "options": [
          "Returns a concrete type hidden behind a protocol",
          "Returns any type conforming to the protocol at runtime",
          "Returns a type-erased wrapper",
          "Returns a generic parameter"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Opaque types hide the concrete type while keeping it consistent."
      },
      {
        "id": "Swift_116",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "What does Task.sleep(nanoseconds:) do?",
        "options": [
          "Suspends the current task without blocking a thread",
          "Blocks the current thread",
          "Cancels the current task",
          "Runs work on the main actor"
        ],
        "correctAnswerIndex": 0,
        "explanation": "It suspends the task cooperatively, not the underlying thread."
      },
      {
        "id": "Swift_117",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Hard",
        "questionText": "In Swift concurrency, what does Task.checkCancellation() typically do?",
        "options": [
          "Throws CancellationError if the task was cancelled",
          "Stops the thread immediately",
          "Marks the task as detached",
          "Resets cancellation state"
        ],
        "correctAnswerIndex": 0,
        "explanation": "It enforces cooperative cancellation by throwing when cancelled."
      },
      {
        "id": "Swift_118",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "Why is associatedtype often used in protocols?",
        "options": [
          "To express placeholder types for conformers",
          "To enable inheritance between structs",
          "To force dynamic dispatch",
          "To remove the need for generics"
        ],
        "correctAnswerIndex": 0,
        "explanation": "associatedtype lets conforming types specify concrete types."
      },
      {
        "id": "Swift_119",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "What is the main purpose of protocol composition (A & B)?",
        "options": [
          "Require conformance to multiple protocols",
          "Create a new protocol type permanently",
          "Enable subclassing multiple classes",
          "Perform runtime type erasure"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Composition expresses “must conform to all listed protocols.”"
      },
      {
        "id": "Swift_120",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Hard",
        "questionText": "Why can using existential types (any Protocol) be slower than generics?",
        "options": [
          "It may require dynamic dispatch and boxing",
          "It always forces main-thread execution",
          "It disables ARC optimizations",
          "It prevents inlining of all functions"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Existentials can introduce dynamic dispatch and heap allocations."
      },

      {
        "id": "Swift_121",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "What is a common pitfall when using weak self with guard let self = self else { return }?",
        "options": [
          "It can extend lifetime only for the closure duration, but still must avoid nested escapes",
          "It guarantees no retain cycle in all cases",
          "It converts self into an unowned reference",
          "It makes self thread-safe automatically"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Strongly binding self is safe in-scope, but nested escaping closures can still capture strongly."
      },
      {
        "id": "Swift_122",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "What is a key difference between class-bound protocols and unconstrained protocols in ARC design?",
        "options": [
          "Class-bound protocols allow weak references to conformers",
          "Unconstrained protocols always use value semantics",
          "Class-bound protocols cannot have associated types",
          "Unconstrained protocols cannot be used with generics"
        ],
        "correctAnswerIndex": 0,
        "explanation": "weak only applies to reference types, so class-bound enables weak referencing."
      },
      {
        "id": "Swift_123",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "Why can Combine pipelines accidentally retain objects?",
        "options": [
          "Closures in operators can capture self strongly",
          "Schedulers always retain upstream",
          "Publishers are value types",
          "AnyCancellable cannot be released"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Operator closures often capture self; without [weak self] it can retain."
      },
      {
        "id": "Swift_124",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "What is the main reason Task.detached can be risky in app code?",
        "options": [
          "It escapes structured concurrency and may ignore actor context",
          "It always runs on main thread",
          "It cannot be cancelled",
          "It forces synchronous execution"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Detached tasks aren’t tied to a parent scope and don’t inherit isolation."
      },
      {
        "id": "Swift_125",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "What does nonisolated(unsafe) imply?",
        "options": [
          "You bypass actor isolation and accept responsibility for safety",
          "The compiler guarantees thread safety",
          "The method becomes main-thread-only",
          "The actor becomes reentrant-free"
        ],
        "correctAnswerIndex": 0,
        "explanation": "It opts out of isolation checks; misuse can cause data races."
      },
      {
        "id": "Swift_126",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "Why can TaskGroup be preferable to manually tracking multiple Tasks?",
        "options": [
          "It provides structured waiting and cancellation propagation",
          "It forces sequential execution",
          "It eliminates the need for await",
          "It guarantees identical scheduling order"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Task groups tie child tasks to scope and propagate cancellation/errors."
      },
      {
        "id": "Swift_127",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "In Combine, what does share() primarily do?",
        "options": [
          "Shares a single upstream subscription among multiple subscribers",
          "Duplicates emissions per subscriber",
          "Converts to a Subject automatically",
          "Guarantees replay of last value"
        ],
        "correctAnswerIndex": 0,
        "explanation": "share() prevents multiple subscriptions to an upstream publisher."
      },
      {
        "id": "Swift_128",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "What is a key drawback of using Subjects extensively in Combine architecture?",
        "options": [
          "They can break declarative flow and make reasoning harder",
          "They cannot be cancelled",
          "They always leak memory",
          "They cannot emit completion"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Subjects introduce imperative state and can complicate stream reasoning."
      },
      {
        "id": "Swift_129",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "Why can capturing a mutable var in a concurrent context be unsafe?",
        "options": [
          "Mutations can interleave causing data races",
          "Swift copies all vars automatically",
          "ARC will deallocate it early",
          "The compiler always locks access"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Concurrent reads/writes without isolation can cause data races."
      },
      {
        "id": "Swift_130",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "What is the core idea of \"actor isolation\"?",
        "options": [
          "Only one task at a time can access an actor’s mutable state",
          "Actors block threads to prevent concurrency",
          "Actors copy state on every call",
          "Actors cannot call async functions"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Actor isolation serializes access to its state, preventing data races."
      },

      {
        "id": "Swift_131",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "Which keyword is used to define a generic type parameter constraint?",
        "options": ["where", "limit", "constraint", "bound"],
        "correctAnswerIndex": 0,
        "explanation": "where adds constraints to generics and associated types."
      },
      {
        "id": "Swift_132",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "What does the operator ... represent in Swift ranges?",
        "options": ["Closed range (includes end)", "Half-open range", "Infinite range", "Step range"],
        "correctAnswerIndex": 0,
        "explanation": "A closed range includes both start and end values."
      },
      {
        "id": "Swift_133",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Normal",
        "questionText": "What does the operator ..< represent in Swift ranges?",
        "options": ["Half-open range (excludes end)", "Closed range", "Open range (excludes both)", "Stride range"],
        "correctAnswerIndex": 0,
        "explanation": "A half-open range includes start but excludes the end."
      },
      {
        "id": "Swift_134",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "Which keyword makes a function parameter label optional in calls?",
        "options": ["_", "label", "nil", "omit"],
        "correctAnswerIndex": 0,
        "explanation": "Using _ removes the external parameter label."
      },
      {
        "id": "Swift_135",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "What does the @escaping attribute indicate?",
        "options": [
          "A closure may outlive the function call",
          "A closure runs on the main thread",
          "A closure cannot capture self",
          "A closure is always async"
        ],
        "correctAnswerIndex": 0,
        "explanation": "@escaping means the closure can be stored and executed later."
      },

      {
        "id": "Swift_136",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "Why is [weak self] commonly used in Combine sink closures?",
        "options": [
          "To avoid retaining self and causing a memory leak",
          "To improve stream throughput",
          "To guarantee main thread updates",
          "To convert errors to nil"
        ],
        "correctAnswerIndex": 0,
        "explanation": "sink closures can capture self strongly and form a retain cycle."
      },
      {
        "id": "Swift_137",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Hard",
        "questionText": "What is the key difference between CurrentValueSubject and PassthroughSubject?",
        "options": [
          "CurrentValueSubject stores the latest value; PassthroughSubject does not",
          "PassthroughSubject replays the last value; CurrentValueSubject does not",
          "CurrentValueSubject cannot complete",
          "PassthroughSubject cannot have subscribers"
        ],
        "correctAnswerIndex": 0,
        "explanation": "CurrentValueSubject retains a current value and replays it to new subscribers."
      },
      {
        "id": "Swift_138",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "What does @Published do in Combine?",
        "options": [
          "Creates a publisher for a property’s changes",
          "Makes a property thread-safe",
          "Stores values in UserDefaults",
          "Automatically debounces changes"
        ],
        "correctAnswerIndex": 0,
        "explanation": "@Published exposes a property publisher that emits on changes."
      },
      {
        "id": "Swift_139",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "What does the operator tryMap do in Combine?",
        "options": [
          "Transforms values and can throw errors",
          "Transforms errors into values",
          "Retries the upstream publisher",
          "Type-erases the publisher"
        ],
        "correctAnswerIndex": 0,
        "explanation": "tryMap allows throwing from the transform and sends failures downstream."
      },
      {
        "id": "Swift_140",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "Why are actors preferred over locks in Swift concurrency?",
        "options": [
          "They provide language-level isolation and safer APIs",
          "They are always faster than locks",
          "They prevent task cancellation",
          "They eliminate the need for async/await"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Actors provide structured, compiler-checked isolation semantics."
      },

      {
        "id": "Swift_141",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "Why is using any Protocol different from some Protocol in return positions?",
        "options": [
          "any allows multiple underlying types; some is a single hidden concrete type",
          "some allows multiple underlying types; any is fixed",
          "any is faster due to specialization",
          "some always uses dynamic dispatch"
        ],
        "correctAnswerIndex": 0,
        "explanation": "some preserves a single concrete type; any is an existential container."
      },
      {
        "id": "Swift_142",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "What is a subtle pitfall with TaskLocal values?",
        "options": [
          "They can be unintentionally inherited by child tasks",
          "They are global across the process always",
          "They cannot be read in async code",
          "They disable actor isolation"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Task-local values propagate through structured concurrency unless carefully scoped."
      },
      {
        "id": "Swift_143",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "In Combine, what is the main difference between merge and zip?",
        "options": [
          "merge interleaves values; zip pairs values by index/time alignment",
          "zip interleaves values; merge pairs values",
          "merge requires identical schedules; zip does not",
          "zip ignores completion; merge does not"
        ],
        "correctAnswerIndex": 0,
        "explanation": "merge forwards values as they arrive; zip waits to pair one from each."
      },
      {
        "id": "Swift_144",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "Why can using UnsafeMutablePointer be dangerous in Swift?",
        "options": [
          "It can violate memory safety rules",
          "It automatically leaks memory",
          "It forces ARC to stop working",
          "It converts value types to reference types"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Unsafe pointers can lead to undefined behavior if misused."
      },
      {
        "id": "Swift_145",
        "category": "Swift",
        "baseDifficulty": "Hard",
        "targetLevel": "Hard",
        "questionText": "What is a key reason to avoid blocking calls inside async functions?",
        "options": [
          "It can stall cooperative executors and reduce concurrency",
          "It prevents ARC deallocation",
          "It forces main-thread execution",
          "It makes Optionals unsafe"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Blocking defeats cooperative scheduling and can starve other tasks."
      },

      {
        "id": "Swift_146",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Easy",
        "questionText": "Which statement creates a tuple in Swift?",
        "options": ["(1, \"a\")", "[1, \"a\"]", "{1, \"a\"}", "<1, \"a\">"],
        "correctAnswerIndex": 0,
        "explanation": "Tuples use parentheses to group multiple values."
      },
      {
        "id": "Swift_147",
        "category": "Swift",
        "baseDifficulty": "Easy",
        "targetLevel": "Normal",
        "questionText": "What does the keyword static mean for a property on a type?",
        "options": [
          "It belongs to the type, not instances",
          "It is immutable",
          "It is lazily loaded always",
          "It is thread-safe"
        ],
        "correctAnswerIndex": 0,
        "explanation": "static members are accessed on the type itself."
      },
      {
        "id": "Swift_148",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Normal",
        "questionText": "What is the main difference between map and flatMap on sequences?",
        "options": [
          "flatMap flattens one level of nesting after mapping",
          "map removes nil values automatically",
          "flatMap sorts the output",
          "map creates publishers"
        ],
        "correctAnswerIndex": 0,
        "explanation": "flatMap maps and flattens nested results into a single sequence."
      },
      {
        "id": "Swift_149",
        "category": "Swift",
        "baseDifficulty": "Normal",
        "targetLevel": "Hard",
        "questionText": "Why can using unowned in asynchronous callbacks be risky?",
        "options": [
          "The object may deallocate before the callback runs",
          "It increases retain count too much",
          "It makes self optional",
          "It forces main-thread execution"
        ],
        "correctAnswerIndex": 0,
        "explanation": "Async timing can outlive the object; unowned would crash if accessed."
      },
      {
          "id": "Swift_150",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "What is the main advantage of using generics over protocol existentials for performance-critical code?",
          "options": [
              "Compile-time specialization and static dispatch",
              "Automatic thread safety",
              "Reduced need for async/await",
              "Elimination of optionals"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Generics allow the compiler to specialize code for concrete types."
      },
        {
          "id": "Swift_151",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "Which keyword declares an immutable stored property?",
          "options": ["let", "var", "static", "final"],
          "correctAnswerIndex": 0,
          "explanation": "let declares a constant that cannot be reassigned."
        },
        {
          "id": "Swift_152",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "What does the keyword break do in a loop?",
          "options": ["Terminates the loop immediately", "Skips current iteration", "Pauses execution", "Exits the function"],
          "correctAnswerIndex": 0,
          "explanation": "break exits the nearest enclosing loop or switch."
        },
        {
          "id": "Swift_153",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Normal",
          "questionText": "Which Swift type represents a function that takes no parameters and returns nothing?",
          "options": ["() -> Void", "Void -> Void", "(Void)", "() -> ()"],
          "correctAnswerIndex": 0,
          "explanation": "Void is an alias for (), so () -> Void is correct."
        },
        {
          "id": "Swift_154",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "Which keyword is used to exit the current function early?",
          "options": ["return", "break", "continue", "exit"],
          "correctAnswerIndex": 0,
          "explanation": "return exits the current function scope."
        },
        {
          "id": "Swift_155",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "What does the keyword continue do in a loop?",
          "options": ["Skips to the next iteration", "Ends the loop", "Restarts the loop", "Exits the function"],
          "correctAnswerIndex": 0,
          "explanation": "continue skips the current iteration and proceeds to the next."
        },
        {
          "id": "Swift_156",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Normal",
          "questionText": "Which access level restricts usage to the same source file?",
          "options": ["fileprivate", "private", "internal", "public"],
          "correctAnswerIndex": 0,
          "explanation": "fileprivate limits access to the same file."
        },
        {
          "id": "Swift_157",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "Which keyword indicates a type cannot be inherited?",
          "options": ["final", "sealed", "closed", "static"],
          "correctAnswerIndex": 0,
          "explanation": "final prevents subclassing and method overriding."
        },
        {
          "id": "Swift_158",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "What does Optional chaining return if any link is nil?",
          "options": ["nil", "false", "0", "A runtime error"],
          "correctAnswerIndex": 0,
          "explanation": "Optional chaining safely returns nil when a link is nil."
        },
        {
          "id": "Swift_159",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Normal",
          "questionText": "Which keyword allows pattern matching on values?",
          "options": ["case", "match", "pattern", "where"],
          "correctAnswerIndex": 0,
          "explanation": "case is used in switch statements for pattern matching."
        },
        {
          "id": "Swift_160",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "Which type represents an unordered collection of unique values?",
          "options": ["Set", "Array", "Dictionary", "Tuple"],
          "correctAnswerIndex": 0,
          "explanation": "Set stores unique elements without guaranteed order."
        },

        {
          "id": "Swift_161",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "Why are escaping closures required to explicitly capture self?",
          "options": [
            "They may outlive the scope and retain captured references",
            "They always run on another thread",
            "They disable ARC automatically",
            "They cannot access instance properties"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Escaping closures can outlive the function call and retain objects."
        },
        {
          "id": "Swift_162",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "What is the primary purpose of weak references in ARC?",
          "options": [
            "Prevent retain cycles",
            "Improve performance",
            "Ensure thread safety",
            "Delay deallocation"
          ],
          "correctAnswerIndex": 0,
          "explanation": "weak references avoid increasing the reference count."
        },
        {
          "id": "Swift_163",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Hard",
          "questionText": "Why is using unowned self unsafe in delayed asynchronous callbacks?",
          "options": [
            "self may be deallocated before callback execution",
            "unowned increases retain count",
            "unowned becomes optional automatically",
            "ARC delays deallocation"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Accessing a deallocated unowned reference causes a crash."
        },
        {
          "id": "Swift_164",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "What does Combine's throttle operator do?",
          "options": [
            "Limits emissions to a fixed time interval",
            "Buffers all values",
            "Drops upstream publishers",
            "Merges multiple streams"
          ],
          "correctAnswerIndex": 0,
          "explanation": "throttle controls how frequently values are emitted."
        },
        {
          "id": "Swift_165",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "What does the sink operator do in Combine?",
          "options": [
            "Subscribes and handles values and completion",
            "Transforms values",
            "Schedules upstream work",
            "Buffers emissions"
          ],
          "correctAnswerIndex": 0,
          "explanation": "sink attaches a subscriber to receive values and completion."
        },
        {
          "id": "Swift_166",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "Why are value types preferred when passing data between tasks?",
          "options": [
            "They avoid shared mutable state",
            "They are automatically thread-safe",
            "They reduce task creation cost",
            "They eliminate copying"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Value semantics prevent unintended shared mutations."
        },
        {
          "id": "Swift_167",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Hard",
          "questionText": "What is the main purpose of TaskGroup?",
          "options": [
            "Manage multiple child tasks with structured lifetime",
            "Run tasks sequentially",
            "Replace DispatchGroup",
            "Ensure main-thread execution"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Task groups provide structured concurrency for multiple tasks."
        },
        {
          "id": "Swift_168",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "Why is Codable often preferred for data models?",
          "options": [
            "Automatic serialization and deserialization",
            "Thread safety",
            "Dynamic dispatch",
            "ARC optimization"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Codable simplifies encoding/decoding with minimal boilerplate."
        },
        {
          "id": "Swift_169",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "What does the operator ~= do in Swift?",
          "options": [
            "Pattern matching comparison",
            "Assignment",
            "Reference comparison",
            "Bitwise OR"
          ],
          "correctAnswerIndex": 0,
          "explanation": "~= is used internally for pattern matching in switch."
        },
        {
          "id": "Swift_170",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Hard",
          "questionText": "Why can using existential any Protocol reduce optimization opportunities?",
          "options": [
            "The concrete type is unknown at compile time",
            "ARC cannot manage memory",
            "Protocols disable generics",
            "Dispatch becomes synchronous"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Unknown concrete types prevent specialization and inlining."
        },

        {
          "id": "Swift_171",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "What is a subtle issue with actor reentrancy?",
          "options": [
            "State can change between await points",
            "Actors block all threads",
            "Actors cannot call async methods",
            "Actors always serialize tasks fully"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Other tasks may run while an actor awaits."
        },
        {
          "id": "Swift_172",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "Why should blocking I/O be avoided inside async functions?",
          "options": [
            "It blocks cooperative executors",
            "It disables ARC",
            "It forces main-thread execution",
            "It prevents cancellation"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Blocking defeats async scheduling and reduces concurrency."
        },
        {
          "id": "Swift_173",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "What risk comes with using UnsafePointer APIs?",
          "options": [
            "Undefined behavior and memory safety violations",
            "Guaranteed memory leaks",
            "Compile-time crashes",
            "Automatic thread blocking"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Unsafe APIs bypass Swift’s memory safety guarantees."
        },
        {
          "id": "Swift_174",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "Why can Combine pipelines be hard to debug?",
          "options": [
            "Asynchronous and declarative flow obscures control path",
            "Publishers hide values",
            "Errors are ignored",
            "Schedulers are implicit"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Declarative async streams can obscure execution order."
        },
        {
          "id": "Swift_175",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "What is the main downside of overusing Subjects in Combine?",
          "options": [
            "Loss of declarative data flow",
            "Inability to complete streams",
            "Memory leaks by default",
            "No support for backpressure"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Subjects introduce imperative state into reactive pipelines."
        },
        {
          "id": "Swift_176",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "Why is Sendable important for value types in concurrency?",
          "options": [
            "It guarantees safe transfer across tasks",
            "It enforces immutability",
            "It disables ARC",
            "It forces main-thread usage"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Sendable ensures values can be safely shared between tasks."
        },
        {
          "id": "Swift_177",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "What is a common mistake when using withCheckedContinuation?",
          "options": [
            "Failing to resume exactly once",
            "Blocking the thread",
            "Calling from main actor",
            "Using weak self"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Continuations must be resumed once or the task may hang."
        },
        {
          "id": "Swift_178",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "Why can nested Task.detached calls be problematic?",
          "options": [
            "They escape structured cancellation and ownership",
            "They always block the main thread",
            "They disable actor isolation",
            "They leak memory automatically"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Detached tasks are not bound to parent task lifetimes."
        },
        {
          "id": "Swift_179",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "What is the cost of excessive dynamic dispatch in protocol-heavy code?",
          "options": [
            "Runtime overhead and reduced optimization",
            "Compile-time crashes",
            "ARC instability",
            "Deadlocks"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Dynamic dispatch limits compiler optimizations."
        },
        {
          "id": "Swift_180",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "Why is immutability encouraged in concurrent Swift code?",
          "options": [
            "It prevents data races",
            "It improves ARC performance",
            "It avoids async/await",
            "It eliminates copying"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Immutable data cannot be corrupted by concurrent mutation."
        },

        {
          "id": "Swift_181",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "Which operator unwraps an Optional unsafely?",
          "options": ["!", "??", "as?", "try?"],
          "correctAnswerIndex": 0,
          "explanation": "! force unwraps and can crash if nil."
        },
        {
          "id": "Swift_182",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Normal",
          "questionText": "Which keyword allows extending a type’s behavior?",
          "options": ["extension", "override", "protocol", "static"],
          "correctAnswerIndex": 0,
          "explanation": "extension adds new functionality to existing types."
        },
        {
          "id": "Swift_183",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "What does the operator ?? do?",
          "options": ["Provides a default for nil Optionals", "Force unwraps", "Casts types", "Compares values"],
          "correctAnswerIndex": 0,
          "explanation": "Nil-coalescing returns a fallback value."
        },
        {
          "id": "Swift_184",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "Which statement is guaranteed to execute at scope exit?",
          "options": ["defer", "finally", "return", "cleanup"],
          "correctAnswerIndex": 0,
          "explanation": "defer runs when leaving the current scope."
        },
        {
          "id": "Swift_185",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Normal",
          "questionText": "What does the keyword where add to generics?",
          "options": [
            "Additional constraints",
            "Runtime checks",
            "Inheritance rules",
            "Memory guarantees"
          ],
          "correctAnswerIndex": 0,
          "explanation": "where clauses refine generic constraints."
        },

        {
          "id": "Swift_186",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "Why should closures capturing self be reviewed carefully?",
          "options": [
            "They can create retain cycles",
            "They slow down execution",
            "They prevent async usage",
            "They disable ARC"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Strong captures can prevent deallocation."
        },
        {
          "id": "Swift_187",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Hard",
          "questionText": "Why can storing AnyCancellable in a long-lived object be risky?",
          "options": [
            "Subscriptions may never be cancelled",
            "It forces main-thread execution",
            "It causes immediate cancellation",
            "It disables backpressure"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Retained cancellables keep subscriptions alive."
        },
        {
          "id": "Swift_188",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "What does async let require before use of its value?",
          "options": ["await", "try", "Task.checkCancellation()", "DispatchQueue"],
          "correctAnswerIndex": 0,
          "explanation": "async let values must be awaited before access."
        },
        {
          "id": "Swift_189",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Hard",
          "questionText": "Why can mixing GCD and Swift concurrency be dangerous?",
          "options": [
            "It can break actor isolation assumptions",
            "It always causes deadlocks",
            "It disables ARC",
            "It makes tasks synchronous"
          ],
          "correctAnswerIndex": 0,
          "explanation": "GCD does not respect actor isolation rules."
        },
        {
          "id": "Swift_190",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "What does @MainActor guarantee?",
          "options": [
            "Execution on the main actor",
            "Synchronous execution",
            "No suspension points",
            "Thread safety everywhere"
          ],
          "correctAnswerIndex": 0,
          "explanation": "@MainActor ensures code runs on the main actor."
        },

        {
          "id": "Swift_191",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "Why can TaskLocal values be hard to reason about?",
          "options": [
            "They propagate implicitly through async call chains",
            "They are global variables",
            "They cannot be read concurrently",
            "They disable isolation"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Implicit propagation can cause hidden dependencies."
        },
        {
          "id": "Swift_192",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "What is the biggest risk of force-unwrapping Optionals in concurrent code?",
          "options": [
            "State may change before access, causing crashes",
            "ARC may deallocate early",
            "Threads will deadlock",
            "Compilation will fail"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Concurrency can change state timing unpredictably."
        },
        {
          "id": "Swift_193",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "Why can value-type mutation across awaits be disallowed by the compiler?",
          "options": [
            "To prevent data races and undefined behavior",
            "To improve ARC performance",
            "To simplify syntax",
            "To force immutability always"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Swift enforces safety across suspension points."
        },
        {
          "id": "Swift_194",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "What problem does isolation inheritance solve?",
          "options": [
            "Maintains actor isolation across async calls",
            "Improves performance",
            "Prevents memory leaks",
            "Avoids optional unwrapping"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Isolation inheritance keeps concurrency guarantees intact."
        },
        {
          "id": "Swift_195",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "Why should you avoid long synchronous work inside actors?",
          "options": [
            "It blocks access to actor state",
            "It disables ARC",
            "It prevents async/await",
            "It forces deinitialization"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Actors serialize access; long work reduces concurrency."
        },

        {
          "id": "Swift_196",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "Which keyword allows a property to be overridden?",
          "options": ["open", "public", "final", "static"],
          "correctAnswerIndex": 0,
          "explanation": "open allows overriding outside the defining module."
        },
        {
          "id": "Swift_197",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Normal",
          "questionText": "What does the operator === compare?",
          "options": [
            "Reference identity",
            "Value equality",
            "Type equality",
            "Hash equality"
          ],
          "correctAnswerIndex": 0,
          "explanation": "=== checks whether two references point to the same instance."
        },
        {
          "id": "Swift_198",
          "category": "Swift",
          "baseDifficulty": "Easy",
          "targetLevel": "Easy",
          "questionText": "Which statement checks for pattern matching in switch cases?",
          "options": ["where", "if", "guard", "else"],
          "correctAnswerIndex": 0,
          "explanation": "where adds conditional logic to case patterns."
        },
        {
          "id": "Swift_199",
          "category": "Swift",
          "baseDifficulty": "Normal",
          "targetLevel": "Normal",
          "questionText": "Why is throwing preferred over returning Optional for errors?",
          "options": [
            "Errors carry context and enforce handling",
            "Optionals are slower",
            "ARC requires it",
            "It avoids generics"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Errors provide richer failure information."
        },
        {
          "id": "Swift_200",
          "category": "Swift",
          "baseDifficulty": "Hard",
          "targetLevel": "Hard",
          "questionText": "What is the main benefit of protocol-oriented design in large Swift codebases?",
          "options": [
            "Loose coupling and testability",
            "Faster compilation always",
            "Elimination of ARC",
            "Automatic concurrency safety"
          ],
          "correctAnswerIndex": 0,
          "explanation": "Protocols reduce coupling and improve testability."
        },
          {
            "id": "CS_001",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "What is the primary purpose of a process in an OS?",
            "options": [
              "An instance of a program in execution",
              "A compiled binary stored on disk",
              "A set of CPU instructions in cache only",
              "A network connection endpoint"
            ],
            "correctAnswerIndex": 0,
            "explanation": "A process is a running program with its own execution state and resources."
          },
          {
            "id": "CS_002",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "Which component translates domain names to IP addresses?",
            "options": ["DNS", "DHCP", "NAT", "ARP"],
            "correctAnswerIndex": 0,
            "explanation": "DNS resolves human-readable domain names into IP addresses."
          },
          {
            "id": "CS_003",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Normal",
            "questionText": "What does ACID in databases primarily guarantee?",
            "options": [
              "Reliable transaction behavior",
              "Fast query performance",
              "Automatic schema migration",
              "Unlimited horizontal scaling"
            ],
            "correctAnswerIndex": 0,
            "explanation": "ACID properties ensure transactions are processed reliably and consistently."
          },
          {
            "id": "CS_004",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "Which protocol is connection-oriented?",
            "options": ["TCP", "UDP", "ICMP", "ARP"],
            "correctAnswerIndex": 0,
            "explanation": "TCP establishes a connection and provides reliable, ordered delivery."
          },
          {
            "id": "CS_005",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "In memory management, what is a stack typically used for?",
            "options": [
              "Function call frames and local variables",
              "Long-lived objects shared across threads",
              "Storing database indexes",
              "Persisting data after reboot"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Stacks store call frames and local variables with LIFO allocation."
          },
          {
            "id": "CS_006",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "What is a context switch?",
            "options": [
              "Switching CPU execution from one process/thread to another",
              "Replacing RAM with disk storage",
              "Changing IP addresses on a host",
              "Rebuilding a database index"
            ],
            "correctAnswerIndex": 0,
            "explanation": "A context switch saves/restores execution state to run another task."
          },
          {
            "id": "CS_007",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Normal",
            "questionText": "Which database object improves lookup speed on a column?",
            "options": ["Index", "Trigger", "View", "Stored procedure"],
            "correctAnswerIndex": 0,
            "explanation": "Indexes speed up reads by providing efficient access paths."
          },
          {
            "id": "CS_008",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "What does DHCP primarily provide?",
            "options": [
              "Automatic IP address assignment",
              "Domain name resolution",
              "Encrypted transport",
              "Packet fragmentation"
            ],
            "correctAnswerIndex": 0,
            "explanation": "DHCP assigns IP configuration (IP, gateway, DNS) automatically."
          },
          {
            "id": "CS_009",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "What is a deadlock?",
            "options": [
              "A set of tasks waiting indefinitely for each other’s resources",
              "A CPU running at 100% utilization",
              "A database transaction that commits too slowly",
              "A network packet that arrives out of order"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Deadlock occurs when tasks hold resources and wait in a cycle."
          },
          {
            "id": "CS_010",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "Which SQL clause filters rows before aggregation?",
            "options": ["WHERE", "HAVING", "ORDER BY", "GROUP BY"],
            "correctAnswerIndex": 0,
            "explanation": "WHERE filters rows prior to GROUP BY and aggregation."
          },

          {
            "id": "CS_011",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "Which scheduling strategy can cause starvation if not controlled?",
            "options": [
              "Priority scheduling",
              "Round-robin scheduling",
              "FCFS scheduling",
              "Lottery scheduling"
            ],
            "correctAnswerIndex": 0,
            "explanation": "High-priority tasks can starve low-priority tasks without aging."
          },
          {
            "id": "CS_012",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What does ARP do on a local network?",
            "options": [
              "Maps IP addresses to MAC addresses",
              "Assigns IP addresses to clients",
              "Encrypts traffic between hosts",
              "Routes packets between subnets"
            ],
            "correctAnswerIndex": 0,
            "explanation": "ARP resolves a local IP address to a hardware (MAC) address."
          },
          {
            "id": "CS_013",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Hard",
            "questionText": "In a database, what is a primary key primarily used for?",
            "options": [
              "Uniquely identifying each row",
              "Storing encrypted data",
              "Improving write throughput",
              "Defining query execution order"
            ],
            "correctAnswerIndex": 0,
            "explanation": "A primary key uniquely identifies rows and enforces entity integrity."
          },
          {
            "id": "CS_014",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What does virtual memory enable?",
            "options": [
              "Processes to use a logical address space independent of physical RAM",
              "Packets to be routed between networks",
              "Transactions to be isolated in databases",
              "CPUs to run at higher clock speeds"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Virtual memory abstracts physical RAM and supports isolation and paging."
          },
          {
            "id": "CS_015",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What is the key difference between a process and a thread?",
            "options": [
              "Threads share a process address space; processes have separate address spaces",
              "Processes share stacks; threads do not",
              "Threads are always slower than processes",
              "Processes cannot run concurrently"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Threads share memory within a process; processes are isolated."
          },
          {
            "id": "CS_016",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What does a TCP three-way handshake establish?",
            "options": [
              "A reliable connection with synchronized sequence numbers",
              "A MAC address mapping",
              "A DNS cache entry",
              "A NAT translation table"
            ],
            "correctAnswerIndex": 0,
            "explanation": "SYN/SYN-ACK/ACK establishes a TCP session and initial sequencing."
          },
          {
            "id": "CS_017",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Hard",
            "questionText": "Which SQL isolation level typically prevents dirty reads?",
            "options": ["READ COMMITTED", "READ UNCOMMITTED", "NONE", "EVENTUAL"],
            "correctAnswerIndex": 0,
            "explanation": "READ COMMITTED prevents reading uncommitted (dirty) changes."
          },
          {
            "id": "CS_018",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What is a page fault?",
            "options": [
              "Access to a virtual memory page not currently in RAM",
              "A CPU arithmetic error",
              "A corrupted database page on disk",
              "A dropped TCP segment"
            ],
            "correctAnswerIndex": 0,
            "explanation": "A page fault occurs when the needed page must be loaded into RAM."
          },
          {
            "id": "CS_019",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What is the purpose of a mutex?",
            "options": [
              "Mutual exclusion to protect a critical section",
              "Queueing network packets in order",
              "Encrypting data in transit",
              "Indexing rows in a database table"
            ],
            "correctAnswerIndex": 0,
            "explanation": "A mutex ensures only one thread enters a critical section at a time."
          },
          {
            "id": "CS_020",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What does NAT primarily do in networking?",
            "options": [
              "Translates private IPs to a public IP for outbound traffic",
              "Resolves domain names to IP addresses",
              "Ensures end-to-end encryption",
              "Provides congestion control for TCP"
            ],
            "correctAnswerIndex": 0,
            "explanation": "NAT rewrites IP/port information to allow private networks to access the internet."
          },

          {
            "id": "CS_021",
            "category": "Computer Science",
            "baseDifficulty": "Hard",
            "targetLevel": "Hard",
            "questionText": "Which deadlock condition is eliminated by using a strict global lock acquisition order?",
            "options": [
              "Circular wait",
              "Mutual exclusion",
              "Hold and wait",
              "No preemption"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Ordering resource acquisition prevents cycles in the wait graph."
          },
          {
            "id": "CS_022",
            "category": "Computer Science",
            "baseDifficulty": "Hard",
            "targetLevel": "Hard",
            "questionText": "In TCP, what is the role of congestion control (e.g., slow start)?",
            "options": [
              "Adjust sending rate based on perceived network capacity",
              "Encrypt payloads to prevent sniffing",
              "Guarantee zero packet loss",
              "Replace routing protocols"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Congestion control adapts the sender’s rate to avoid overloading the network."
          },
          {
            "id": "CS_023",
            "category": "Computer Science",
            "baseDifficulty": "Hard",
            "targetLevel": "Hard",
            "questionText": "Which index structure is most commonly used in relational databases for range queries?",
            "options": ["B+ tree", "Hash index", "Bloom filter", "Skip list cache"],
            "correctAnswerIndex": 0,
            "explanation": "B+ trees maintain sorted order, making range scans efficient."
          },
          {
            "id": "CS_024",
            "category": "Computer Science",
            "baseDifficulty": "Hard",
            "targetLevel": "Hard",
            "questionText": "What is TLB thrashing most closely associated with?",
            "options": [
              "Excessive misses in the Translation Lookaside Buffer",
              "Excessive CPU cache line evictions",
              "Excessive TCP retransmissions",
              "Excessive database lock escalation"
            ],
            "correctAnswerIndex": 0,
            "explanation": "TLB thrashing occurs when address translation entries churn heavily, increasing misses."
          },
          {
            "id": "CS_025",
            "category": "Computer Science",
            "baseDifficulty": "Hard",
            "targetLevel": "Hard",
            "questionText": "In MVCC databases, what does snapshot isolation primarily provide?",
            "options": [
              "Reads see a consistent snapshot without blocking writers",
              "All anomalies are prevented like serializable isolation",
              "Writers never conflict with each other",
              "Dirty reads are allowed for performance"
            ],
            "correctAnswerIndex": 0,
            "explanation": "MVCC lets readers see a stable snapshot while writers proceed concurrently."
          },
          {
            "id": "CS_026",
            "category": "Computer Science",
            "baseDifficulty": "Hard",
            "targetLevel": "Hard",
            "questionText": "What problem does copy-on-write (CoW) primarily solve?",
            "options": [
              "Avoids copying memory until a write occurs",
              "Guarantees lock-free synchronization",
              "Eliminates page faults entirely",
              "Prevents SQL deadlocks"
            ],
            "correctAnswerIndex": 0,
            "explanation": "CoW shares pages until modification, reducing unnecessary copies."
          },
          {
            "id": "CS_027",
            "category": "Computer Science",
            "baseDifficulty": "Hard",
            "targetLevel": "Hard",
            "questionText": "What is the key benefit of using epoll/kqueue over one-thread-per-connection?",
            "options": [
              "Scales to many connections with fewer threads",
              "Guarantees no packet loss",
              "Automatically encrypts connections",
              "Eliminates the need for TCP"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Event-driven I/O multiplexing reduces thread overhead for many sockets."
          },
          {
            "id": "CS_028",
            "category": "Computer Science",
            "baseDifficulty": "Hard",
            "targetLevel": "Hard",
            "questionText": "What does write-ahead logging (WAL) ensure?",
            "options": [
              "Durability by logging changes before applying them to data pages",
              "Faster SELECT queries by precomputing joins",
              "Eliminating the need for indexes",
              "Preventing all deadlocks automatically"
            ],
            "correctAnswerIndex": 0,
            "explanation": "WAL enables crash recovery because logs persist before data is updated."
          },
          {
            "id": "CS_029",
            "category": "Computer Science",
            "baseDifficulty": "Hard",
            "targetLevel": "Hard",
            "questionText": "In OS memory management, what does 'working set' refer to?",
            "options": [
              "The set of pages a process actively uses in a time window",
              "The maximum virtual address space available",
              "The bytes currently in CPU registers",
              "The files opened by the process"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Working set approximates the pages needed to run efficiently without paging."
          },
          {
            "id": "CS_030",
            "category": "Computer Science",
            "baseDifficulty": "Hard",
            "targetLevel": "Hard",
            "questionText": "What is a classic downside of strict two-phase locking (2PL)?",
            "options": [
              "It can reduce concurrency due to lock holding until commit",
              "It allows dirty reads by design",
              "It breaks durability guarantees",
              "It prevents index usage"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Holding locks until commit reduces concurrency and can increase contention."
          },

          {
            "id": "CS_031",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "Which OS component is responsible for managing hardware resources?",
            "options": ["Kernel", "Shell", "Compiler", "Hypervisor"],
            "correctAnswerIndex": 0,
            "explanation": "The kernel manages CPU, memory, devices, and scheduling."
          },
          {
            "id": "CS_032",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Normal",
            "questionText": "What does UDP primarily trade off compared to TCP?",
            "options": [
              "Reliability and ordering for lower overhead",
              "Security for speed",
              "Addressability for simplicity",
              "Bandwidth for latency"
            ],
            "correctAnswerIndex": 0,
            "explanation": "UDP is connectionless and does not guarantee delivery or order."
          },
          {
            "id": "CS_033",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "Which SQL command is used to remove rows from a table without dropping the table?",
            "options": ["DELETE", "DROP", "TRUNCATE TABLESPACE", "DETACH"],
            "correctAnswerIndex": 0,
            "explanation": "DELETE removes rows (optionally with a WHERE clause) while keeping the table."
          },
          {
            "id": "CS_034",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "What does a semaphore primarily control?",
            "options": [
              "Access to a limited number of shared resources",
              "DNS name resolution",
              "Database schema migration",
              "CPU instruction pipelining"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Semaphores manage concurrent access counts to shared resources."
          },
          {
            "id": "CS_035",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "Which layer does IP operate at in the OSI model?",
            "options": ["Network layer", "Transport layer", "Data link layer", "Application layer"],
            "correctAnswerIndex": 0,
            "explanation": "IP is a network-layer protocol responsible for routing packets."
          },
          {
            "id": "CS_036",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Normal",
            "questionText": "What is the purpose of a foreign key?",
            "options": [
              "Enforce referential integrity between tables",
              "Speed up full table scans",
              "Encrypt primary keys",
              "Store computed columns"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Foreign keys ensure referenced rows exist and maintain relationships."
          },
          {
            "id": "CS_037",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "What is heap memory typically used for?",
            "options": [
              "Dynamically allocated objects with longer lifetimes",
              "CPU registers for arithmetic",
              "Storing IP routing tables",
              "Persisting data in a database"
            ],
            "correctAnswerIndex": 0,
            "explanation": "The heap stores dynamically allocated data that can outlive a function call."
          },
          {
            "id": "CS_038",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "Which command is used to modify existing rows in SQL?",
            "options": ["UPDATE", "INSERT", "SELECT", "CREATE"],
            "correctAnswerIndex": 0,
            "explanation": "UPDATE changes values in existing rows, optionally filtered by WHERE."
          },
          {
            "id": "CS_039",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Normal",
            "questionText": "What is a socket in networking?",
            "options": [
              "An endpoint for sending/receiving data over a network",
              "A device driver interface",
              "A database transaction log",
              "A CPU scheduling queue"
            ],
            "correctAnswerIndex": 0,
            "explanation": "A socket represents an endpoint (IP+port/protocol) used for communication."
          },
          {
            "id": "CS_040",
            "category": "Computer Science",
            "baseDifficulty": "Easy",
            "targetLevel": "Easy",
            "questionText": "What is the main goal of caching?",
            "options": [
              "Reduce latency by storing frequently accessed data closer to compute",
              "Increase durability by writing twice",
              "Guarantee strong consistency across replicas",
              "Prevent deadlocks in concurrent programs"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Caching speeds up access by avoiding expensive repeated retrievals."
          },

          {
            "id": "CS_041",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What does a page table map in virtual memory systems?",
            "options": [
              "Virtual pages to physical frames",
              "MAC addresses to IP addresses",
              "SQL rows to index nodes",
              "Threads to CPU cores"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Page tables translate virtual addresses into physical memory locations."
          },
          {
            "id": "CS_042",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What is the primary reason for using TLS?",
            "options": [
              "Encrypt and authenticate data in transit",
              "Assign IP addresses automatically",
              "Route packets between subnets",
              "Improve query planner performance"
            ],
            "correctAnswerIndex": 0,
            "explanation": "TLS provides confidentiality and integrity for network communications."
          },
          {
            "id": "CS_043",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Hard",
            "questionText": "Which normal form primarily reduces data redundancy by removing partial dependency on a composite key?",
            "options": ["Second Normal Form (2NF)", "First Normal Form (1NF)", "Boyce-Codd Normal Form (BCNF)", "Denormalization"],
            "correctAnswerIndex": 0,
            "explanation": "2NF removes partial dependencies on a subset of a composite primary key."
          },
          {
            "id": "CS_044",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What is the difference between a binary semaphore and a mutex in practice?",
            "options": [
              "A mutex is typically owned by a thread; a binary semaphore may not enforce ownership",
              "A binary semaphore can only be used in databases",
              "A mutex cannot block",
              "A binary semaphore guarantees fairness"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Mutexes usually enforce ownership; semaphores often do not."
          },
          {
            "id": "CS_045",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What does 'idempotent' mean for an HTTP method like PUT?",
            "options": [
              "Repeated identical requests have the same effect as one request",
              "It always returns cached data",
              "It is encrypted by default",
              "It can only be used over TCP"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Idempotent operations can be safely retried without changing the final result."
          },
          {
            "id": "CS_046",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Hard",
            "questionText": "Why can an index slow down writes in a relational database?",
            "options": [
              "Indexes must be updated on INSERT/UPDATE/DELETE",
              "Indexes require full table scans",
              "Indexes disable transaction logging",
              "Indexes force serializable isolation"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Maintaining index structures adds overhead during write operations."
          },
          {
            "id": "CS_047",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "Which OS mechanism is used to prevent one process from accessing another’s memory?",
            "options": [
              "Memory protection via MMU and virtual addressing",
              "CPU pipelining",
              "Disk defragmentation",
              "DNS caching"
            ],
            "correctAnswerIndex": 0,
            "explanation": "The MMU enforces access permissions and address space isolation."
          },
          {
            "id": "CS_048",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "What is the primary function of a database transaction log?",
            "options": [
              "Support recovery and durability after crashes",
              "Reduce network latency",
              "Replace the need for indexes",
              "Automatically normalize schemas"
            ],
            "correctAnswerIndex": 0,
            "explanation": "Logs allow redo/undo during crash recovery to preserve durability."
          },
          {
            "id": "CS_049",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Hard",
            "questionText": "What is the most likely impact of false sharing between CPU cores?",
            "options": [
              "Performance degradation due to cache line invalidations",
              "Guaranteed correctness failure in memory reads",
              "Fewer context switches",
              "Lower database lock contention"
            ],
            "correctAnswerIndex": 0,
            "explanation": "False sharing triggers frequent cache invalidations even without true data sharing."
          },
          {
            "id": "CS_050",
            "category": "Computer Science",
            "baseDifficulty": "Normal",
            "targetLevel": "Normal",
            "questionText": "In networking, what does MTU represent?",
            "options": [
              "Maximum Transmission Unit (largest packet payload for a link)",
              "Minimum Time Update (routing interval)",
              "Media Transfer Utility (throughput measure)",
              "Mapped Tunnel Unit (VPN segment size)"
            ],
            "correctAnswerIndex": 0,
            "explanation": "MTU is the maximum size of a packet that can traverse a link without fragmentation."
          },
            {
              "id": "CS_051",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "What is the main purpose of an OS scheduler?",
              "options": [
                "Decide which thread/process runs on the CPU next",
                "Allocate IP addresses to clients",
                "Normalize database tables",
                "Encrypt data at rest"
              ],
              "correctAnswerIndex": 0,
              "explanation": "The scheduler selects runnable tasks to execute on the CPU."
            },
            {
              "id": "CS_052",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "Which protocol is used to transfer web pages in its classic form?",
              "options": ["HTTP", "FTP", "SMTP", "SNMP"],
              "correctAnswerIndex": 0,
              "explanation": "HTTP is the application-layer protocol used for web requests and responses."
            },
            {
              "id": "CS_053",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Normal",
              "questionText": "What does a database UNIQUE constraint enforce?",
              "options": [
                "No duplicate values in the constrained column(s)",
                "The column cannot be NULL",
                "Rows must be physically sorted",
                "Transactions must be serializable"
              ],
              "correctAnswerIndex": 0,
              "explanation": "UNIQUE ensures values don’t repeat across rows for specified columns."
            },
            {
              "id": "CS_054",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "What is a race condition?",
              "options": [
                "When outcome depends on timing/interleaving of concurrent operations",
                "When a network packet arrives late",
                "When a database index becomes fragmented",
                "When CPU cache becomes full"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Race conditions occur when concurrency timing changes program behavior."
            },
            {
              "id": "CS_055",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "Which SQL statement adds a new row to a table?",
              "options": ["INSERT", "UPDATE", "ALTER", "MERGE"],
              "correctAnswerIndex": 0,
              "explanation": "INSERT creates a new row in a table."
            },
            {
              "id": "CS_056",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "In networking, what is latency?",
              "options": [
                "Time delay between sending and receiving data",
                "Maximum bandwidth of a link",
                "Number of hops in a route",
                "Packet loss percentage"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Latency measures delay, typically in milliseconds."
            },
            {
              "id": "CS_057",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Normal",
              "questionText": "What is memory fragmentation?",
              "options": [
                "Free memory split into small non-contiguous blocks",
                "Memory encrypted into multiple segments",
                "Stack frames being reordered by the compiler",
                "Pages being swapped to SSD"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Fragmentation reduces ability to allocate large contiguous blocks efficiently."
            },
            {
              "id": "CS_058",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "What does the OSI model primarily provide?",
              "options": [
                "A conceptual framework for networking layers",
                "A database normalization standard",
                "A CPU instruction set specification",
                "A file system layout"
              ],
              "correctAnswerIndex": 0,
              "explanation": "OSI layers help reason about network protocols and responsibilities."
            },
            {
              "id": "CS_059",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "What does a NOT NULL constraint enforce?",
              "options": [
                "A column must have a value",
                "A column must be unique",
                "A table must have a primary key",
                "A transaction must commit"
              ],
              "correctAnswerIndex": 0,
              "explanation": "NOT NULL prevents storing NULL in that column."
            },
            {
              "id": "CS_060",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Normal",
              "questionText": "What is a system call?",
              "options": [
                "A controlled interface from user space to kernel services",
                "A function call optimized by the compiler",
                "A network call to a remote service",
                "A database call to execute SQL"
              ],
              "correctAnswerIndex": 0,
              "explanation": "System calls let user programs request OS services like I/O or process creation."
            },

            {
              "id": "CS_061",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What is the main difference between UDP and TCP regarding delivery guarantees?",
              "options": [
                "TCP provides reliable delivery; UDP does not",
                "UDP guarantees ordering; TCP does not",
                "UDP retransmits lost packets; TCP never retransmits",
                "TCP is stateless; UDP is stateful"
              ],
              "correctAnswerIndex": 0,
              "explanation": "TCP implements reliability (ACKs/retransmissions), while UDP is best-effort."
            },
            {
              "id": "CS_062",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What is the purpose of a database VIEW?",
              "options": [
                "A virtual table defined by a query",
                "A physical copy of data for faster reads",
                "A write-ahead log of transactions",
                "An index on multiple columns"
              ],
              "correctAnswerIndex": 0,
              "explanation": "A view presents query results as a virtual table."
            },
            {
              "id": "CS_063",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Hard",
              "questionText": "In OS scheduling, what does 'time quantum' refer to?",
              "options": [
                "The maximum CPU time a task gets before preemption in round-robin",
                "The minimum time a thread must sleep",
                "The time to flush CPU caches",
                "The window for database lock timeout"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Round-robin uses a time slice (quantum) to share CPU fairly."
            },
            {
              "id": "CS_064",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What does a TCP ACK indicate?",
              "options": [
                "Successful receipt of data up to a sequence number",
                "A request to start encryption",
                "A DNS resolution completion",
                "A route discovery message"
              ],
              "correctAnswerIndex": 0,
              "explanation": "ACKs confirm received bytes/segments, enabling reliability."
            },
            {
              "id": "CS_065",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What is an OS interrupt?",
              "options": [
                "A signal to the CPU to handle an event immediately",
                "A thread voluntarily yielding CPU",
                "A database transaction rollback",
                "A network packet retransmission"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Interrupts notify the CPU of events like I/O completion or timers."
            },
            {
              "id": "CS_066",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Hard",
              "questionText": "Which SQL concept ensures that related changes are committed as a single unit?",
              "options": ["Transaction", "Index", "Trigger", "Materialized view"],
              "correctAnswerIndex": 0,
              "explanation": "Transactions bundle operations into an all-or-nothing commit."
            },
            {
              "id": "CS_067",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What is a cache miss?",
              "options": [
                "Requested data not found in cache and must be fetched from a slower level",
                "Cache returning corrupted data",
                "A database query failing to use an index",
                "A TCP packet being dropped"
              ],
              "correctAnswerIndex": 0,
              "explanation": "A miss forces access to slower memory (e.g., L2/L3/RAM)."
            },
            {
              "id": "CS_068",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What is the main purpose of database normalization?",
              "options": [
                "Reduce redundancy and update anomalies",
                "Increase read latency for consistency",
                "Guarantee horizontal scaling",
                "Replace the need for indexes"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Normalization structures data to avoid duplication and anomalies."
            },
            {
              "id": "CS_069",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Hard",
              "questionText": "What does 'lock escalation' mean in databases?",
              "options": [
                "Replacing many fine-grained locks with a coarser lock",
                "Upgrading from read committed to serializable isolation",
                "Switching from row storage to column storage",
                "Rebuilding indexes automatically"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Systems may escalate to table/page locks to reduce lock management overhead."
            },
            {
              "id": "CS_070",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What does 'swap' refer to in memory management?",
              "options": [
                "Moving pages between RAM and disk",
                "Exchanging CPU cores between processes",
                "Switching TCP ports mid-connection",
                "Swapping primary keys in a table"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Swapping uses disk as backing store when RAM is insufficient."
            },

            {
              "id": "CS_071",
              "category": "Computer Science",
              "baseDifficulty": "Hard",
              "targetLevel": "Hard",
              "questionText": "Why can using SELECT * be problematic in production systems?",
              "options": [
                "It can fetch unnecessary columns and break clients when schema changes",
                "It prevents the query planner from using indexes",
                "It forces serializable isolation",
                "It disables network compression"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Selecting explicit columns reduces payload and avoids accidental breaking changes."
            },
            {
              "id": "CS_072",
              "category": "Computer Science",
              "baseDifficulty": "Hard",
              "targetLevel": "Hard",
              "questionText": "In OS design, what does 'preemption' mean?",
              "options": [
                "The OS can forcibly stop a running task to schedule another",
                "A task voluntarily yields CPU",
                "A process blocks until I/O completes",
                "A program exits and frees memory"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Preemptive scheduling lets the OS interrupt tasks to ensure responsiveness."
            },
            {
              "id": "CS_073",
              "category": "Computer Science",
              "baseDifficulty": "Hard",
              "targetLevel": "Hard",
              "questionText": "What is the main purpose of a database query optimizer?",
              "options": [
                "Choose an efficient execution plan for a query",
                "Guarantee zero deadlocks",
                "Encrypt query results",
                "Automatically normalize tables"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Optimizers select plans (indexes/join order) to reduce execution cost."
            },
            {
              "id": "CS_074",
              "category": "Computer Science",
              "baseDifficulty": "Hard",
              "targetLevel": "Hard",
              "questionText": "What does 'head-of-line blocking' mean in networking?",
              "options": [
                "A queued packet/stream delays subsequent ones behind it",
                "A router drops the first packet of every flow",
                "DNS queries block TLS handshakes",
                "TCP retransmits faster than UDP"
              ],
              "correctAnswerIndex": 0,
              "explanation": "HOL blocking occurs when one blocked item stalls others in order-dependent queues."
            },
            {
              "id": "CS_075",
              "category": "Computer Science",
              "baseDifficulty": "Hard",
              "targetLevel": "Hard",
              "questionText": "Which anomaly can occur under snapshot isolation?",
              "options": [
                "Write skew",
                "Dirty read",
                "Lost update is always impossible",
                "Phantom reads are always impossible"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Snapshot isolation prevents dirty reads but can allow write skew in some cases."
            },
            {
              "id": "CS_076",
              "category": "Computer Science",
              "baseDifficulty": "Hard",
              "targetLevel": "Hard",
              "questionText": "What is the main advantage of a lock-free algorithm?",
              "options": [
                "System-wide progress without blocking on locks",
                "Guaranteed fairness among threads",
                "Zero CPU usage under contention",
                "Elimination of cache misses"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Lock-free designs avoid global lock contention and reduce blocking risks."
            },
            {
              "id": "CS_077",
              "category": "Computer Science",
              "baseDifficulty": "Hard",
              "targetLevel": "Hard",
              "questionText": "What does 'thundering herd' describe?",
              "options": [
                "Many threads waking up for a single event causing contention",
                "Many TCP connections sharing one IP",
                "Many indexes created on one table",
                "Many pages swapped out at once"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Thundering herd happens when many waiters wake and contend for the same resource."
            },
            {
              "id": "CS_078",
              "category": "Computer Science",
              "baseDifficulty": "Hard",
              "targetLevel": "Hard",
              "questionText": "Why does LRU caching perform poorly under some access patterns?",
              "options": [
                "It can thrash on cyclic scans larger than cache size",
                "It cannot store variable-sized entries",
                "It requires full table scans",
                "It breaks transaction durability"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Sequential scans can evict frequently used items, causing cache thrashing."
            },
            {
              "id": "CS_079",
              "category": "Computer Science",
              "baseDifficulty": "Hard",
              "targetLevel": "Hard",
              "questionText": "In networking, what is 'jitter'?",
              "options": [
                "Variation in packet delay over time",
                "Total packet loss percentage",
                "Maximum throughput of a link",
                "Time to resolve a DNS name"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Jitter is delay variability, critical for real-time audio/video."
            },
            {
              "id": "CS_080",
              "category": "Computer Science",
              "baseDifficulty": "Hard",
              "targetLevel": "Hard",
              "questionText": "What does a 'covering index' allow in many databases?",
              "options": [
                "Answering a query using only the index without reading the table",
                "Indexing across multiple databases automatically",
                "Guaranteeing serializable isolation",
                "Avoiding all lock contention"
              ],
              "correctAnswerIndex": 0,
              "explanation": "A covering index contains all needed columns, avoiding table lookups."
            },

            {
              "id": "CS_081",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "Which OS concept provides isolation between running programs?",
              "options": ["Process", "Semaphore", "Socket", "Index"],
              "correctAnswerIndex": 0,
              "explanation": "Processes provide isolation via separate address spaces and resources."
            },
            {
              "id": "CS_082",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Normal",
              "questionText": "What does ICMP primarily support?",
              "options": [
                "Network diagnostics and control messages",
                "Reliable data streaming",
                "DNS name resolution",
                "HTTP request routing"
              ],
              "correctAnswerIndex": 0,
              "explanation": "ICMP is used for errors and diagnostics like ping."
            },
            {
              "id": "CS_083",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "What does SELECT DISTINCT do in SQL?",
              "options": [
                "Removes duplicate rows in the result set",
                "Sorts rows by primary key",
                "Locks the selected rows",
                "Returns only non-null values"
              ],
              "correctAnswerIndex": 0,
              "explanation": "DISTINCT filters out duplicate result rows."
            },
            {
              "id": "CS_084",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "What is a thread in an OS?",
              "options": [
                "A unit of execution within a process",
                "A compiled program on disk",
                "A network route entry",
                "A database row version"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Threads run within a process and typically share its memory."
            },
            {
              "id": "CS_085",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Normal",
              "questionText": "In databases, what does a JOIN do?",
              "options": [
                "Combines rows from two tables based on a related column",
                "Creates a new index",
                "Removes duplicate rows",
                "Commits a transaction"
              ],
              "correctAnswerIndex": 0,
              "explanation": "JOIN merges rows using a specified relationship (join condition)."
            },
            {
              "id": "CS_086",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "What does FIFO represent in scheduling/queues?",
              "options": [
                "First In, First Out",
                "Fast In, Fast Out",
                "First Index, Final Output",
                "Fixed Interval, Fixed Order"
              ],
              "correctAnswerIndex": 0,
              "explanation": "FIFO means items are processed in arrival order."
            },
            {
              "id": "CS_087",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "What is the main function of a router?",
              "options": [
                "Forward packets between different networks",
                "Assign IPs within a LAN",
                "Resolve domain names",
                "Encrypt application payloads"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Routers connect networks and forward packets based on IP routing."
            },
            {
              "id": "CS_088",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Normal",
              "questionText": "What is a primary benefit of paging in virtual memory?",
              "options": [
                "Non-contiguous allocation and reduced external fragmentation",
                "Guaranteed no page faults",
                "Eliminates need for an MMU",
                "Forces contiguous physical memory"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Paging maps virtual pages to frames, avoiding contiguous physical allocation."
            },
            {
              "id": "CS_089",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "Which SQL clause sorts the result set?",
              "options": ["ORDER BY", "GROUP BY", "HAVING", "LIMIT"],
              "correctAnswerIndex": 0,
              "explanation": "ORDER BY sorts rows in the query result."
            },
            {
              "id": "CS_090",
              "category": "Computer Science",
              "baseDifficulty": "Easy",
              "targetLevel": "Easy",
              "questionText": "What does CPU cache primarily reduce?",
              "options": ["Average memory access latency", "Network bandwidth usage", "Disk durability risk", "SQL injection risk"],
              "correctAnswerIndex": 0,
              "explanation": "Caches keep hot data close to the CPU to reduce access time."
            },

            {
              "id": "CS_091",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What does an OS 'daemon' typically refer to?",
              "options": [
                "A background service process",
                "A kernel-mode thread only",
                "A GUI-only application",
                "A database transaction"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Daemons run in the background providing system services."
            },
            {
              "id": "CS_092",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Hard",
              "questionText": "Why can N+1 query problems be harmful?",
              "options": [
                "They cause excessive database round trips and latency",
                "They guarantee deadlocks under load",
                "They prevent index usage entirely",
                "They force full table locks"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Many small queries amplify network/db overhead and slow systems."
            },
            {
              "id": "CS_093",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What does a database transaction 'rollback' do?",
              "options": [
                "Reverts changes made in the transaction",
                "Commits changes permanently",
                "Creates a new savepoint automatically",
                "Rebuilds indexes for the modified table"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Rollback undoes uncommitted changes to restore prior state."
            },
            {
              "id": "CS_094",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What is the main purpose of a 'savepoint' in SQL transactions?",
              "options": [
                "Allow partial rollback within a transaction",
                "Force immediate durability to disk",
                "Upgrade isolation level for a single statement",
                "Lock a table for exclusive access"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Savepoints let you roll back to a point without aborting the whole transaction."
            },
            {
              "id": "CS_095",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Hard",
              "questionText": "What is the 'ABA problem' in lock-free programming?",
              "options": [
                "A value changes A->B->A, misleading CAS-based checks",
                "A thread is blocked by a mutex forever",
                "A database row is updated twice in one transaction",
                "A TCP connection resets during handshake"
              ],
              "correctAnswerIndex": 0,
              "explanation": "CAS may succeed incorrectly if the value returns to its original state."
            },
            {
              "id": "CS_096",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What does 'port' represent in TCP/UDP networking?",
              "options": [
                "A logical endpoint identifying a service on a host",
                "A physical network interface",
                "A routing table entry",
                "A DNS record type"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Ports multiplex network services on a single IP address."
            },
            {
              "id": "CS_097",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "What does 'bufferbloat' describe?",
              "options": [
                "High latency caused by excessive buffering in network devices",
                "Packet loss due to small MTU",
                "DNS cache poisoning",
                "TCP handshake failure under load"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Too much buffering increases queueing delay and hurts latency-sensitive traffic."
            },
            {
              "id": "CS_098",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Hard",
              "questionText": "What is the main purpose of a database 'EXPLAIN' plan?",
              "options": [
                "Show how the DB intends to execute a query",
                "Automatically optimize the query permanently",
                "Lock tables for safe reads",
                "Export query results to a file"
              ],
              "correctAnswerIndex": 0,
              "explanation": "EXPLAIN reveals indexes, join order, and estimated costs for debugging performance."
            },
            {
              "id": "CS_099",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Normal",
              "questionText": "In OS memory, what does 'heap allocation' typically involve?",
              "options": [
                "Dynamic allocation with explicit/free or GC/allocator tracking",
                "Automatic allocation per function call only",
                "Allocation only for CPU registers",
                "Allocation only for disk buffers"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Heap allocations are dynamic and managed by an allocator/runtime."
            },
            {
              "id": "CS_100",
              "category": "Computer Science",
              "baseDifficulty": "Normal",
              "targetLevel": "Hard",
              "questionText": "Why can increasing isolation level from READ COMMITTED to SERIALIZABLE reduce throughput?",
              "options": [
                "It increases locking/conflict detection and reduces concurrency",
                "It disables indexes",
                "It forces all queries to run in memory",
                "It removes the need for WAL"
              ],
              "correctAnswerIndex": 0,
              "explanation": "Stronger isolation requires more coordination, reducing parallelism."
            },
              {
                "id": "CS_101",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "What is the primary purpose of an OS file system?",
                "options": [
                  "Organize and manage persistent data on storage",
                  "Schedule CPU time for threads",
                  "Encrypt all network traffic",
                  "Translate virtual addresses to physical addresses"
                ],
                "correctAnswerIndex": 0,
                "explanation": "A file system manages how data is stored, retrieved, and organized on persistent storage."
              },
              {
                "id": "CS_102",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "Which SQL command is typically used to create a new table?",
                "options": ["CREATE TABLE", "ADD TABLE", "NEW TABLE", "MAKE TABLE"],
                "correctAnswerIndex": 0,
                "explanation": "CREATE TABLE defines a new table schema in SQL."
              },
              {
                "id": "CS_103",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Normal",
                "questionText": "What does the term 'throughput' mean in networking?",
                "options": [
                  "Amount of data successfully delivered per unit time",
                  "Time taken for a single packet to arrive",
                  "Maximum packet size allowed on a link",
                  "Number of routers between endpoints"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Throughput measures delivered data rate (e.g., Mbps), distinct from latency."
              },
              {
                "id": "CS_104",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "What does RAM primarily store?",
                "options": [
                  "Data and instructions currently in use",
                  "Files permanently stored for long-term retention",
                  "Only CPU registers and flags",
                  "Only network routing tables"
                ],
                "correctAnswerIndex": 0,
                "explanation": "RAM holds working data/instructions for active processes; it’s volatile."
              },
              {
                "id": "CS_105",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "Which device typically forwards frames based on MAC addresses in a LAN?",
                "options": ["Switch", "Router", "Firewall", "DNS server"],
                "correctAnswerIndex": 0,
                "explanation": "Switches operate at L2 and forward frames using MAC address tables."
              },
              {
                "id": "CS_106",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "In SQL, what does the GROUP BY clause do?",
                "options": [
                  "Groups rows for aggregate calculations",
                  "Sorts rows in ascending order",
                  "Filters rows before selection",
                  "Creates an index automatically"
                ],
                "correctAnswerIndex": 0,
                "explanation": "GROUP BY groups rows so aggregates (COUNT/SUM/AVG) can be computed per group."
              },
              {
                "id": "CS_107",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "Which OS concept describes a program waiting for I/O and not using the CPU?",
                "options": ["Blocked state", "Running state", "Ready state", "Zombie state"],
                "correctAnswerIndex": 0,
                "explanation": "Blocked (waiting) means the task can’t run until an event like I/O completes."
              },
              {
                "id": "CS_108",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Normal",
                "questionText": "What is the main purpose of a database index cardinality estimate?",
                "options": [
                  "Help the optimizer choose efficient plans",
                  "Encrypt the index pages",
                  "Guarantee zero lock contention",
                  "Force consistent reads across replicas"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Optimizers use cardinality estimates to pick join orders and access paths."
              },
              {
                "id": "CS_109",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "What does the term 'port scanning' most commonly refer to?",
                "options": [
                  "Probing which TCP/UDP ports are open on a host",
                  "Measuring MTU on a network path",
                  "Resolving domain names to IPs repeatedly",
                  "Rewriting IP headers at a gateway"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Port scanning checks open ports to discover exposed services."
              },
              {
                "id": "CS_110",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "What does the term 'cache hit' mean?",
                "options": [
                  "Requested data found in cache",
                  "Requested data not found in cache",
                  "Cache storing data on disk",
                  "CPU skipping cache and reading RAM"
                ],
                "correctAnswerIndex": 0,
                "explanation": "A hit means the cache contains the requested data, avoiding slower memory."
              },
              {
                "id": "CS_111",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "Which SQL statement changes the table schema (e.g., add a column)?",
                "options": ["ALTER TABLE", "UPDATE TABLE", "MODIFY ROWS", "REINDEX TABLE"],
                "correctAnswerIndex": 0,
                "explanation": "ALTER TABLE is used to modify table structure."
              },
              {
                "id": "CS_112",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "Which OS mechanism typically isolates user applications from hardware access?",
                "options": ["User mode vs kernel mode", "DNS caching", "ARP tables", "SQL constraints"],
                "correctAnswerIndex": 0,
                "explanation": "CPU privilege levels separate user code from privileged kernel operations."
              },
              {
                "id": "CS_113",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "What is the purpose of a database schema?",
                "options": [
                  "Define tables, columns, and relationships",
                  "Store query results permanently",
                  "Encrypt data with keys",
                  "Route packets between networks"
                ],
                "correctAnswerIndex": 0,
                "explanation": "A schema defines the structure and constraints of stored data."
              },
              {
                "id": "CS_114",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Normal",
                "questionText": "What is the main role of a load balancer in networking?",
                "options": [
                  "Distribute traffic across multiple backend servers",
                  "Resolve domains to IPs",
                  "Assign IP addresses to clients",
                  "Encrypt database rows"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Load balancers spread requests across instances to improve availability and capacity."
              },
              {
                "id": "CS_115",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "What does the term 'swap space' usually refer to?",
                "options": [
                  "Disk area used to extend RAM via paging",
                  "CPU register file for context switching",
                  "Encrypted storage for secrets",
                  "Network buffer used by routers"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Swap provides disk backing for pages when RAM pressure is high."
              },
              {
                "id": "CS_116",
                "category": "Computer Science",
                "baseDifficulty": "Easy",
                "targetLevel": "Easy",
                "questionText": "Which SQL clause limits the number of rows returned?",
                "options": ["LIMIT", "TOP", "RANGE", "CAP"],
                "correctAnswerIndex": 0,
                "explanation": "LIMIT restricts the count of result rows (syntax may vary by DB)."
              },

              {
                "id": "CS_117",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What does 'paging' mean in virtual memory?",
                "options": [
                  "Dividing memory into fixed-size pages mapped to frames",
                  "Allocating memory only on the stack",
                  "Compressing RAM contents automatically",
                  "Writing all memory changes directly to disk"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Paging maps fixed-size virtual pages to physical frames to manage memory efficiently."
              },
              {
                "id": "CS_118",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What is the primary purpose of a database trigger?",
                "options": [
                  "Automatically execute logic on data changes",
                  "Speed up range queries",
                  "Prevent any writes to a table",
                  "Replicate data between servers"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Triggers run automatically on INSERT/UPDATE/DELETE events."
              },
              {
                "id": "CS_119",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Hard",
                "questionText": "Why can a non-clustered index still require a table lookup?",
                "options": [
                  "The index may not contain all requested columns",
                  "The index pages are always encrypted",
                  "The optimizer forbids index-only scans",
                  "Non-clustered indexes store full rows by definition"
                ],
                "correctAnswerIndex": 0,
                "explanation": "If needed columns aren’t in the index, the DB must fetch the base row."
              },
              {
                "id": "CS_120",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What does 'DNS caching' primarily improve?",
                "options": [
                  "Reduces repeated DNS lookup latency",
                  "Prevents packet fragmentation",
                  "Guarantees TLS authenticity",
                  "Eliminates NAT overhead"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Caching avoids repeated queries to resolvers for the same domain."
              },
              {
                "id": "CS_121",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What is the primary purpose of a read-write lock (RWLock)?",
                "options": [
                  "Allow multiple concurrent readers but exclusive writers",
                  "Guarantee fairness among threads",
                  "Prevent all forms of deadlocks",
                  "Make I/O operations non-blocking"
                ],
                "correctAnswerIndex": 0,
                "explanation": "RWLocks boost read concurrency while keeping writes exclusive."
              },
              {
                "id": "CS_122",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What does 'aging' in priority scheduling address?",
                "options": [
                  "Prevents starvation by gradually increasing waiting tasks’ priority",
                  "Reduces CPU clock speed over time",
                  "Deletes old database rows automatically",
                  "Rotates TLS keys periodically"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Aging boosts long-waiting tasks to avoid starvation."
              },
              {
                "id": "CS_123",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Hard",
                "questionText": "What does 'phantom read' refer to in transaction isolation?",
                "options": [
                  "Re-executing a query returns a different set of rows due to inserts/deletes",
                  "Reading uncommitted changes from another transaction",
                  "Two transactions updating the same row concurrently",
                  "A row becoming NULL unexpectedly after commit"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Phantoms occur when new rows appear/disappear in a range between reads."
              },
              {
                "id": "CS_124",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What is the main purpose of a TCP window (receive window)?",
                "options": [
                  "Flow control to avoid overwhelming the receiver",
                  "Congestion control to avoid router overload",
                  "Encrypting payloads during handshake",
                  "Mapping IP to MAC on a LAN"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Flow control uses the advertised window to limit unacknowledged data."
              },
              {
                "id": "CS_125",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What is 'copying' in garbage-collected or managed runtimes primarily used for?",
                "options": [
                  "Compaction and improved allocation locality",
                  "Preventing all race conditions",
                  "Encrypting objects in memory",
                  "Eliminating page tables"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Copying collectors can compact memory and improve locality by moving objects."
              },
              {
                "id": "CS_126",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Hard",
                "questionText": "Why might a DB choose a hash join over a nested loop join?",
                "options": [
                  "Better performance for large, unsorted inputs with equality joins",
                  "Required for all range queries",
                  "Avoids using any memory",
                  "Guarantees serializable isolation"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Hash joins are often efficient for large equality joins by hashing one side."
              },
              {
                "id": "CS_127",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What does 'fork' commonly do in Unix-like operating systems?",
                "options": [
                  "Creates a new process by duplicating the calling process",
                  "Starts a new thread in the same address space",
                  "Mounts a file system",
                  "Allocates a new network port"
                ],
                "correctAnswerIndex": 0,
                "explanation": "fork creates a child process with a copy of the parent’s state (often via CoW)."
              },
              {
                "id": "CS_128",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What is the main purpose of a database connection pool?",
                "options": [
                  "Reuse established connections to reduce connection overhead",
                  "Cache query results automatically",
                  "Guarantee zero deadlocks",
                  "Increase index cardinality"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Pooling avoids expensive connection setup/teardown per request."
              },
              {
                "id": "CS_129",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Hard",
                "questionText": "Why can 'offset-based pagination' become slow on large tables?",
                "options": [
                  "The DB may scan and discard many rows before returning results",
                  "It forces full table locks",
                  "It disables indexes by definition",
                  "It requires serializable isolation"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Large OFFSET values often require scanning/skipping many rows."
              },
              {
                "id": "CS_130",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What does a 'dirty read' mean?",
                "options": [
                  "Reading uncommitted changes from another transaction",
                  "Reading the same row twice and getting different values",
                  "Reading rows inserted after a query started",
                  "Reading a row that violates a foreign key"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Dirty reads occur when one transaction sees another’s uncommitted changes."
              },
              {
                "id": "CS_131",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What is the purpose of a CPU memory barrier (fence)?",
                "options": [
                  "Enforce ordering/visibility of memory operations across cores",
                  "Increase L1 cache size dynamically",
                  "Compress RAM pages automatically",
                  "Prevent page faults during I/O"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Fences ensure memory operations become visible in a required order."
              },
              {
                "id": "CS_132",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Hard",
                "questionText": "What does 'non-repeatable read' describe?",
                "options": [
                  "Reading the same row twice returns different values due to another commit",
                  "Reading rows that are later rolled back",
                  "Reading different row counts due to inserts in a range",
                  "A query reading from a replica with lag"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Non-repeatable reads happen when an updated row changes between reads."
              },
              {
                "id": "CS_133",
                "category": "Computer Science",
                "baseDifficulty": "Normal",
                "targetLevel": "Normal",
                "questionText": "What is the primary benefit of a journaling file system?",
                "options": [
                  "Faster crash recovery by logging metadata/data changes",
                  "Eliminates the need for backups",
                  "Guarantees zero fragmentation",
                  "Encrypts files by default"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Journaling records intended changes, allowing quicker recovery after crashes."
              },

              {
                "id": "CS_134",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "Why can 'priority inversion' happen in concurrent systems?",
                "options": [
                  "A low-priority task holds a resource needed by a high-priority task",
                  "A high-priority task always yields to low-priority tasks",
                  "The scheduler ignores priorities when CPU is idle",
                  "A mutex can only be locked by the highest priority task"
                ],
                "correctAnswerIndex": 0,
                "explanation": "If low priority holds a lock, it can block high priority, inverting effective priority."
              },
              {
                "id": "CS_135",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "What is the main difference between a clustered index and a non-clustered index?",
                "options": [
                  "Clustered index defines physical row order; non-clustered stores separate key-to-row mapping",
                  "Non-clustered index defines physical row order; clustered does not",
                  "Clustered indexes cannot support range scans",
                  "Non-clustered indexes always contain full row data"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Clustered indexes often align row storage with index order; non-clustered are separate structures."
              },
              {
                "id": "CS_136",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "Why can 'checksum offloading' to NICs improve performance?",
                "options": [
                  "It reduces CPU work by letting hardware compute packet checksums",
                  "It prevents packet loss entirely",
                  "It replaces the need for TCP retransmission",
                  "It forces encryption for all packets"
                ],
                "correctAnswerIndex": 0,
                "explanation": "NIC offload features shift work from CPU to hardware, improving throughput."
              },
              {
                "id": "CS_137",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "What is 'dirty page' in OS memory management?",
                "options": [
                  "A page modified in RAM that must be written back before eviction",
                  "A page that contains corrupted bytes due to ECC failure",
                  "A page that cannot be mapped into virtual memory",
                  "A page that always resides in CPU cache"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Dirty pages differ from disk backing and must be flushed before replacement."
              },
              {
                "id": "CS_138",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "What is the main risk of using a 'global' mutex for many unrelated resources?",
                "options": [
                  "High contention and reduced parallelism",
                  "Guaranteed deadlock in all cases",
                  "Memory leaks due to reference cycles",
                  "Loss of transaction durability"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Coarse locks serialize unrelated work, increasing contention and hurting scalability."
              },
              {
                "id": "CS_139",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "Why can 'TCP retransmission timeout' (RTO) selection matter?",
                "options": [
                  "Too small causes spurious retransmits; too large delays recovery",
                  "It determines the DNS cache TTL",
                  "It sets the MTU for the path",
                  "It controls NAT port allocation"
                ],
                "correctAnswerIndex": 0,
                "explanation": "RTO impacts responsiveness and network load; it must balance delay vs false retransmits."
              },
              {
                "id": "CS_140",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "In databases, what is the main purpose of 'predicate pushdown'?",
                "options": [
                  "Filter data as early as possible to reduce work",
                  "Force all joins to use hash joins",
                  "Guarantee serializable isolation",
                  "Disable caching for correctness"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Pushing filters down reduces intermediate result sizes and speeds execution."
              },
              {
                "id": "CS_141",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "Why can 'NUMA' architectures affect performance?",
                "options": [
                  "Memory access latency depends on which CPU node owns the memory",
                  "NUMA makes caches coherent automatically without overhead",
                  "NUMA eliminates the need for page tables",
                  "NUMA guarantees uniform latency across all cores"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Non-uniform access means remote memory is slower than local node memory."
              },
              {
                "id": "CS_142",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "What is a key downside of 'synchronous replication' in databases?",
                "options": [
                  "Higher write latency because commits wait for replicas",
                  "Inability to read from replicas",
                  "Loss of durability guarantees",
                  "Automatic schema divergence"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Waiting for replicas improves consistency but increases commit latency."
              },
              {
                "id": "CS_143",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "What does 'path MTU discovery' try to avoid?",
                "options": [
                  "IP fragmentation by discovering the largest usable MTU",
                  "TCP congestion control entirely",
                  "DNS lookup delays",
                  "TLS certificate verification"
                ],
                "correctAnswerIndex": 0,
                "explanation": "PMTUD finds the max MTU so packets aren’t fragmented along the path."
              },
              {
                "id": "CS_144",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "In OS virtual memory, why are huge pages sometimes used?",
                "options": [
                  "Reduce TLB misses by mapping more memory per entry",
                  "Increase CPU frequency by lowering heat",
                  "Eliminate need for caching",
                  "Prevent all page faults"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Huge pages reduce translation overhead by covering more memory with fewer TLB entries."
              },
              {
                "id": "CS_145",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "What does 'lock-free' guarantee (not 'wait-free') imply?",
                "options": [
                  "Some thread makes progress even under contention",
                  "Every thread completes in bounded steps",
                  "No atomic operations are used",
                  "All operations are executed sequentially"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Lock-free means system progress is guaranteed, but individual threads may starve."
              },
              {
                "id": "CS_146",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "Why can 'index selectivity' strongly impact query performance?",
                "options": [
                  "High selectivity reduces scanned rows and improves efficiency",
                  "High selectivity forces table locks",
                  "Low selectivity makes joins impossible",
                  "Selectivity only matters for inserts, not selects"
                ],
                "correctAnswerIndex": 0,
                "explanation": "More selective indexes filter more, reducing I/O and work."
              },
              {
                "id": "CS_147",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "What is the main risk of using 'eventual consistency' for user-visible counters?",
                "options": [
                  "Users may observe temporarily incorrect or stale values",
                  "Writes become impossible without locks",
                  "Reads always block writers",
                  "Network packets cannot be routed"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Eventual consistency allows temporary divergence; counters may lag across replicas."
              },
              {
                "id": "CS_148",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "Why is 'double free' a serious memory management bug?",
                "options": [
                  "It can corrupt allocator metadata and lead to undefined behavior",
                  "It only causes a minor memory leak",
                  "It merely slows down garbage collection",
                  "It only affects stack memory, not heap"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Freeing the same block twice can corrupt heap structures and cause crashes or exploits."
              },
              {
                "id": "CS_149",
                "category": "Computer Science",
                "baseDifficulty": "Hard",
                "targetLevel": "Hard",
                "questionText": "In databases, what is the key advantage of 'partitioning' a large table?",
                "options": [
                  "Limit scans and maintenance to relevant partitions",
                  "Guarantee no deadlocks",
                  "Eliminate the need for indexes",
                  "Make all queries O(1)"
                ],
                "correctAnswerIndex": 0,
                "explanation": "Partition pruning can reduce scanned data; maintenance can be partition-scoped."
              },
              {
                  "id": "CS_150",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why can 'synchronous I/O' reduce throughput in high-concurrency servers?",
                  "options": [
                      "Threads may block waiting for I/O, limiting concurrent work",
                      "It guarantees packet loss under load",
                      "It disables CPU caching",
                      "It forces serializable database isolation"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Blocking I/O ties up threads; async/event-driven I/O can scale better with many connections."
              },
                {
                  "id": "CS_151",
                  "category": "Computer Science",
                  "baseDifficulty": "Easy",
                  "targetLevel": "Easy",
                  "questionText": "What is the main purpose of a TCP port number?",
                  "options": [
                    "Identify the destination application/service on a host",
                    "Identify the destination router on a path",
                    "Encrypt the payload end-to-end",
                    "Control the MTU of the link"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Ports multiplex multiple services on the same IP address."
                },
                {
                  "id": "CS_152",
                  "category": "Computer Science",
                  "baseDifficulty": "Easy",
                  "targetLevel": "Easy",
                  "questionText": "Which SQL keyword removes an entire table definition?",
                  "options": ["DROP", "DELETE", "REMOVE", "PURGE"],
                  "correctAnswerIndex": 0,
                  "explanation": "DROP removes the table schema itself (and its data)."
                },
                {
                  "id": "CS_153",
                  "category": "Computer Science",
                  "baseDifficulty": "Easy",
                  "targetLevel": "Easy",
                  "questionText": "What is the primary role of the OS kernel?",
                  "options": [
                    "Manage hardware resources and provide core services",
                    "Render UI components for apps",
                    "Compile source code into binaries",
                    "Resolve DNS records for applications"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "The kernel manages CPU, memory, devices, and privileged operations."
                },
                {
                  "id": "CS_154",
                  "category": "Computer Science",
                  "baseDifficulty": "Easy",
                  "targetLevel": "Easy",
                  "questionText": "What does 'bandwidth' typically measure in networking?",
                  "options": [
                    "Maximum data transfer capacity per unit time",
                    "Time for one packet to arrive",
                    "Number of packets dropped per second",
                    "Maximum DNS cache size"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Bandwidth is capacity (e.g., Mbps), distinct from latency."
                },
                {
                  "id": "CS_155",
                  "category": "Computer Science",
                  "baseDifficulty": "Easy",
                  "targetLevel": "Easy",
                  "questionText": "Which SQL clause filters grouped results after aggregation?",
                  "options": ["HAVING", "WHERE", "ORDER BY", "DISTINCT"],
                  "correctAnswerIndex": 0,
                  "explanation": "HAVING applies conditions to groups (post-aggregation)."
                },
                {
                  "id": "CS_156",
                  "category": "Computer Science",
                  "baseDifficulty": "Easy",
                  "targetLevel": "Normal",
                  "questionText": "What is the primary benefit of using a CDN?",
                  "options": [
                    "Serve content closer to users to reduce latency",
                    "Encrypt all application traffic automatically",
                    "Eliminate the need for a database",
                    "Guarantee zero packet loss"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "CDNs reduce latency by caching content near end users."
                },
                {
                  "id": "CS_157",
                  "category": "Computer Science",
                  "baseDifficulty": "Easy",
                  "targetLevel": "Easy",
                  "questionText": "What is a 'daemon' process most commonly?",
                  "options": [
                    "A background service running without user interaction",
                    "A one-time process that runs only at boot",
                    "A process that must have a GUI",
                    "A kernel module that can’t be stopped"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Daemons provide background services (e.g., logging, scheduling, networking)."
                },
                {
                  "id": "CS_158",
                  "category": "Computer Science",
                  "baseDifficulty": "Easy",
                  "targetLevel": "Easy",
                  "questionText": "What is the main purpose of a database backup?",
                  "options": [
                    "Restore data after corruption, deletion, or outages",
                    "Speed up SELECT queries",
                    "Enforce stronger transaction isolation",
                    "Reduce network jitter"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Backups allow recovery from failures and data loss events."
                },
                {
                  "id": "CS_159",
                  "category": "Computer Science",
                  "baseDifficulty": "Easy",
                  "targetLevel": "Normal",
                  "questionText": "In OS terms, what is 'IPC'?",
                  "options": [
                    "Mechanisms for inter-process communication",
                    "A CPU instruction pipeline cache",
                    "A database integrity constraint",
                    "A network routing protocol"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "IPC includes pipes, sockets, shared memory, signals, etc."
                },
                {
                  "id": "CS_160",
                  "category": "Computer Science",
                  "baseDifficulty": "Easy",
                  "targetLevel": "Easy",
                  "questionText": "Which component typically stores recently used disk blocks to speed up file access?",
                  "options": ["Page cache / buffer cache", "ARP cache", "TLS session cache", "B+ tree index"],
                  "correctAnswerIndex": 0,
                  "explanation": "The OS caches file data/blocks in memory to reduce disk I/O."
                },

                {
                  "id": "CS_161",
                  "category": "Computer Science",
                  "baseDifficulty": "Normal",
                  "targetLevel": "Normal",
                  "questionText": "What does 'pipelining' in a CPU primarily improve?",
                  "options": [
                    "Instruction throughput by overlapping execution stages",
                    "Single-instruction latency by removing stages",
                    "Disk I/O bandwidth by caching writes",
                    "Network reliability by retransmitting packets"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Pipelining overlaps stages to increase completed instructions per time unit."
                },
                {
                  "id": "CS_162",
                  "category": "Computer Science",
                  "baseDifficulty": "Normal",
                  "targetLevel": "Normal",
                  "questionText": "What does a 'socket backlog' primarily represent on a listening server?",
                  "options": [
                    "Queued pending connections waiting to be accepted",
                    "Maximum MTU allowed for the connection",
                    "Number of DNS retries allowed",
                    "Size of TLS certificate chain"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Backlog is the queue of not-yet-accepted connections."
                },
                {
                  "id": "CS_163",
                  "category": "Computer Science",
                  "baseDifficulty": "Normal",
                  "targetLevel": "Normal",
                  "questionText": "What is the main purpose of a 'materialized view'?",
                  "options": [
                    "Persist the result of a query for faster reads",
                    "Provide a virtual table without storage",
                    "Guarantee serializable isolation",
                    "Replace foreign keys automatically"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Materialized views store computed results to speed up repeated queries."
                },
                {
                  "id": "CS_164",
                  "category": "Computer Science",
                  "baseDifficulty": "Normal",
                  "targetLevel": "Hard",
                  "questionText": "Why does HTTP keep-alive improve performance?",
                  "options": [
                    "It reuses TCP connections, reducing handshake overhead",
                    "It compresses payloads automatically",
                    "It guarantees ordering across different hosts",
                    "It eliminates the need for TLS"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Reusing connections avoids repeated TCP/TLS setup costs."
                },
                {
                  "id": "CS_165",
                  "category": "Computer Science",
                  "baseDifficulty": "Normal",
                  "targetLevel": "Normal",
                  "questionText": "What does 'least privilege' mean in OS security?",
                  "options": [
                    "Grant only the permissions necessary to perform a task",
                    "Run all processes as administrator to avoid failures",
                    "Encrypt all memory pages by default",
                    "Disable all network ports"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Limiting permissions reduces blast radius if something is compromised."
                },
                {
                  "id": "CS_166",
                  "category": "Computer Science",
                  "baseDifficulty": "Normal",
                  "targetLevel": "Normal",
                  "questionText": "What does a 'stored procedure' typically provide?",
                  "options": [
                    "Predefined logic executed on the database server",
                    "A faster replacement for indexes",
                    "A guarantee of eventual consistency",
                    "A file-system journaling mechanism"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Stored procedures run server-side logic close to the data."
                },
                {
                  "id": "CS_167",
                  "category": "Computer Science",
                  "baseDifficulty": "Normal",
                  "targetLevel": "Normal",
                  "questionText": "What is the primary goal of a CPU cache coherence protocol (e.g., MESI)?",
                  "options": [
                    "Keep shared data consistent across multiple core caches",
                    "Make disk writes atomic without logs",
                    "Prevent TCP packet reordering",
                    "Reduce DNS lookup time"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Coherence ensures cores see consistent values for shared memory."
                },
                {
                  "id": "CS_168",
                  "category": "Computer Science",
                  "baseDifficulty": "Normal",
                  "targetLevel": "Hard",
                  "questionText": "What is the key difference between logical and physical replication?",
                  "options": [
                    "Logical replicates changes at row/statement level; physical replicates storage blocks/WAL",
                    "Physical replicates only schema; logical replicates only data",
                    "Logical requires no network; physical does",
                    "Physical is always eventually consistent; logical is always strongly consistent"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Logical replication replays data changes; physical replays low-level storage logs/blocks."
                },
                {
                  "id": "CS_169",
                  "category": "Computer Science",
                  "baseDifficulty": "Normal",
                  "targetLevel": "Normal",
                  "questionText": "What does 'backpressure' in streaming systems primarily manage?",
                  "options": [
                    "Preventing producers from overwhelming consumers",
                    "Ensuring packets never arrive out of order",
                    "Making transactions serializable",
                    "Avoiding page faults in virtual memory"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Backpressure coordinates flow when consumers can’t keep up."
                },
                {
                  "id": "CS_170",
                  "category": "Computer Science",
                  "baseDifficulty": "Normal",
                  "targetLevel": "Normal",
                  "questionText": "What is the main purpose of 'mmap' (memory-mapped files) in OSes?",
                  "options": [
                    "Map files into virtual memory for efficient I/O and access",
                    "Allocate CPU registers for a process",
                    "Encrypt files with per-page keys",
                    "Route packets between subnets"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "mmap lets programs access file contents via memory reads/writes."
                },

                {
                  "id": "CS_171",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "In distributed systems, what does the CAP theorem state?",
                  "options": [
                    "You can’t simultaneously guarantee Consistency, Availability, and Partition tolerance",
                    "You can’t achieve low latency and high throughput together",
                    "You can’t have encryption and compression at the same time",
                    "You can’t index a table and also normalize it"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Under network partitions, systems trade off consistency vs availability."
                },
                {
                  "id": "CS_172",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why can BGP misconfiguration cause widespread outages?",
                  "options": [
                    "Incorrect route announcements can divert or blackhole traffic globally",
                    "It changes MAC addresses for all hosts",
                    "It disables TLS certificate validation",
                    "It forces all traffic to use UDP"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "BGP propagates routing info; bad announcements can impact large parts of the internet."
                },
                {
                  "id": "CS_173",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What is the primary purpose of two-phase commit (2PC)?",
                  "options": [
                    "Coordinate an atomic commit across multiple participants",
                    "Guarantee lock-free progress under contention",
                    "Prevent all deadlocks in databases",
                    "Speed up range queries using indexes"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "2PC ensures all participants either commit or all abort."
                },
                {
                  "id": "CS_174",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why can 2PC block in some failure scenarios?",
                  "options": [
                    "Participants may wait indefinitely if the coordinator fails after prepare",
                    "It requires DNS to be available at commit time",
                    "It forces full table scans for each participant",
                    "It disables WAL, preventing recovery"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "If the coordinator disappears mid-protocol, participants can be stuck waiting."
                },
                {
                  "id": "CS_175",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "In OS memory, what is the key goal of a buddy allocator?",
                  "options": [
                    "Fast allocation/free with coalescing using power-of-two blocks",
                    "Eliminate internal fragmentation entirely",
                    "Guarantee no page faults",
                    "Provide lock-free allocation without atomics"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Buddy allocators split/merge power-of-two blocks quickly via 'buddy' relationships."
                },
                {
                  "id": "CS_176",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What problem does 'slab allocation' primarily address in kernels?",
                  "options": [
                    "Efficient allocation for many objects of the same size/type",
                    "IP routing convergence delays",
                    "SQL deadlocks on hot rows",
                    "TCP head-of-line blocking"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Slab allocators reuse preallocated caches for common object sizes to reduce overhead."
                },
                {
                  "id": "CS_177",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why can 'write amplification' be harmful on SSD-backed databases?",
                  "options": [
                    "Small logical writes can cause larger physical writes, reducing performance and endurance",
                    "It makes reads return stale data by design",
                    "It prevents transactions from committing",
                    "It eliminates caching benefits"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Extra physical writes slow performance and wear out flash faster."
                },
                {
                  "id": "CS_178",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What is the main purpose of a Bloom filter in storage/DB systems?",
                  "options": [
                    "Probabilistically test membership to avoid unnecessary disk lookups",
                    "Provide exact sorting for range queries",
                    "Ensure serializable transaction ordering",
                    "Encrypt index pages at rest"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Bloom filters quickly rule out misses (with possible false positives)."
                },
                {
                  "id": "CS_179",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "In networking, what is a common advantage of QUIC over TCP for web traffic?",
                  "options": [
                    "Reduced handshake latency and improved multiplexing over UDP",
                    "Guaranteed zero packet loss",
                    "No need for congestion control",
                    "Requires no encryption support"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "QUIC integrates TLS and supports faster setup and stream multiplexing."
                },
                {
                  "id": "CS_180",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why can HTTP/2 still suffer from head-of-line blocking at the transport layer?",
                  "options": [
                    "Multiple streams share a single TCP connection; loss can stall delivery",
                    "HTTP/2 disables retransmission by default",
                    "HTTP/2 uses UDP without sequencing",
                    "HTTP/2 forces packet fragmentation"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "TCP-level loss/retransmit can delay all streams sharing the connection."
                },
                {
                  "id": "CS_181",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What is 'consistent hashing' primarily used for?",
                  "options": [
                    "Minimizing key remapping when nodes join/leave a cluster",
                    "Guaranteeing cryptographic integrity of packets",
                    "Preventing SQL injection attacks",
                    "Reducing page faults via larger TLB entries"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Consistent hashing limits how many keys move when the cluster membership changes."
                },
                {
                  "id": "CS_182",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why do LSM-tree based stores often need compaction?",
                  "options": [
                    "To merge sorted runs and control read amplification",
                    "To enforce foreign key constraints",
                    "To eliminate the need for WAL",
                    "To prevent cache coherence traffic"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Compaction merges levels/runs to keep reads efficient and reclaim space."
                },
                {
                  "id": "CS_183",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What is the main purpose of a 'redo log' in crash recovery?",
                  "options": [
                    "Reapply committed changes that weren’t flushed to data pages",
                    "Undo committed transactions",
                    "Prevent deadlocks by reordering locks",
                    "Store query results for caching"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Redo replays committed operations to reach a consistent state after a crash."
                },
                {
                  "id": "CS_184",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "In OS scheduling, what is 'load average' commonly measuring?",
                  "options": [
                    "Average number of runnable and uninterruptible tasks over time",
                    "Average CPU temperature over time",
                    "Average network RTT to the default gateway",
                    "Average disk capacity used per directory"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Load average approximates system demand (runnable + some waiting tasks)."
                },
                {
                  "id": "CS_185",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What is the key risk of 'split-brain' in distributed databases?",
                  "options": [
                    "Two partitions accept writes independently, causing divergence",
                    "All reads become strongly consistent automatically",
                    "Indexes become unusable due to hashing",
                    "Transactions become lock-free by default"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "If multiple leaders accept writes, reconciling conflicting states becomes difficult."
                },
                {
                  "id": "CS_186",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why is 'leader election' used in many distributed systems?",
                  "options": [
                    "Choose a coordinator to avoid conflicting decisions/writes",
                    "Ensure every node writes simultaneously for speed",
                    "Eliminate network partitions",
                    "Guarantee zero latency reads"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "A leader coordinates actions to maintain consistency and avoid split-brain."
                },
                {
                  "id": "CS_187",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What does 'DNSSEC' primarily add to DNS?",
                  "options": [
                    "Authenticity/integrity via signed DNS records",
                    "Transport encryption for all DNS packets",
                    "Automatic IP assignment to hosts",
                    "Lower DNS TTLs for faster failover"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "DNSSEC signs records to prevent tampering/spoofing of DNS responses."
                },
                {
                  "id": "CS_188",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "In OS memory, what is 'page replacement' trying to decide?",
                  "options": [
                    "Which page to evict when RAM is full",
                    "Which CPU core to assign to a thread",
                    "Which TCP segment to retransmit",
                    "Which SQL join algorithm to use"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Replacement algorithms choose eviction victims to minimize future faults."
                },
                {
                  "id": "CS_189",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why can 'clock (second-chance)' page replacement be preferred over pure LRU?",
                  "options": [
                    "It approximates LRU with lower overhead",
                    "It guarantees no page faults",
                    "It eliminates internal fragmentation",
                    "It forces contiguous physical memory"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Clock gives pages a second chance using a reference bit, cheaper than strict LRU."
                },
                {
                  "id": "CS_190",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What is 'GC stop-the-world pause' primarily impacting?",
                  "options": [
                    "Application latency due to pausing all threads for garbage collection",
                    "Database durability guarantees on commit",
                    "Network MTU discovery time",
                    "CPU cache coherence correctness"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Stop-the-world pauses halt application threads, increasing tail latency."
                },
                {
                  "id": "CS_191",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why do databases use 'checksum' pages/blocks?",
                  "options": [
                    "Detect data corruption in storage or memory",
                    "Speed up sorting operations",
                    "Prevent deadlocks automatically",
                    "Eliminate the need for WAL"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Checksums detect corruption so the system can fail fast or repair."
                },
                {
                  "id": "CS_192",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What is the key difference between 'flow control' and 'congestion control' in TCP?",
                  "options": [
                    "Flow control protects the receiver; congestion control protects the network",
                    "Flow control protects the network; congestion control protects the receiver",
                    "Both are identical mechanisms",
                    "Congestion control is done only by routers"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Flow control uses receiver window; congestion control adapts to network capacity."
                },
                {
                  "id": "CS_193",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why can 'read repair' be used in eventually consistent systems?",
                  "options": [
                    "Fix stale replicas during reads by reconciling versions",
                    "Prevent all writes during network partitions",
                    "Guarantee serializable transactions across shards",
                    "Eliminate replication lag entirely"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Read repair updates out-of-date replicas when a read detects divergence."
                },
                {
                  "id": "CS_194",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What is a 'write skew' anomaly most associated with?",
                  "options": [
                    "Snapshot isolation allowing concurrent writes that violate an invariant",
                    "Read uncommitted allowing dirty reads",
                    "Serializable isolation guaranteeing phantoms",
                    "Strict 2PL eliminating conflicts"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Under snapshot isolation, concurrent transactions can both commit and break constraints."
                },
                {
                  "id": "CS_195",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why can 'vector clocks' be used in distributed systems?",
                  "options": [
                    "Track causality and detect concurrent updates",
                    "Encrypt messages end-to-end",
                    "Choose an optimal SQL query plan",
                    "Prevent CPU cache misses"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Vector clocks help reason about partial ordering and concurrency of events."
                },
                {
                  "id": "CS_196",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What does 'fsync' (or similar) typically guarantee for a database commit?",
                  "options": [
                    "Data/log is flushed to stable storage before acknowledging success",
                    "Queries are automatically optimized",
                    "Indexes are rebuilt after each write",
                    "Network packets are retransmitted faster"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "fsync forces buffered data to disk, supporting durability."
                },
                {
                  "id": "CS_197",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "In concurrency, what is 'linearizability'?",
                  "options": [
                    "Operations appear to occur atomically in a single global order consistent with real time",
                    "Operations are eventually visible across replicas",
                    "Threads never block on locks",
                    "All operations execute on one CPU core"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Linearizability is a strong correctness model for concurrent objects."
                },
                {
                  "id": "CS_198",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why can 'dirty shutdown' be a challenge for file systems/databases?",
                  "options": [
                    "In-flight writes may be partially persisted, requiring recovery logic",
                    "It prevents TCP from establishing connections",
                    "It forces all data into CPU registers",
                    "It guarantees data is always consistent without logs"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Unexpected power loss can leave partial writes; journaling/WAL enables recovery."
                },
                {
                  "id": "CS_199",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "What is the main purpose of 'checksum + WAL' together in many databases?",
                  "options": [
                    "Detect corruption and enable correct recovery to a consistent state",
                    "Avoid all locking for better concurrency",
                    "Eliminate the need for backups",
                    "Guarantee zero latency queries"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Checksums detect corruption; WAL supports redo/undo recovery for consistency/durability."
                },
                {
                  "id": "CS_200",
                  "category": "Computer Science",
                  "baseDifficulty": "Hard",
                  "targetLevel": "Hard",
                  "questionText": "Why can 'sharding' complicate transactions compared to a single-node database?",
                  "options": [
                    "Atomic commits may require distributed coordination (e.g., 2PC) and careful design",
                    "Indexes cannot be used on sharded tables",
                    "Sharding forces all reads to be strongly consistent",
                    "Sharding eliminates network partitions"
                  ],
                  "correctAnswerIndex": 0,
                  "explanation": "Cross-shard transactions add coordination overhead and failure modes."
                },
                  {
                    "id": "MobileDev_001",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "In SwiftUI, which property wrapper is used for local mutable state inside a View?",
                    "options": ["@State", "@Binding", "@ObservedObject", "@EnvironmentObject"],
                    "correctAnswerIndex": 0,
                    "explanation": "@State stores view-local state that triggers view updates when changed."
                  },
                  {
                    "id": "MobileDev_002",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "In UIKit, which object is responsible for managing a screen of content?",
                    "options": ["UIViewController", "UIView", "UIWindow", "UIApplication"],
                    "correctAnswerIndex": 0,
                    "explanation": "UIViewController manages a view hierarchy and user interactions for a screen."
                  },
                  {
                    "id": "MobileDev_003",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Normal",
                    "questionText": "In MVVM, which layer should contain business logic and state for a screen?",
                    "options": ["ViewModel", "View", "Model", "Router"],
                    "correctAnswerIndex": 0,
                    "explanation": "The ViewModel holds presentation state and business logic, exposing it to the View."
                  },
                  {
                    "id": "MobileDev_004",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "Which SwiftUI view is used to create a vertically scrolling list of rows?",
                    "options": ["List", "VStack", "HStack", "ZStack"],
                    "correctAnswerIndex": 0,
                    "explanation": "List renders a scrollable collection of rows with platform-native behaviors."
                  },
                  {
                    "id": "MobileDev_005",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "Which iOS API is commonly used for simple key-value local storage?",
                    "options": ["UserDefaults", "Core Data", "Keychain", "FileHandle"],
                    "correctAnswerIndex": 0,
                    "explanation": "UserDefaults is designed for lightweight preferences and small key-value data."
                  },
                  {
                    "id": "MobileDev_006",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "In UIKit, which method is typically called after a view controller's view is loaded into memory?",
                    "options": ["viewDidLoad()", "viewWillAppear()", "viewDidAppear()", "loadView()"],
                    "correctAnswerIndex": 0,
                    "explanation": "viewDidLoad() runs once after the view is loaded and is ideal for setup."
                  },
                  {
                    "id": "MobileDev_007",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Normal",
                    "questionText": "In SwiftUI, what does @Binding represent?",
                    "options": [
                      "A two-way connection to state owned elsewhere",
                      "A globally shared singleton state",
                      "A reference-type observable object",
                      "A compile-time constant value"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "@Binding lets a child view read/write state owned by a parent."
                  },
                  {
                    "id": "MobileDev_008",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "Which UIKit class is used to display a scrollable list of rows efficiently?",
                    "options": ["UITableView", "UILabel", "UIScrollView", "UIStackView"],
                    "correctAnswerIndex": 0,
                    "explanation": "UITableView is optimized for long, scrollable lists of reusable cells."
                  },
                  {
                    "id": "MobileDev_009",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "What is the primary role of the AppDelegate in a UIKit app?",
                    "options": [
                      "Handle application-level lifecycle events",
                      "Render SwiftUI views",
                      "Manage Core Data migrations automatically",
                      "Replace the navigation controller"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "AppDelegate responds to app-wide events like launch and backgrounding (legacy flow)."
                  },
                  {
                    "id": "MobileDev_010",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Normal",
                    "questionText": "Which storage is best suited for small secrets like tokens on iOS?",
                    "options": ["Keychain", "UserDefaults", "Bundle", "NSUserActivity"],
                    "correctAnswerIndex": 0,
                    "explanation": "Keychain is designed for secure credential storage."
                  },
                  {
                    "id": "MobileDev_011",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "In SwiftUI, which container overlays views on top of each other?",
                    "options": ["ZStack", "VStack", "HStack", "Grid"],
                    "correctAnswerIndex": 0,
                    "explanation": "ZStack stacks views along the Z-axis (front-to-back)."
                  },
                  {
                    "id": "MobileDev_012",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "Which SwiftUI modifier is commonly used to push a view onto a navigation stack?",
                    "options": ["navigationDestination", "sheet", "alert", "popover"],
                    "correctAnswerIndex": 0,
                    "explanation": "navigationDestination maps navigation state to destination views (NavigationStack)."
                  },
                  {
                    "id": "MobileDev_013",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Normal",
                    "questionText": "In MVVM, what should the View ideally avoid doing?",
                    "options": [
                      "Containing complex business logic",
                      "Displaying UI state",
                      "Binding to ViewModel outputs",
                      "Forwarding user actions"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Views should be thin; business logic belongs in the ViewModel/Model layers."
                  },
                  {
                    "id": "MobileDev_014",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "Which UIKit component is the root of all view hierarchies on screen?",
                    "options": ["UIWindow", "UIView", "UIViewController", "UIApplication"],
                    "correctAnswerIndex": 0,
                    "explanation": "UIWindow hosts the root view controller’s view hierarchy."
                  },
                  {
                    "id": "MobileDev_015",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Easy",
                    "questionText": "What is the main purpose of Auto Layout in iOS?",
                    "options": [
                      "Create adaptive UI using constraints",
                      "Schedule CPU tasks efficiently",
                      "Encrypt local storage automatically",
                      "Manage database transactions"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Auto Layout uses constraints to adapt UI to different sizes and orientations."
                  },
                  {
                    "id": "MobileDev_016",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Easy",
                    "targetLevel": "Normal",
                    "questionText": "In SwiftUI, what does @ObservedObject require from the observed type?",
                    "options": [
                      "Conformance to ObservableObject",
                      "Conformance to Identifiable",
                      "Inheritance from UIViewController",
                      "Conformance to Codable"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "@ObservedObject observes an ObservableObject and refreshes when it emits changes."
                  },

                  {
                    "id": "MobileDev_017",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "In SwiftUI, what is the key difference between @StateObject and @ObservedObject?",
                    "options": [
                      "@StateObject owns and initializes the object; @ObservedObject is injected/owned elsewhere",
                      "@ObservedObject persists across view recreations; @StateObject does not",
                      "@ObservedObject is only for structs; @StateObject is only for classes",
                      "They are identical in behavior"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "@StateObject creates/owns the lifecycle; @ObservedObject observes an external instance."
                  },
                  {
                    "id": "MobileDev_018",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "What problem does cell reuse solve in UITableView/UICollectionView?",
                    "options": [
                      "Reduces memory and improves scroll performance",
                      "Guarantees correct data ordering in the database",
                      "Prevents all UI thread blocking",
                      "Automatically caches network responses"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Reusing cells avoids allocating views for every item, improving performance."
                  },
                  {
                    "id": "MobileDev_019",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Hard",
                    "questionText": "Why can updating UIKit UI from a background thread cause issues?",
                    "options": [
                      "UIKit is not thread-safe and expects main-thread updates",
                      "Background threads cannot allocate memory",
                      "It forces a deadlock in all cases",
                      "It disables Auto Layout constraints"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "UIKit must be mutated on the main thread to avoid race conditions and crashes."
                  },
                  {
                    "id": "MobileDev_020",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "In SwiftUI, what does .task { } commonly do?",
                    "options": [
                      "Runs async work tied to the view's lifecycle",
                      "Creates a persistent singleton background job",
                      "Blocks the UI thread until completion",
                      "Replaces Combine publishers automatically"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": ".task starts async work when the view appears and cancels when it disappears."
                  },
                  {
                    "id": "MobileDev_021",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "What is the main benefit of using MVVM on iOS?",
                    "options": [
                      "Separates UI from logic to improve testability and maintainability",
                      "Guarantees faster animations",
                      "Eliminates the need for networking code",
                      "Makes database writes automatically transactional"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "MVVM separates concerns and makes UI state/logic easier to test."
                  },
                  {
                    "id": "MobileDev_022",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "In UIKit, what is the purpose of a navigation controller?",
                    "options": [
                      "Manage a stack of view controllers for push/pop navigation",
                      "Manage database schema migrations",
                      "Schedule background tasks",
                      "Handle push notifications delivery"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "UINavigationController manages hierarchical navigation via a view controller stack."
                  },
                  {
                    "id": "MobileDev_023",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Hard",
                    "questionText": "What is a common pitfall of using UserDefaults for large data?",
                    "options": [
                      "It’s not optimized for large blobs and can hurt performance",
                      "It automatically encrypts data and slows writes",
                      "It requires a background thread always",
                      "It supports only integers and booleans"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "UserDefaults is for small preferences; large data can slow load/save and bloat memory."
                  },
                  {
                    "id": "MobileDev_024",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "What is the main role of SceneDelegate (iOS 13+ UIKit lifecycle)?",
                    "options": [
                      "Manage UI lifecycle per window/scene",
                      "Handle DNS resolution for the app",
                      "Replace the app’s networking layer",
                      "Control database replication"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "SceneDelegate manages per-scene lifecycle like foreground/background transitions."
                  },
                  {
                    "id": "MobileDev_025",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "In SwiftUI, when does body typically recompute?",
                    "options": [
                      "When observed state changes",
                      "Only once at app launch",
                      "Only when device rotates",
                      "Only when using NavigationStack"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "SwiftUI recomputes body when relevant state changes trigger updates."
                  },
                  {
                    "id": "MobileDev_026",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Hard",
                    "questionText": "Why is dependency injection helpful in MVVM?",
                    "options": [
                      "It enables testing by swapping real services with mocks",
                      "It guarantees faster rendering",
                      "It eliminates memory leaks automatically",
                      "It prevents all race conditions"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "DI decouples components, allowing easy replacement of dependencies in tests."
                  },
                  {
                    "id": "MobileDev_027",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "What does 'state restoration' aim to achieve in iOS apps?",
                    "options": [
                      "Restore UI/navigation to a previous state after termination",
                      "Encrypt files when app goes background",
                      "Force network requests to retry automatically",
                      "Rebuild Core Data store on launch"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "State restoration helps users return to where they left off after an app restart."
                  },
                  {
                    "id": "MobileDev_028",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "In UIKit, what does traitCollection primarily represent?",
                    "options": [
                      "Environment traits like size class, display scale, and interface style",
                      "A network configuration profile",
                      "Database schema version",
                      "Core Animation timing curve"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Traits describe environment (dark mode, size class) used for adaptive UI."
                  },
                  {
                    "id": "MobileDev_029",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Hard",
                    "questionText": "Why can using singletons for shared state be problematic in large apps?",
                    "options": [
                      "Hidden dependencies and harder testing",
                      "They cannot be accessed across files",
                      "They always cause deadlocks",
                      "They prevent navigation"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Singletons create global mutable state and implicit coupling, hurting testability."
                  },
                  {
                    "id": "MobileDev_030",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "What is the primary benefit of using UICollectionView over UITableView?",
                    "options": [
                      "More flexible layouts (grids, custom layouts) with cell reuse",
                      "Automatic database paging",
                      "Built-in MVVM support",
                      "Guaranteed thread-safe UI updates"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "UICollectionView supports complex, customizable layouts beyond simple lists."
                  },
                  {
                    "id": "MobileDev_031",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Hard",
                    "questionText": "In SwiftUI, why can using @EnvironmentObject crash at runtime?",
                    "options": [
                      "If the object is not injected into the environment for that view tree",
                      "Because it always retains cycles by default",
                      "Because SwiftUI cannot observe reference types",
                      "Because it only works with @State"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Accessing a missing EnvironmentObject triggers a runtime failure."
                  },
                  {
                    "id": "MobileDev_032",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "What does 'cold start' typically refer to in mobile performance?",
                    "options": [
                      "App launch from a terminated state",
                      "App returning from background",
                      "A network request timing out",
                      "A database index rebuild"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Cold start is launching when the process is not in memory."
                  },
                  {
                    "id": "MobileDev_033",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Normal",
                    "targetLevel": "Normal",
                    "questionText": "Which iOS API is commonly used for object graph persistence?",
                    "options": ["Core Data", "UserDefaults", "URLCache", "NotificationCenter"],
                    "correctAnswerIndex": 0,
                    "explanation": "Core Data is designed for structured persistence with relationships and querying."
                  },

                  {
                    "id": "MobileDev_034",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "Why can SwiftUI Lists sometimes show unexpected row update animations?",
                    "options": [
                      "Identity/diffing issues when row IDs are unstable",
                      "Because List always reloads the entire UI on every frame",
                      "Because Lists can’t handle dynamic data sources",
                      "Because List disables diffing when using ForEach"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "If IDs change between updates, SwiftUI may treat rows as different items and animate oddly."
                  },
                  {
                    "id": "MobileDev_035",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "In UIKit Auto Layout, what does an 'ambiguous layout' mean?",
                    "options": [
                      "Constraints don’t uniquely determine size/position",
                      "Constraints contain a cycle so solving is impossible",
                      "The view is offscreen due to z-ordering",
                      "The layout is correct but slow"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Ambiguity happens when there aren’t enough constraints to determine a unique layout."
                  },
                  {
                    "id": "MobileDev_036",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "Why is Core Data concurrency tricky?",
                    "options": [
                      "NSManagedObjectContext is not thread-safe and must be used on its queue",
                      "SQLite is not supported on iOS",
                      "Core Data requires main-thread networking",
                      "Core Data stores objects only in UserDefaults"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Contexts must be confined to their queue; crossing threads causes crashes/data issues."
                  },
                  {
                    "id": "MobileDev_037",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "What is the primary risk of doing heavy work in viewDidLoad() on the main thread?",
                    "options": [
                      "Slower launch/UI freeze due to blocking the main run loop",
                      "Automatic memory leaks in ARC",
                      "Breaks compilation due to missing constraints",
                      "Forces background execution of network calls"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Blocking the main thread delays rendering and hurts perceived performance."
                  },
                  {
                    "id": "MobileDev_038",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "In MVVM, what is a common cause of 'fat ViewModel'?",
                    "options": [
                      "Putting domain/business rules and networking details directly into the ViewModel",
                      "Using too many SwiftUI views",
                      "Using a navigation controller",
                      "Using UserDefaults instead of Core Data"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "ViewModels should orchestrate, but heavy domain logic often belongs in services/use-cases."
                  },
                  {
                    "id": "MobileDev_039",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "Why can SwiftUI view identity problems cause state to reset unexpectedly?",
                    "options": [
                      "SwiftUI may recreate the view when its identity changes, resetting @State",
                      "SwiftUI stores @State globally across the whole app",
                      "SwiftUI forbids state in dynamic lists",
                      "SwiftUI always resets state on device rotation"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "If a view’s identity changes (e.g., unstable IDs), SwiftUI may treat it as a new view."
                  },
                  {
                    "id": "MobileDev_040",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "What is the key difference between background fetch and push notifications for updates?",
                    "options": [
                      "Background fetch is OS-scheduled; push is server-initiated",
                      "Background fetch requires a server; push does not",
                      "Push runs unlimited code time; fetch is unlimited too",
                      "They are identical mechanisms"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Fetch depends on OS heuristics; push is triggered by the server via APNs."
                  },
                  {
                    "id": "MobileDev_041",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "Why can 'retain cycles' occur with closures in view controllers?",
                    "options": [
                      "A closure strongly captures self while self retains the closure",
                      "Closures cannot capture values in Swift",
                      "UIKit automatically retains all closures forever",
                      "ARC ignores closures during deallocation"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "If VC holds a closure and the closure strongly holds VC, neither deallocates."
                  },
                  {
                    "id": "MobileDev_042",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "In SwiftUI, why can nested GeometryReader lead to layout issues?",
                    "options": [
                      "It can create dependency loops and unexpected size proposals",
                      "It disables all animations",
                      "It prevents using @State",
                      "It forces views to render offscreen"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "GeometryReader affects layout proposals; nesting can cause complex, unstable sizing behavior."
                  },
                  {
                    "id": "MobileDev_043",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "Why is it risky to persist NSManagedObject directly outside its context lifecycle?",
                    "options": [
                      "It can become a fault or invalid when the context changes or is reset",
                      "It automatically clones itself into UserDefaults",
                      "It forces all queries to be serializable",
                      "It disables caching for the store"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Managed objects are tied to a context; pass IDs or DTOs instead."
                  },
                  {
                    "id": "MobileDev_044",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "What is a common cause of 'layout constraint conflicts' in Auto Layout?",
                    "options": [
                      "Two or more constraints cannot be satisfied simultaneously",
                      "Missing Info.plist keys",
                      "Using NavigationStack in SwiftUI",
                      "A slow database query"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Conflicts happen when constraints over-constrain the system with incompatible requirements."
                  },
                  {
                    "id": "MobileDev_045",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "Why can background tasks be suspended unexpectedly on iOS?",
                    "options": [
                      "iOS enforces strict resource limits and may terminate/suspend to save power",
                      "Background tasks run forever by default",
                      "iOS disables networking in background for all apps",
                      "UIKit prevents any background execution"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "iOS aggressively manages background execution for battery and performance."
                  },
                  {
                    "id": "MobileDev_046",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "What is the primary benefit of using a diffable data source in UICollectionView?",
                    "options": [
                      "Safer, simpler updates with automatic diffing and animations",
                      "Guaranteed O(1) inserts regardless of size",
                      "No need for cell reuse",
                      "Automatic persistence to disk"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Diffable data sources compute diffs and apply consistent UI updates."
                  },
                  {
                    "id": "MobileDev_047",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "Why can excessive use of NotificationCenter be problematic in large apps?",
                    "options": [
                      "Loose coupling can become hidden dependencies and hard-to-trace flows",
                      "It prevents background execution",
                      "It forces all observers to run on background threads",
                      "It disables SwiftUI state updates"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Global broadcasts can make logic hard to trace and test, especially at scale."
                  },
                  {
                    "id": "MobileDev_048",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "What is the main risk of storing large images directly in Core Data as Binary Data?",
                    "options": [
                      "Store bloat and slow fetches; better store on disk and keep references",
                      "It breaks ARC and leaks memory",
                      "It prevents using fetched results controllers",
                      "It disables encryption on the device"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "Large blobs in the DB can inflate the store and slow reads/writes; file storage is often better."
                  },
                  {
                    "id": "MobileDev_049",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "In SwiftUI, what is a common cause of 'sheet not dismissing' issues?",
                    "options": [
                      "Presentation state not updating on the correct source of truth",
                      "SwiftUI sheets cannot be dismissed programmatically",
                      "NavigationStack blocks all sheets",
                      "List disables sheet presentation"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "If the bound state doesn't change (or changes in a different owner), dismissal won’t occur."
                  },
                  {
                    "id": "MobileDev_050",
                    "category": "Mobile Dev",
                    "baseDifficulty": "Hard",
                    "targetLevel": "Hard",
                    "questionText": "Why can using a single shared URLSession delegate for many requests be risky?",
                    "options": [
                      "Delegate callbacks can mix concerns and complicate concurrency/state handling",
                      "URLSession delegates disable HTTP/2",
                      "It forces all requests to be synchronous",
                      "It prevents caching from working"
                    ],
                    "correctAnswerIndex": 0,
                    "explanation": "A shared delegate can become a shared mutable bottleneck and complicate request isolation."
                  },
                    {
                      "id": "MobileDev_051",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Easy",
                      "targetLevel": "Easy",
                      "questionText": "In SwiftUI, which modifier is used to make a view expand to fill available space?",
                      "options": ["frame(maxWidth: .infinity)", "padding()", "fixedSize()", "layoutPriority(1)"],
                      "correctAnswerIndex": 0,
                      "explanation": "Using maxWidth: .infinity allows a view to expand to available horizontal space."
                    },
                    {
                      "id": "MobileDev_052",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Easy",
                      "targetLevel": "Easy",
                      "questionText": "Which UIKit class handles touch events at the lowest level?",
                      "options": ["UIResponder", "UIViewController", "UIGestureRecognizer", "UIApplicationDelegate"],
                      "correctAnswerIndex": 0,
                      "explanation": "UIResponder is the base class for handling touch, motion, and remote-control events."
                    },
                    {
                      "id": "MobileDev_053",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Easy",
                      "targetLevel": "Normal",
                      "questionText": "In MVVM, what is the primary responsibility of the Model?",
                      "options": [
                        "Represent domain data and core business rules",
                        "Render UI components",
                        "Handle navigation logic",
                        "Bind directly to SwiftUI views"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Models represent domain data and business rules independent of UI."
                    },
                    {
                      "id": "MobileDev_054",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Easy",
                      "targetLevel": "Easy",
                      "questionText": "Which SwiftUI view is commonly used to arrange items horizontally?",
                      "options": ["HStack", "VStack", "ZStack", "List"],
                      "correctAnswerIndex": 0,
                      "explanation": "HStack lays out child views horizontally."
                    },
                    {
                      "id": "MobileDev_055",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Easy",
                      "targetLevel": "Easy",
                      "questionText": "Which lifecycle method is called just before a UIViewController appears on screen?",
                      "options": ["viewWillAppear()", "viewDidLoad()", "viewDidAppear()", "loadView()"],
                      "correctAnswerIndex": 0,
                      "explanation": "viewWillAppear() is called before the view becomes visible."
                    },
                    {
                      "id": "MobileDev_056",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Easy",
                      "targetLevel": "Normal",
                      "questionText": "What is the primary use of UIScrollView?",
                      "options": [
                        "Enable scrolling and zooming of content",
                        "Render table rows efficiently",
                        "Manage navigation stack",
                        "Handle background tasks"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "UIScrollView provides scrolling and zooming behavior for content."
                    },
                    {
                      "id": "MobileDev_057",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Easy",
                      "targetLevel": "Easy",
                      "questionText": "Which SwiftUI modifier applies spacing inside a view’s bounds?",
                      "options": ["padding()", "margin()", "inset()", "spacing()"],
                      "correctAnswerIndex": 0,
                      "explanation": "padding() adds internal spacing around a view’s content."
                    },
                    {
                      "id": "MobileDev_058",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Easy",
                      "targetLevel": "Easy",
                      "questionText": "Which local storage option persists data across app launches?",
                      "options": ["UserDefaults", "In-memory cache", "Temporary variables", "NotificationCenter"],
                      "correctAnswerIndex": 0,
                      "explanation": "UserDefaults persists data to disk across launches."
                    },
                    {
                      "id": "MobileDev_059",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Easy",
                      "targetLevel": "Normal",
                      "questionText": "In SwiftUI, what does the body property represent?",
                      "options": [
                        "A computed description of the view hierarchy",
                        "A stored layout tree in memory",
                        "A mutable view instance",
                        "A background rendering thread"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "body is a computed property that describes the view’s UI structure."
                    },
                    {
                      "id": "MobileDev_060",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Easy",
                      "targetLevel": "Easy",
                      "questionText": "Which UIKit component is used to group related views?",
                      "options": ["UIView", "UIWindow", "UIScene", "UIApplication"],
                      "correctAnswerIndex": 0,
                      "explanation": "UIView acts as a container for other views."
                    },

                    {
                      "id": "MobileDev_061",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Normal",
                      "targetLevel": "Normal",
                      "questionText": "Why should network calls not be performed on the main thread?",
                      "options": [
                        "They can block UI rendering and cause freezes",
                        "They are automatically rejected by iOS",
                        "They disable ARC",
                        "They prevent navigation"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Blocking the main thread delays UI updates and harms responsiveness."
                    },
                    {
                      "id": "MobileDev_062",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Normal",
                      "targetLevel": "Normal",
                      "questionText": "What does size class in iOS primarily help with?",
                      "options": [
                        "Adaptive layouts across different screen sizes",
                        "Managing memory pressure",
                        "Controlling animation timing",
                        "Handling background execution"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Size classes allow UI to adapt to compact/regular environments."
                    },
                    {
                      "id": "MobileDev_063",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Normal",
                      "targetLevel": "Hard",
                      "questionText": "Why is it recommended to use weak self in escaping closures?",
                      "options": [
                        "To avoid retain cycles and memory leaks",
                        "To improve execution speed",
                        "To allow thread-safe UI updates",
                        "To force value semantics"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Weak captures prevent closures from strongly retaining their owners."
                    },
                    {
                      "id": "MobileDev_064",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Normal",
                      "targetLevel": "Normal",
                      "questionText": "What is the main advantage of using SwiftUI previews?",
                      "options": [
                        "Rapid UI iteration without running the full app",
                        "Automatic performance profiling",
                        "Guaranteed layout correctness",
                        "Replacing unit tests"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Previews enable fast feedback during UI development."
                    },
                    {
                      "id": "MobileDev_065",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Normal",
                      "targetLevel": "Normal",
                      "questionText": "What does NotificationCenter provide?",
                      "options": [
                        "A publish-subscribe mechanism for events",
                        "Persistent storage for app settings",
                        "Thread-safe UI updates",
                        "Automatic dependency injection"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "NotificationCenter broadcasts events to registered observers."
                    },
                    {
                      "id": "MobileDev_066",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Normal",
                      "targetLevel": "Hard",
                      "questionText": "Why can excessive SwiftUI view nesting impact performance?",
                      "options": [
                        "It increases diffing and layout computation cost",
                        "It disables view reuse entirely",
                        "It forces synchronous rendering",
                        "It prevents state updates"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Deep hierarchies increase layout and update computation."
                    },
                    {
                      "id": "MobileDev_067",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Normal",
                      "targetLevel": "Normal",
                      "questionText": "What does UIApplication.shared represent?",
                      "options": [
                        "The singleton instance managing app-level behavior",
                        "The root view controller",
                        "The main storyboard",
                        "The active scene only"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "UIApplication manages global app behaviors and events."
                    },
                    {
                      "id": "MobileDev_068",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Normal",
                      "targetLevel": "Normal",
                      "questionText": "Which API is used to persist files to disk on iOS?",
                      "options": ["FileManager", "UserDefaults", "Keychain", "URLSession"],
                      "correctAnswerIndex": 0,
                      "explanation": "FileManager handles file system operations."
                    },
                    {
                      "id": "MobileDev_069",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Normal",
                      "targetLevel": "Hard",
                      "questionText": "Why is view identity important in SwiftUI lists?",
                      "options": [
                        "It determines how SwiftUI diffs and updates rows",
                        "It controls gesture priority",
                        "It defines animation duration",
                        "It affects network request caching"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Stable identity allows SwiftUI to correctly diff and update views."
                    },
                    {
                      "id": "MobileDev_070",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Normal",
                      "targetLevel": "Normal",
                      "questionText": "What is the main purpose of accessibility identifiers?",
                      "options": [
                        "Enable UI testing and accessibility tools",
                        "Optimize layout performance",
                        "Persist UI state",
                        "Manage navigation routes"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Accessibility identifiers help testing and assistive technologies."
                    },

                    {
                      "id": "MobileDev_071",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Hard",
                      "targetLevel": "Hard",
                      "questionText": "Why can improper Core Data merge policies cause data loss?",
                      "options": [
                        "Conflicting changes may be overwritten during context merges",
                        "They disable persistent stores",
                        "They force full database reloads",
                        "They prevent background contexts"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Incorrect merge policies can discard changes when conflicts occur."
                    },
                    {
                      "id": "MobileDev_072",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Hard",
                      "targetLevel": "Hard",
                      "questionText": "What problem does state hoisting solve in SwiftUI?",
                      "options": [
                        "Sharing state between parent and child views cleanly",
                        "Reducing memory usage automatically",
                        "Improving network throughput",
                        "Avoiding Auto Layout conflicts"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "State hoisting centralizes ownership to avoid duplicated or inconsistent state."
                    },
                    {
                      "id": "MobileDev_073",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Hard",
                      "targetLevel": "Hard",
                      "questionText": "Why can long-running background tasks be terminated by the system?",
                      "options": [
                        "iOS enforces strict execution and energy limits",
                        "ARC releases background threads",
                        "The app loses Keychain access",
                        "Navigation controllers time out"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "iOS prioritizes battery and system health over prolonged background execution."
                    },
                    {
                      "id": "MobileDev_074",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Hard",
                      "targetLevel": "Hard",
                      "questionText": "What is a common drawback of tightly coupling View and ViewModel?",
                      "options": [
                        "Reduced testability and reusability",
                        "Slower animation performance",
                        "Increased binary size",
                        "Loss of SwiftUI previews"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Tight coupling makes components harder to test and reuse."
                    },
                    {
                      "id": "MobileDev_075",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Hard",
                      "targetLevel": "Hard",
                      "questionText": "Why is it recommended to avoid force-unwrapping optionals in UI code?",
                      "options": [
                        "It can cause runtime crashes if the value is nil",
                        "It prevents ARC from deallocating objects",
                        "It disables SwiftUI diffing",
                        "It slows down compilation"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Force-unwrapping nil results in a fatal runtime error."
                    },
                    {
                      "id": "MobileDev_076",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Hard",
                      "targetLevel": "Hard",
                      "questionText": "What is the main benefit of using background contexts in Core Data?",
                      "options": [
                        "Perform heavy work without blocking the main thread",
                        "Guarantee immediate consistency across contexts",
                        "Avoid merge conflicts entirely",
                        "Replace persistent stores"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Background contexts keep UI responsive during heavy data operations."
                    },
                    {
                      "id": "MobileDev_077",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Hard",
                      "targetLevel": "Hard",
                      "questionText": "Why can SwiftUI animations behave unexpectedly when state updates rapidly?",
                      "options": [
                        "Multiple state changes can interrupt or override animations",
                        "SwiftUI disables animations by default",
                        "Animations only work on main thread",
                        "Layout constraints are recalculated incorrectly"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Rapid state changes can cancel or restart animations."
                    },
                    {
                      "id": "MobileDev_078",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Hard",
                      "targetLevel": "Hard",
                      "questionText": "What is the primary reason to use an abstraction layer over URLSession?",
                      "options": [
                        "Decouple networking for testability and flexibility",
                        "Improve raw network speed",
                        "Avoid TLS entirely",
                        "Guarantee offline support"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Abstraction allows mocking and swapping implementations easily."
                    },
                    {
                      "id": "MobileDev_079",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Hard",
                      "targetLevel": "Hard",
                      "questionText": "Why can improper scene handling lead to bugs in multi-window iPad apps?",
                      "options": [
                        "State may be shared incorrectly across independent scenes",
                        "It disables background execution",
                        "It breaks SwiftUI previews",
                        "It forces portrait-only layout"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Each scene has its own lifecycle; shared state can cause inconsistencies."
                    },
                    {
                      "id": "MobileDev_080",
                      "category": "Mobile Dev",
                      "baseDifficulty": "Hard",
                      "targetLevel": "Hard",
                      "questionText": "What is a common performance issue caused by excessive layout passes?",
                      "options": [
                        "Increased CPU usage and dropped frames",
                        "Memory leaks in ARC",
                        "Network request retries",
                        "Database deadlocks"
                      ],
                      "correctAnswerIndex": 0,
                      "explanation": "Repeated layout calculations consume CPU and hurt frame rates."
                    },
                      {
                        "id": "MobileDev_081",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Easy",
                        "targetLevel": "Easy",
                        "questionText": "In SwiftUI, which modifier controls the alignment of content inside a frame?",
                        "options": ["alignment", "position", "layoutPriority", "offset"],
                        "correctAnswerIndex": 0,
                        "explanation": "The alignment parameter defines how content is positioned within a frame."
                      },
                      {
                        "id": "MobileDev_082",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Easy",
                        "targetLevel": "Easy",
                        "questionText": "Which UIKit class is responsible for handling app-level touch events before views?",
                        "options": ["UIApplication", "UIWindow", "UIResponder", "UIViewController"],
                        "correctAnswerIndex": 0,
                        "explanation": "UIApplication receives events first and dispatches them down the responder chain."
                      },
                      {
                        "id": "MobileDev_083",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Easy",
                        "targetLevel": "Normal",
                        "questionText": "In MVVM, which component should expose observable UI state?",
                        "options": ["ViewModel", "Model", "View", "Coordinator"],
                        "correctAnswerIndex": 0,
                        "explanation": "The ViewModel exposes state that the View observes and renders."
                      },
                      {
                        "id": "MobileDev_084",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Easy",
                        "targetLevel": "Easy",
                        "questionText": "Which SwiftUI view arranges elements vertically?",
                        "options": ["VStack", "HStack", "ZStack", "Grid"],
                        "correctAnswerIndex": 0,
                        "explanation": "VStack lays out its child views from top to bottom."
                      },
                      {
                        "id": "MobileDev_085",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Easy",
                        "targetLevel": "Easy",
                        "questionText": "Which iOS lifecycle event indicates the app is no longer visible?",
                        "options": [
                          "applicationDidEnterBackground",
                          "applicationDidBecomeActive",
                          "applicationWillTerminate",
                          "applicationWillFinishLaunching"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "applicationDidEnterBackground is called when the app moves to the background."
                      },
                      {
                        "id": "MobileDev_086",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Easy",
                        "targetLevel": "Normal",
                        "questionText": "What is the main purpose of a storyboard in UIKit?",
                        "options": [
                          "Visually define UI screens and transitions",
                          "Store persistent user data",
                          "Handle background tasks",
                          "Manage dependency injection"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Storyboards visually describe view controllers and their relationships."
                      },
                      {
                        "id": "MobileDev_087",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Easy",
                        "targetLevel": "Easy",
                        "questionText": "Which SwiftUI modifier hides a view conditionally while keeping layout space?",
                        "options": ["opacity(0)", "hidden()", "remove()", "collapsed()"],
                        "correctAnswerIndex": 1,
                        "explanation": "hidden() hides the view but preserves its layout space."
                      },
                      {
                        "id": "MobileDev_088",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Easy",
                        "targetLevel": "Easy",
                        "questionText": "Which local storage option is volatile and cleared on app termination?",
                        "options": ["In-memory variables", "UserDefaults", "Keychain", "Core Data"],
                        "correctAnswerIndex": 0,
                        "explanation": "In-memory data is lost when the app process ends."
                      },
                      {
                        "id": "MobileDev_089",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Easy",
                        "targetLevel": "Normal",
                        "questionText": "In SwiftUI, what triggers a view redraw?",
                        "options": [
                          "A change in observed state",
                          "A timer firing in the background",
                          "A network request completion alone",
                          "Calling body() directly"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "SwiftUI updates views when observed state changes."
                      },
                      {
                        "id": "MobileDev_090",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Easy",
                        "targetLevel": "Easy",
                        "questionText": "Which UIKit component manages multiple windows/scenes?",
                        "options": ["UISceneSession", "UIApplication", "UIWindow", "UIView"],
                        "correctAnswerIndex": 0,
                        "explanation": "UISceneSession represents a managed instance of a UI scene."
                      },

                      {
                        "id": "MobileDev_091",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Normal",
                        "targetLevel": "Normal",
                        "questionText": "Why should heavy JSON parsing be done off the main thread?",
                        "options": [
                          "To avoid blocking UI rendering",
                          "Because JSONDecoder is not thread-safe",
                          "Because networking APIs forbid main-thread work",
                          "To reduce memory leaks"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "CPU-heavy work on the main thread causes UI jank and freezes."
                      },
                      {
                        "id": "MobileDev_092",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Normal",
                        "targetLevel": "Normal",
                        "questionText": "What is the main benefit of using Codable for models?",
                        "options": [
                          "Automatic JSON encoding/decoding with less boilerplate",
                          "Guaranteed backward compatibility",
                          "Automatic persistence to disk",
                          "Built-in validation rules"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Codable simplifies mapping between models and external representations."
                      },
                      {
                        "id": "MobileDev_093",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Normal",
                        "targetLevel": "Hard",
                        "questionText": "Why can updating SwiftUI state from a background task cause issues?",
                        "options": [
                          "UI state must be updated on the main actor",
                          "SwiftUI does not support async code",
                          "Background tasks cannot access memory",
                          "ARC prevents cross-thread updates"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "SwiftUI UI-related state updates should occur on the main actor."
                      },
                      {
                        "id": "MobileDev_094",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Normal",
                        "targetLevel": "Normal",
                        "questionText": "What is the role of a Coordinator pattern in iOS apps?",
                        "options": [
                          "Handle navigation and flow outside view controllers",
                          "Persist data to disk",
                          "Manage background execution",
                          "Optimize Auto Layout constraints"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Coordinators decouple navigation logic from view controllers."
                      },
                      {
                        "id": "MobileDev_095",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Normal",
                        "targetLevel": "Normal",
                        "questionText": "What does URLCache primarily store?",
                        "options": [
                          "Cached HTTP responses",
                          "User credentials",
                          "Database query results",
                          "Background tasks"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "URLCache stores cached responses for URL requests."
                      },
                      {
                        "id": "MobileDev_096",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Normal",
                        "targetLevel": "Hard",
                        "questionText": "Why is separating ViewModels per screen recommended?",
                        "options": [
                          "To reduce coupling and improve maintainability",
                          "To guarantee faster app launch",
                          "To avoid using Combine",
                          "To reduce binary size"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Smaller, focused ViewModels are easier to reason about and test."
                      },
                      {
                        "id": "MobileDev_097",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Normal",
                        "targetLevel": "Normal",
                        "questionText": "Which iOS API provides haptic feedback?",
                        "options": ["UIImpactFeedbackGenerator", "AVAudioPlayer", "CoreMotion", "NotificationCenter"],
                        "correctAnswerIndex": 0,
                        "explanation": "UIImpactFeedbackGenerator triggers haptic feedback patterns."
                      },
                      {
                        "id": "MobileDev_098",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Normal",
                        "targetLevel": "Normal",
                        "questionText": "What does the main run loop manage?",
                        "options": [
                          "Event processing and UI updates",
                          "Database transaction ordering",
                          "Background URL sessions",
                          "File system journaling"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "The main run loop processes input events and schedules UI updates."
                      },
                      {
                        "id": "MobileDev_099",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Normal",
                        "targetLevel": "Hard",
                        "questionText": "Why can unstable IDs in SwiftUI ForEach cause bugs?",
                        "options": [
                          "SwiftUI may mis-diff views, causing state and animation issues",
                          "IDs control network request retries",
                          "IDs affect accessibility labels only",
                          "IDs are ignored by SwiftUI"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Unstable IDs break SwiftUI’s diffing assumptions."
                      },
                      {
                        "id": "MobileDev_100",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Normal",
                        "targetLevel": "Normal",
                        "questionText": "What is the main advantage of using async/await for networking code?",
                        "options": [
                          "Clearer, linear control flow with structured concurrency",
                          "Guaranteed faster network speed",
                          "Automatic retries on failure",
                          "No need for error handling"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "async/await simplifies asynchronous code readability and correctness."
                      },

                      {
                        "id": "MobileDev_101",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can combining UIKit and SwiftUI in the same screen be tricky?",
                        "options": [
                          "Different lifecycle and state management models can conflict",
                          "SwiftUI cannot run inside UIKit",
                          "UIKit views cannot receive touch events",
                          "SwiftUI disables Auto Layout"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "UIKit and SwiftUI have different lifecycle/state assumptions that must be bridged carefully."
                      },
                      {
                        "id": "MobileDev_102",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is the main purpose of MainActor in Swift concurrency for UI code?",
                        "options": [
                          "Ensure UI-related code runs on the main thread",
                          "Increase CPU parallelism",
                          "Replace DispatchQueue entirely",
                          "Automatically batch network requests"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "MainActor guarantees UI updates execute on the main thread."
                      },
                      {
                        "id": "MobileDev_103",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can excessive observers in NotificationCenter lead to bugs?",
                        "options": [
                          "Observers may outlive owners, causing unexpected callbacks",
                          "They block the main thread permanently",
                          "They prevent background execution",
                          "They disable SwiftUI updates"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Unmanaged observers can trigger callbacks on deallocated or unintended objects."
                      },
                      {
                        "id": "MobileDev_104",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is a common drawback of using global app state excessively?",
                        "options": [
                          "Hidden dependencies and unpredictable side effects",
                          "Guaranteed memory leaks",
                          "Inability to use SwiftUI",
                          "Slower compilation times"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Global state increases coupling and makes behavior harder to reason about."
                      },
                      {
                        "id": "MobileDev_105",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why should Core Data objects generally not be passed across threads?",
                        "options": [
                          "NSManagedObject instances are not thread-safe",
                          "They automatically deallocate on thread switch",
                          "They disable ARC",
                          "They corrupt the persistent store"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Managed objects are confined to their context’s queue."
                      },
                      {
                        "id": "MobileDev_106",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What issue can arise if a SwiftUI ViewModel is recreated too often?",
                        "options": [
                          "State resets and unnecessary work",
                          "Guaranteed memory leaks",
                          "Broken Auto Layout",
                          "Disabled animations"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Recreating ViewModels can reset state and trigger redundant processing."
                      },
                      {
                        "id": "MobileDev_107",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can misuse of DispatchQueue.main.async lead to subtle bugs?",
                        "options": [
                          "It can reorder execution and hide race conditions",
                          "It blocks the main thread indefinitely",
                          "It disables ARC deallocation",
                          "It prevents Combine subscriptions"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Overusing async dispatch can mask ordering issues and races."
                      },
                      {
                        "id": "MobileDev_108",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is the primary performance cost of excessive SwiftUI view recomputation?",
                        "options": [
                          "Increased CPU usage during diffing and layout",
                          "Higher network latency",
                          "More disk I/O",
                          "Increased GPU memory only"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Frequent recomputation increases CPU work for diffing and layout."
                      },
                      {
                        "id": "MobileDev_109",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can improper cancellation of async tasks cause issues in SwiftUI?",
                        "options": [
                          "Tasks may continue running after views disappear",
                          "Tasks automatically leak memory",
                          "Tasks block the main thread by default",
                          "Tasks disable animations"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Uncancelled tasks can waste resources and update stale state."
                      },
                      {
                        "id": "MobileDev_110",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is the main risk of storing sensitive data in UserDefaults?",
                        "options": [
                          "It is not designed for secure storage",
                          "It prevents background execution",
                          "It increases app size dramatically",
                          "It breaks iCloud sync"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "UserDefaults is not encrypted like Keychain and should not store secrets."
                      },
                      {
                        "id": "MobileDev_111",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can tight coupling between networking and UI layers be harmful?",
                        "options": [
                          "It reduces testability and flexibility",
                          "It improves performance too much",
                          "It prevents async/await usage",
                          "It forces all requests to be synchronous"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Coupling makes changes and testing harder across layers."
                      },
                      {
                        "id": "MobileDev_112",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What problem does debouncing user input solve?",
                        "options": [
                          "Avoids excessive repeated actions in rapid succession",
                          "Improves Auto Layout stability",
                          "Eliminates memory leaks",
                          "Guarantees thread safety"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Debouncing limits how often an action triggers during rapid input."
                      },
                      {
                        "id": "MobileDev_113",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can synchronous disk I/O on the main thread degrade UX?",
                        "options": [
                          "It blocks UI updates and user interactions",
                          "It disables background tasks",
                          "It corrupts the file system",
                          "It forces app termination"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Blocking I/O stalls the main run loop, freezing the UI."
                      },
                      {
                        "id": "MobileDev_114",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is a common reason to introduce a service layer in iOS apps?",
                        "options": [
                          "Encapsulate business logic and external dependencies",
                          "Replace ViewModels",
                          "Optimize Auto Layout",
                          "Handle push notifications"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Services isolate logic and dependencies from UI layers."
                      },
                      {
                        "id": "MobileDev_115",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can memory pressure notifications matter for large apps?",
                        "options": [
                          "Apps should release caches to avoid termination",
                          "They guarantee more background time",
                          "They disable ARC temporarily",
                          "They force garbage collection"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Responding to memory pressure helps prevent app termination."
                      },
                      {
                        "id": "MobileDev_116",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is the primary benefit of using identifiers instead of index paths for UI state?",
                        "options": [
                          "Stability across insertions and deletions",
                          "Faster animations",
                          "Lower memory usage",
                          "Automatic persistence"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Identifiers remain stable when list ordering changes."
                      },
                      {
                        "id": "MobileDev_117",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can excessive logging in production apps be problematic?",
                        "options": [
                          "Performance overhead and potential information leakage",
                          "It disables compiler optimizations",
                          "It prevents crash reporting",
                          "It blocks background execution"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Too much logging can slow apps and expose sensitive data."
                      },
                      {
                        "id": "MobileDev_118",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What issue can arise if multiple scenes share mutable singletons?",
                        "options": [
                          "State conflicts across independent UI sessions",
                          "Guaranteed deadlocks",
                          "Loss of accessibility support",
                          "Broken animations"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Shared mutable state can conflict across independent scenes."
                      },
                      {
                        "id": "MobileDev_119",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why is testing ViewModels without UI frameworks beneficial?",
                        "options": [
                          "Tests run faster and are more deterministic",
                          "It guarantees zero bugs",
                          "It eliminates the need for mocks",
                          "It enforces MVVM automatically"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Decoupled ViewModels enable fast, reliable unit tests."
                      },
                      {
                        "id": "MobileDev_120",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is the main downside of relying heavily on storyboard segues?",
                        "options": [
                          "Harder navigation logic and testing",
                          "Slower app launch always",
                          "Inability to support dark mode",
                          "Larger memory footprint"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Segues hide navigation logic and reduce explicit control."
                      },
                      {
                        "id": "MobileDev_121",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can frequent Core Data saves reduce performance?",
                        "options": [
                          "Each save may flush data and incur I/O cost",
                          "Saves always block all threads",
                          "Saves disable caching",
                          "Saves invalidate indexes"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Excessive saves increase disk I/O and slow performance."
                      },
                      {
                        "id": "MobileDev_122",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is a common reason to use background URLSession configurations?",
                        "options": [
                          "Allow transfers to continue when the app is suspended",
                          "Increase request priority",
                          "Disable caching automatically",
                          "Avoid TLS negotiation"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Background sessions let downloads/uploads continue outside the app’s lifetime."
                      },
                      {
                        "id": "MobileDev_123",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can large view hierarchies increase memory usage?",
                        "options": [
                          "Each view allocates memory and layout metadata",
                          "Views are stored on disk automatically",
                          "ARC duplicates views internally",
                          "SwiftUI caches all views forever"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "More views mean more objects and layout data in memory."
                      },
                      {
                        "id": "MobileDev_124",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is the main risk of ignoring app lifecycle transitions?",
                        "options": [
                          "Lost state or unfinished tasks",
                          "Guaranteed crashes on launch",
                          "Disabled background execution",
                          "Broken Auto Layout constraints"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Ignoring lifecycle events can leave work incomplete or state inconsistent."
                      },
                      {
                        "id": "MobileDev_125",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can tight coupling between ViewModels cause cascading updates?",
                        "options": [
                          "Changes in one ViewModel propagate unintentionally to others",
                          "ARC disables deallocation",
                          "It prevents async execution",
                          "It guarantees data consistency"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Coupled ViewModels can trigger unintended chains of updates."
                      },
                      {
                        "id": "MobileDev_126",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is the main benefit of feature-based module separation?",
                        "options": [
                          "Clear ownership and scalable codebase structure",
                          "Guaranteed faster build times",
                          "Automatic dependency injection",
                          "Reduced runtime memory usage"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Feature modules improve ownership and long-term maintainability."
                      },
                      {
                        "id": "MobileDev_127",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can unbounded Combine publishers cause memory issues?",
                        "options": [
                          "Subscriptions may never cancel and keep resources alive",
                          "Combine forces strong references always",
                          "Publishers block the main thread",
                          "They disable ARC optimizations"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Without cancellation, subscriptions can retain resources indefinitely."
                      },
                      {
                        "id": "MobileDev_128",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What problem does view-model scoping solve in SwiftUI?",
                        "options": [
                          "Ensures correct lifetime and reuse of state",
                          "Improves animation smoothness automatically",
                          "Eliminates network latency",
                          "Guarantees thread safety"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Proper scoping prevents unintended recreation or retention of ViewModels."
                      },
                      {
                        "id": "MobileDev_129",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "Why can improper error handling in async tasks degrade UX?",
                        "options": [
                          "Failures may be silent or leave UI in inconsistent state",
                          "Errors automatically crash the app",
                          "Errors block background threads",
                          "Errors disable SwiftUI updates"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Unreported errors can confuse users and leave stale UI."
                      },
                      {
                        "id": "MobileDev_130",
                        "category": "Mobile Dev",
                        "baseDifficulty": "Hard",
                        "targetLevel": "Hard",
                        "questionText": "What is the main architectural risk of mixing multiple state management styles?",
                        "options": [
                          "Increased complexity and harder reasoning about data flow",
                          "Guaranteed performance regression",
                          "Inability to support async/await",
                          "Loss of accessibility features"
                        ],
                        "correctAnswerIndex": 0,
                        "explanation": "Mixed state patterns make data flow and ownership harder to reason about."
                      },
                        {
                          "id": "MobileDev_131",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "In SwiftUI, which view is commonly used to overlay content on top of another view?",
                          "options": ["overlay(_:alignment:)", "background(_:)", "mask(_:)", "clipShape(_)"],
                          "correctAnswerIndex": 0,
                          "explanation": "overlay places another view on top of the original view."
                        },
                        {
                          "id": "MobileDev_132",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "Which UIKit method is called to lay out subviews after constraints are applied?",
                          "options": ["layoutSubviews()", "draw(_:)", "updateConstraints()", "didMoveToSuperview()"],
                          "correctAnswerIndex": 0,
                          "explanation": "layoutSubviews() is where a UIView lays out its children."
                        },
                        {
                          "id": "MobileDev_133",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Normal",
                          "questionText": "In SwiftUI, which property wrapper stores values in UserDefaults automatically?",
                          "options": ["@AppStorage", "@SceneStorage", "@State", "@Environment"],
                          "correctAnswerIndex": 0,
                          "explanation": "@AppStorage persists simple values via UserDefaults."
                        },
                        {
                          "id": "MobileDev_134",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "Which UIKit class is used to show a modal alert with actions?",
                          "options": ["UIAlertController", "UIMenuController", "UIActionSheet", "UIWindowScene"],
                          "correctAnswerIndex": 0,
                          "explanation": "UIAlertController presents alerts and action sheets."
                        },
                        {
                          "id": "MobileDev_135",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "In SwiftUI, which view is commonly used to push a new view with a tappable row?",
                          "options": ["NavigationLink", "Button", "Link", "Stepper"],
                          "correctAnswerIndex": 0,
                          "explanation": "NavigationLink triggers navigation to a destination in a NavigationStack."
                        },
                        {
                          "id": "MobileDev_136",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "Which file system location is typically used for user-generated app documents?",
                          "options": ["Documents directory", "Bundle directory", "Caches directory", "Temporary directory"],
                          "correctAnswerIndex": 0,
                          "explanation": "Documents is for user data that should persist and be backed up."
                        },
                        {
                          "id": "MobileDev_137",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "Which SwiftUI modifier rounds the corners of a view?",
                          "options": ["cornerRadius(_)", "shadow(radius:)", "blur(radius:)", "opacity(_)"],
                          "correctAnswerIndex": 0,
                          "explanation": "cornerRadius clips the view with rounded corners."
                        },
                        {
                          "id": "MobileDev_138",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Normal",
                          "questionText": "Which UIKit property defines a view’s position and size in its superview’s coordinate space?",
                          "options": ["frame", "bounds", "center", "transform"],
                          "correctAnswerIndex": 0,
                          "explanation": "frame is the rectangle in the superview’s coordinate system."
                        },
                        {
                          "id": "MobileDev_139",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "In SwiftUI, which container lazily loads rows for efficient scrolling?",
                          "options": ["LazyVStack", "VStack", "ZStack", "Group"],
                          "correctAnswerIndex": 0,
                          "explanation": "LazyVStack creates rows on demand as they appear."
                        },
                        {
                          "id": "MobileDev_140",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "What is the main purpose of the iOS Safe Area?",
                          "options": [
                            "Avoid placing content under system UI (notch/home indicator)",
                            "Prevent memory leaks",
                            "Guarantee 60 FPS animations",
                            "Encrypt local files"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Safe Area defines a region not obscured by system UI."
                        },
                        {
                          "id": "MobileDev_141",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "Which UIKit class is commonly used for grid-style layouts with reusable cells?",
                          "options": ["UICollectionView", "UITableView", "UIStackView", "UISplitViewController"],
                          "correctAnswerIndex": 0,
                          "explanation": "UICollectionView supports flexible layouts and cell reuse."
                        },
                        {
                          "id": "MobileDev_142",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "In SwiftUI, what does the Spacer() view primarily do?",
                          "options": [
                            "Push views apart by taking flexible space",
                            "Add padding inside a view",
                            "Align views to the top",
                            "Measure view geometry"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Spacer expands to occupy available space, pushing siblings apart."
                        },
                        {
                          "id": "MobileDev_143",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Normal",
                          "questionText": "Which local storage is best for non-critical, regeneratable data like images cache?",
                          "options": ["Caches directory", "Documents directory", "Keychain", "Bundle resources"],
                          "correctAnswerIndex": 0,
                          "explanation": "Caches can be purged by the system and is appropriate for regeneratable data."
                        },
                        {
                          "id": "MobileDev_144",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "Which UIKit lifecycle method is called after the view’s bounds are set and constraints laid out?",
                          "options": ["viewDidLayoutSubviews()", "viewDidLoad()", "viewWillAppear()", "viewDidAppear()"],
                          "correctAnswerIndex": 0,
                          "explanation": "viewDidLayoutSubviews runs after layout, useful for final frame-dependent work."
                        },
                        {
                          "id": "MobileDev_145",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "In MVVM, what is a common way for a View to react to ViewModel changes in SwiftUI?",
                          "options": ["Bind to observable state", "Call ViewModel methods in init()", "Use global variables", "Poll in a Timer"],
                          "correctAnswerIndex": 0,
                          "explanation": "SwiftUI renders based on bindings/observed state changes."
                        },
                        {
                          "id": "MobileDev_146",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Easy",
                          "questionText": "Which UIKit class is used to manage tab-based navigation?",
                          "options": ["UITabBarController", "UINavigationController", "UISplitViewController", "UIPageViewController"],
                          "correctAnswerIndex": 0,
                          "explanation": "UITabBarController manages multiple root tabs."
                        },
                        {
                          "id": "MobileDev_147",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Easy",
                          "targetLevel": "Normal",
                          "questionText": "In SwiftUI, which property wrapper stores values per scene and restores them automatically?",
                          "options": ["@SceneStorage", "@AppStorage", "@State", "@ObservedObject"],
                          "correctAnswerIndex": 0,
                          "explanation": "@SceneStorage persists per-scene state and restores it when the scene returns."
                        },

                        {
                          "id": "MobileDev_148",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "What is a key advantage of using NSCache for in-memory caching?",
                          "options": [
                            "It can evict objects automatically under memory pressure",
                            "It persists data across app launches",
                            "It encrypts cached objects automatically",
                            "It guarantees thread confinement"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "NSCache supports eviction and is memory-pressure aware."
                        },
                        {
                          "id": "MobileDev_149",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "In Auto Layout, what does a higher content hugging priority mean?",
                          "options": [
                            "The view resists growing beyond its intrinsic content size",
                            "The view resists shrinking below its intrinsic content size",
                            "The view always expands to fill the screen",
                            "The view ignores constraints"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Content hugging resists expansion; compression resistance resists shrinking."
                        },
                        {
                          "id": "MobileDev_150",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Hard",
                          "questionText": "Why is using 'AnyView' excessively in SwiftUI discouraged?",
                          "options": [
                            "It can degrade performance by erasing view type information",
                            "It prevents navigation from working",
                            "It disables state updates entirely",
                            "It forces all rendering onto the GPU"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Type erasure can reduce compiler optimizations and increase update cost."
                        },
                        {
                          "id": "MobileDev_151",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "What does prepareForReuse() in a reusable cell typically do?",
                          "options": [
                            "Reset cell state before it’s reused",
                            "Commit Core Data changes",
                            "Invalidate Auto Layout permanently",
                            "Start a background task"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "It clears old content/state to avoid displaying stale data."
                        },
                        {
                          "id": "MobileDev_152",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "In SwiftUI, why might you use PreferenceKey?",
                          "options": [
                            "Pass layout-related values up the view tree",
                            "Persist data securely in Keychain",
                            "Increase view redraw frequency",
                            "Replace navigation destinations"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "PreferenceKey lets children communicate values upward (e.g., sizes/offsets)."
                        },
                        {
                          "id": "MobileDev_153",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "What does traitCollectionDidChange(_:) help handle in UIKit?",
                          "options": [
                            "Environment changes like dark mode or size class updates",
                            "Database schema migrations",
                            "Network reconnect logic",
                            "Keychain access changes"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "It’s called when traits change (e.g., interface style, size class)."
                        },
                        {
                          "id": "MobileDev_154",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Hard",
                          "questionText": "Why can using NotificationCenter for app-wide state updates be risky?",
                          "options": [
                            "It can create implicit coupling and hard-to-trace data flow",
                            "It disables background execution",
                            "It guarantees main-thread deadlocks",
                            "It prevents SwiftUI rendering"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Broadcast-based updates hide dependencies and complicate debugging/testing."
                        },
                        {
                          "id": "MobileDev_155",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "Which approach is most appropriate to store a Codable model to disk?",
                          "options": [
                            "Encode to Data and write to a file in Documents/Application Support",
                            "Store the whole object in UserDefaults without encoding",
                            "Write the object directly to Bundle resources",
                            "Store it in NotificationCenter"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Codable models should be encoded (JSON/PropertyList) and written via FileManager."
                        },
                        {
                          "id": "MobileDev_156",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "What is the main reason to use Application Support directory?",
                          "options": [
                            "Store app-managed files that should persist but aren’t user documents",
                            "Store temporary files only",
                            "Store files that must be visible in Photos app",
                            "Store immutable app resources"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Application Support is for internal app data that persists across launches."
                        },
                        {
                          "id": "MobileDev_157",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "In MVVM, what is a common way to handle navigation cleanly?",
                          "options": [
                            "Move navigation decisions to a coordinator/router",
                            "Put navigation logic inside model entities",
                            "Trigger navigation inside database layer",
                            "Hard-code navigation in static global functions only"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Coordinators/routers centralize navigation and reduce view/controller coupling."
                        },
                        {
                          "id": "MobileDev_158",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Hard",
                          "questionText": "Why can forcing layout with layoutIfNeeded() inside animations be necessary?",
                          "options": [
                            "To ensure constraint changes are applied during the animation",
                            "To disable Auto Layout for the view",
                            "To prevent view reuse",
                            "To flush URLCache"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Calling layoutIfNeeded within an animation block animates constraint-based changes."
                        },
                        {
                          "id": "MobileDev_159",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "What does 'App Transport Security' (ATS) primarily enforce?",
                          "options": [
                            "Secure network connections (e.g., HTTPS) by default",
                            "Encrypted local file storage by default",
                            "Strong password rules in Keychain",
                            "Only background networking"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "ATS encourages secure transport like HTTPS unless explicitly configured."
                        },
                        {
                          "id": "MobileDev_160",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "In SwiftUI, what does .onAppear typically indicate?",
                          "options": [
                            "The view entered the view hierarchy and became visible",
                            "The app finished launching",
                            "The view was deallocated",
                            "The network request completed"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "onAppear runs when the view appears on screen (may run multiple times)."
                        },
                        {
                          "id": "MobileDev_161",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Hard",
                          "questionText": "Why can using shared mutable singletons complicate multi-scene apps?",
                          "options": [
                            "Independent scenes may unexpectedly affect each other’s state",
                            "Scenes cannot access singletons",
                            "Single-threaded rendering becomes mandatory",
                            "Navigation becomes impossible"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Multiple scenes can unintentionally share and mutate the same global state."
                        },
                        {
                          "id": "MobileDev_162",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "What is the primary purpose of a diffable snapshot in iOS lists?",
                          "options": [
                            "Describe current data state and apply changes with safe diffing",
                            "Persist list data to disk automatically",
                            "Disable cell reuse for stability",
                            "Guarantee O(1) insert performance"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Snapshots define the list state; the system diffs and animates updates safely."
                        },
                        {
                          "id": "MobileDev_163",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Normal",
                          "questionText": "Which Core Data component is commonly used to set up the stack quickly?",
                          "options": ["NSPersistentContainer", "NSFetchedResultsController", "NSManagedObjectID", "NSBatchInsertRequest"],
                          "correctAnswerIndex": 0,
                          "explanation": "NSPersistentContainer bundles the model, context, and persistent store setup."
                        },
                        {
                          "id": "MobileDev_164",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Normal",
                          "targetLevel": "Hard",
                          "questionText": "Why can using @State for reference types be problematic?",
                          "options": [
                            "@State is designed for value types; reference mutations may not trigger updates reliably",
                            "@State prevents compilation for classes",
                            "@State automatically writes to disk",
                            "@State always causes retain cycles"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Reference-type changes may not be observed; use ObservableObject patterns instead."
                        },

                        {
                          "id": "MobileDev_165",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "Why can Auto Layout constraint priority misconfiguration cause 'jumping' UI?",
                          "options": [
                            "Different constraints win in different passes, leading to unstable layouts",
                            "Priorities are ignored in release builds",
                            "Constraints become encrypted at runtime",
                            "Safe Area disables priorities"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "If priorities conflict, the solver may break different constraints, causing layout shifts."
                        },
                        {
                          "id": "MobileDev_166",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "What is a common cause of memory leaks in UIKit with timers?",
                          "options": [
                            "A repeating Timer strongly retains its target/closure",
                            "Timers automatically store data in UserDefaults",
                            "Timers cannot run on the main thread",
                            "ARC ignores Timer references"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Repeating timers can retain targets; invalidate or use weak captures."
                        },
                        {
                          "id": "MobileDev_167",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "Why can SwiftUI navigation become inconsistent when using multiple sources of truth?",
                          "options": [
                            "Competing state updates can desync the navigation stack and UI",
                            "NavigationStack disables state updates",
                            "SwiftUI forbids programmatic navigation",
                            "NavigationDestination runs on background threads"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Navigation should be driven by a single, consistent state source."
                        },
                        {
                          "id": "MobileDev_168",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "What is the primary risk of storing large blobs in Core Data without external storage?",
                          "options": [
                            "Store bloat and slower fetch/save performance",
                            "Immediate loss of data on backgrounding",
                            "Automatic keychain eviction",
                            "Disabled indexing for all entities"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Large blobs inflate the store and slow I/O; external storage/file refs can help."
                        },
                        {
                          "id": "MobileDev_169",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "Why can capturing self strongly in async tasks inside a ViewModel be risky?",
                          "options": [
                            "The task can keep the ViewModel alive longer than expected",
                            "async tasks cannot access class instances",
                            "It disables cancellation automatically",
                            "It forces tasks to run on the main thread"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Long-lived tasks can retain owners; use cancellation and avoid unintended retention."
                        },
                        {
                          "id": "MobileDev_170",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "What is the key downside of putting networking code directly inside SwiftUI views?",
                          "options": [
                            "Harder testing and lifecycle-coupled side effects",
                            "It makes networking faster",
                            "It guarantees consistent caching",
                            "It prevents error propagation"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Side effects inside views can rerun unexpectedly and are harder to test."
                        },
                        {
                          "id": "MobileDev_171",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "Why can Combine subscriptions cause retain cycles in UIKit?",
                          "options": [
                            "The sink closure captures self while self retains the cancellable",
                            "Publishers can only run on the main thread",
                            "Combine disables ARC for closures",
                            "Cancellables are value types so they leak by default"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "If VC stores cancellables and closures capture VC strongly, it forms a cycle."
                        },
                        {
                          "id": "MobileDev_172",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "What problem does 'idempotent UI updates' help prevent in mobile apps?",
                          "options": [
                            "Duplicate side effects when the same update runs multiple times",
                            "Slow DNS resolution",
                            "Auto Layout ambiguity",
                            "Keychain access failures"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Idempotent updates avoid applying the same side effect repeatedly on rerenders."
                        },
                        {
                          "id": "MobileDev_173",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "Why is it important to handle foreground/background transitions for network requests?",
                          "options": [
                            "Requests may be paused/canceled; UI state must remain consistent",
                            "iOS forbids requests in foreground",
                            "Requests automatically duplicate in background",
                            "ATS is disabled in background"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Lifecycle changes can interrupt work; apps should reconcile state on return."
                        },
                        {
                          "id": "MobileDev_174",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "What is the key benefit of using compositional layout in UICollectionView?",
                          "options": [
                            "Complex layouts with a declarative, flexible configuration",
                            "Automatic database pagination",
                            "Guaranteed constant-time inserts",
                            "Eliminates the need for cell reuse"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Compositional layout makes complex grids/lists easier to define and maintain."
                        },
                        {
                          "id": "MobileDev_175",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "Why can relying on device time for security decisions be unsafe?",
                          "options": [
                            "Users can change the clock, breaking assumptions about freshness/expiry",
                            "iOS forbids reading device time",
                            "Keychain becomes inaccessible",
                            "TLS stops working entirely"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Client clocks can be manipulated; prefer server-side validation for security."
                        },
                        {
                          "id": "MobileDev_176",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "What is a common cause of 'ghost updates' in SwiftUI when using async tasks?",
                          "options": [
                            "A completed task updates state after the view is no longer relevant",
                            "SwiftUI always reruns tasks in a tight loop",
                            "Tasks can’t be canceled",
                            "State updates are ignored unless using Combine"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "If you don’t cancel/guard, old tasks may update state after navigation."
                        },
                        {
                          "id": "MobileDev_177",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "Why can storing authentication tokens in plaintext files be dangerous?",
                          "options": [
                            "Tokens can be extracted from backups or device storage",
                            "Tokens automatically expire immediately",
                            "ATS blocks token usage",
                            "UIKit prevents file reads"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Sensitive tokens should be stored in Keychain, not plaintext files."
                        },
                        {
                          "id": "MobileDev_178",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "In UIKit, why can calling setNeedsLayout repeatedly in a loop be harmful?",
                          "options": [
                            "It can trigger excessive layout passes and hurt performance",
                            "It disables Auto Layout constraints",
                            "It forces view controllers to deallocate",
                            "It blocks all touch events permanently"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "Repeated invalidation can cause redundant layout work and dropped frames."
                        },
                        {
                          "id": "MobileDev_179",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "What is the main benefit of using DTOs between persistence and UI layers?",
                          "options": [
                            "Decouple UI from storage types and avoid thread/lifecycle issues",
                            "Increase network throughput automatically",
                            "Eliminate the need for error handling",
                            "Guarantee zero merge conflicts"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "DTOs prevent leaking Core Data/DB objects into UI and simplify testing."
                        },
                        {
                          "id": "MobileDev_180",
                          "category": "Mobile Dev",
                          "baseDifficulty": "Hard",
                          "targetLevel": "Hard",
                          "questionText": "Why can mixing imperative UIKit state changes with SwiftUI state cause bugs?",
                          "options": [
                            "Two state systems can diverge and fight over the rendered UI",
                            "SwiftUI cannot render on iOS",
                            "UIKit disables state updates",
                            "Auto Layout stops functioning"
                          ],
                          "correctAnswerIndex": 0,
                          "explanation": "If UIKit and SwiftUI each maintain their own source of truth, UI can desync."
                        },
                          {
                            "id": "Algorithm_001",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "What is the time complexity of binary search on a sorted array?",
                            "options": ["O(log n)", "O(n)", "O(n log n)", "O(1)"],
                            "correctAnswerIndex": 0,
                            "explanation": "Binary search halves the search space each step."
                          },
                          {
                            "id": "Algorithm_002",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "Which sorting algorithm is typically O(n^2) in the average case?",
                            "options": ["Insertion sort", "Merge sort", "Heap sort", "Counting sort"],
                            "correctAnswerIndex": 0,
                            "explanation": "Insertion sort is quadratic on average for random input."
                          },
                          {
                            "id": "Algorithm_003",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Normal",
                            "questionText": "In Big-O notation, which describes the worst-case growth?",
                            "options": ["Upper bound", "Lower bound", "Exact bound always", "Average-case only"],
                            "correctAnswerIndex": 0,
                            "explanation": "Big-O is an asymptotic upper bound (commonly used for worst-case)."
                          },
                          {
                            "id": "Algorithm_004",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "Which algorithm technique repeatedly chooses a locally optimal step?",
                            "options": ["Greedy", "Dynamic programming", "Backtracking", "Divide and conquer"],
                            "correctAnswerIndex": 0,
                            "explanation": "Greedy algorithms make locally optimal choices at each step."
                          },
                          {
                            "id": "Algorithm_005",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "What is the space complexity of an in-place sorting algorithm?",
                            "options": ["O(1) extra space", "O(n) extra space", "O(log n) extra space always", "O(n^2) extra space"],
                            "correctAnswerIndex": 0,
                            "explanation": "In-place means constant extra space (ignoring recursion stack unless specified)."
                          },
                          {
                            "id": "Algorithm_006",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "Which sorting algorithm is stable by default?",
                            "options": ["Merge sort", "Heap sort", "Quick sort", "Selection sort"],
                            "correctAnswerIndex": 0,
                            "explanation": "Merge sort preserves relative order of equal elements."
                          },
                          {
                            "id": "Algorithm_007",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "What is the typical time complexity of merge sort?",
                            "options": ["O(n log n)", "O(n^2)", "O(log n)", "O(n)"],
                            "correctAnswerIndex": 0,
                            "explanation": "Merge sort divides and merges across log n levels with O(n) work each."
                          },
                          {
                            "id": "Algorithm_008",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "What does a 'base case' prevent in recursion?",
                            "options": ["Infinite recursion", "Integer overflow", "Cache misses", "Deadlocks"],
                            "correctAnswerIndex": 0,
                            "explanation": "A base case stops recursion from continuing forever."
                          },
                          {
                            "id": "Algorithm_009",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "Which complexity best describes scanning an array once?",
                            "options": ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
                            "correctAnswerIndex": 0,
                            "explanation": "A single pass touches each element once."
                          },
                          {
                            "id": "Algorithm_010",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Normal",
                            "questionText": "Which term describes breaking a problem into smaller subproblems and combining results?",
                            "options": ["Divide and conquer", "Greedy", "Branch and bound", "Memoization only"],
                            "correctAnswerIndex": 0,
                            "explanation": "Divide-and-conquer solves subproblems and combines their results."
                          },
                          {
                            "id": "Algorithm_011",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "Which of these is a typical use case for dynamic programming?",
                            "options": ["Overlapping subproblems + optimal substructure", "Randomized hashing", "Packet routing", "Memory allocation"],
                            "correctAnswerIndex": 0,
                            "explanation": "DP is ideal when subproblems repeat and optimal substructure holds."
                          },
                          {
                            "id": "Algorithm_012",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "What is the typical time complexity of linear search?",
                            "options": ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
                            "correctAnswerIndex": 0,
                            "explanation": "In the worst case you check every element."
                          },
                          {
                            "id": "Algorithm_013",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "Which sorting algorithm repeatedly swaps adjacent out-of-order elements?",
                            "options": ["Bubble sort", "Quick sort", "Merge sort", "Radix sort"],
                            "correctAnswerIndex": 0,
                            "explanation": "Bubble sort performs adjacent swaps to move larger elements right."
                          },
                          {
                            "id": "Algorithm_014",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "Which is an example of a logarithmic-time operation?",
                            "options": ["Binary search", "Appending to array", "Scanning a list", "Nested loops over n elements"],
                            "correctAnswerIndex": 0,
                            "explanation": "Binary search reduces the search space exponentially."
                          },
                          {
                            "id": "Algorithm_015",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "What is the best-case time complexity of insertion sort on an already sorted array?",
                            "options": ["O(n)", "O(n log n)", "O(n^2)", "O(log n)"],
                            "correctAnswerIndex": 0,
                            "explanation": "Each insertion is constant work; a single pass is enough."
                          },
                          {
                            "id": "Algorithm_016",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Normal",
                            "questionText": "Which approach stores computed subproblem results to avoid recomputation?",
                            "options": ["Memoization", "Partitioning", "Bucketing", "Backtracking"],
                            "correctAnswerIndex": 0,
                            "explanation": "Memoization caches results of expensive function calls."
                          },
                          {
                            "id": "Algorithm_017",
                            "category": "Algorithm",
                            "baseDifficulty": "Easy",
                            "targetLevel": "Easy",
                            "questionText": "Which sorting algorithm picks a pivot and partitions elements around it?",
                            "options": ["Quick sort", "Selection sort", "Counting sort", "Insertion sort"],
                            "correctAnswerIndex": 0,
                            "explanation": "Quick sort partitions around a pivot and recursively sorts partitions."
                          },

                          {
                            "id": "Algorithm_018",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "What is the average-case time complexity of quicksort (with good pivots)?",
                            "options": ["O(n log n)", "O(n^2)", "O(log n)", "O(n)"],
                            "correctAnswerIndex": 0,
                            "explanation": "Balanced partitions yield log n levels with O(n) work per level."
                          },
                          {
                            "id": "Algorithm_019",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "What is the worst-case time complexity of quicksort?",
                            "options": ["O(n^2)", "O(n log n)", "O(n)", "O(log n)"],
                            "correctAnswerIndex": 0,
                            "explanation": "Highly unbalanced partitions (e.g., sorted input + poor pivot) cause quadratic time."
                          },
                          {
                            "id": "Algorithm_020",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Hard",
                            "questionText": "Which change most directly reduces quicksort's worst-case probability in practice?",
                            "options": ["Randomized pivot selection", "Using stable partitioning", "Switching to bubble sort for large arrays", "Removing recursion entirely"],
                            "correctAnswerIndex": 0,
                            "explanation": "Random pivots make adversarial worst-case inputs unlikely."
                          },
                          {
                            "id": "Algorithm_021",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "Which algorithmic pattern is used by merge sort?",
                            "options": ["Divide and conquer", "Greedy", "Backtracking", "Two pointers only"],
                            "correctAnswerIndex": 0,
                            "explanation": "Merge sort splits the array then merges sorted halves."
                          },
                          {
                            "id": "Algorithm_022",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "In DP, what does 'optimal substructure' mean?",
                            "options": [
                              "An optimal solution contains optimal solutions to subproblems",
                              "All subproblems must be independent",
                              "Greedy choices are always correct",
                              "The recursion must be tail-recursive"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "DP works when optimal global solutions are built from optimal subproblem solutions."
                          },
                          {
                            "id": "Algorithm_023",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "What is the space complexity of merge sort (typical implementation)?",
                            "options": ["O(n)", "O(1)", "O(log n)", "O(n log n)"],
                            "correctAnswerIndex": 0,
                            "explanation": "Merging usually requires an auxiliary array proportional to n."
                          },
                          {
                            "id": "Algorithm_024",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "Which technique is most suitable for finding a shortest path in an unweighted graph?",
                            "options": ["BFS", "DFS", "Dijkstra", "Bellman-Ford"],
                            "correctAnswerIndex": 0,
                            "explanation": "BFS explores in layers, giving shortest path in edges for unweighted graphs."
                          },
                          {
                            "id": "Algorithm_025",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "What is the key idea of the 'two pointers' technique?",
                            "options": [
                              "Maintain two indices to shrink or expand a search window efficiently",
                              "Always use recursion for searching",
                              "Sort then binary search every time",
                              "Use hash tables to replace arrays"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "Two pointers moves indices based on invariants (common in arrays/strings)."
                          },
                          {
                            "id": "Algorithm_026",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Hard",
                            "questionText": "Why is BFS preferred over DFS for shortest path in an unweighted graph?",
                            "options": [
                              "BFS guarantees the first time you reach a node is via the fewest edges",
                              "DFS always explores in sorted order",
                              "DFS uses less memory in all cases",
                              "BFS is always O(log n)"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "Layer-by-layer exploration ensures minimal edge count paths."
                          },
                          {
                            "id": "Algorithm_027",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "What is the time complexity of building a heap from an unsorted array (heapify)?",
                            "options": ["O(n)", "O(n log n)", "O(log n)", "O(n^2)"],
                            "correctAnswerIndex": 0,
                            "explanation": "Bottom-up heapify runs in linear time."
                          },
                          {
                            "id": "Algorithm_028",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "Which algorithm finds the minimum spanning tree using a priority queue and grows from a start node?",
                            "options": ["Prim's algorithm", "Kruskal's algorithm", "Dijkstra's algorithm", "Floyd-Warshall"],
                            "correctAnswerIndex": 0,
                            "explanation": "Prim grows the MST from a starting vertex using a min-heap of edges."
                          },
                          {
                            "id": "Algorithm_029",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "Which statement best describes top-down DP?",
                            "options": [
                              "Recursion with memoization",
                              "Iterative table fill with loops",
                              "Greedy local choices",
                              "Randomized partitioning"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "Top-down DP uses recursion and caches results."
                          },
                          {
                            "id": "Algorithm_030",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Hard",
                            "questionText": "In DP, why might you compress a 2D table into 1D?",
                            "options": [
                              "Reduce space from O(nm) to O(min(n,m)) when transitions only use previous row/column",
                              "Make time complexity O(1)",
                              "Ensure stable sorting",
                              "Avoid integer overflow"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "If state depends only on the previous layer, you can reuse one array."
                          },
                          {
                            "id": "Algorithm_031",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "What is the time complexity of checking all pairs in an array of size n?",
                            "options": ["O(n^2)", "O(n log n)", "O(n)", "O(log n)"],
                            "correctAnswerIndex": 0,
                            "explanation": "Two nested loops over n elements yield n^2 comparisons."
                          },
                          {
                            "id": "Algorithm_032",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "Which technique is commonly used to detect cycles in directed graphs?",
                            "options": ["DFS with recursion stack (colors)", "BFS with two pointers", "Binary search on edges", "Counting sort"],
                            "correctAnswerIndex": 0,
                            "explanation": "DFS coloring/recursion stack detects back edges indicating cycles."
                          },
                          {
                            "id": "Algorithm_033",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Normal",
                            "questionText": "What is the key invariant of a sliding window algorithm?",
                            "options": [
                              "Maintain a window that satisfies a condition while moving endpoints efficiently",
                              "Always keep the array fully sorted",
                              "Use recursion to backtrack all possibilities",
                              "Use a heap to store every element"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "Sliding window adjusts boundaries to maintain a condition with linear movement."
                          },
                          {
                            "id": "Algorithm_034",
                            "category": "Algorithm",
                            "baseDifficulty": "Normal",
                            "targetLevel": "Hard",
                            "questionText": "For longest substring without repeating characters, what makes sliding window O(n)?",
                            "options": [
                              "Each pointer moves at most n times, so total moves are linear",
                              "Hashing makes it O(1) regardless of n",
                              "Sorting the string first",
                              "Using recursion reduces complexity"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "Left/right pointers only advance forward, each at most n steps."
                          },

                          {
                            "id": "Algorithm_035",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "Which shortest path algorithm handles negative edge weights (but no negative cycles)?",
                            "options": ["Bellman-Ford", "Dijkstra", "Prim", "A* always"],
                            "correctAnswerIndex": 0,
                            "explanation": "Bellman-Ford relaxes edges V-1 times and supports negative weights."
                          },
                          {
                            "id": "Algorithm_036",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "Why does Dijkstra fail with negative edge weights?",
                            "options": [
                              "Greedy extraction assumes distances are final, which breaks with negative edges",
                              "It requires an adjacency matrix",
                              "It only works on trees",
                              "It cannot use a priority queue"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "Negative edges can produce a shorter path after a node is 'finalized'."
                          },
                          {
                            "id": "Algorithm_037",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "What is the time complexity of Floyd-Warshall for all-pairs shortest paths?",
                            "options": ["O(n^3)", "O(n^2)", "O(n log n)", "O(2^n)"],
                            "correctAnswerIndex": 0,
                            "explanation": "It uses three nested loops over vertices."
                          },
                          {
                            "id": "Algorithm_038",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "Which DP optimization uses monotonicity/convexity to reduce transitions (common in competitive programming)?",
                            "options": ["Convex Hull Trick", "Union-Find", "Topological sort", "Two pointers always"],
                            "correctAnswerIndex": 0,
                            "explanation": "Convex Hull Trick speeds up certain DP recurrences with linear functions."
                          },
                          {
                            "id": "Algorithm_039",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "What is the main idea of Kadane’s algorithm?",
                            "options": [
                              "Track best subarray ending at i to compute max subarray in O(n)",
                              "Sort and binary search subarray sums",
                              "Use two heaps to keep medians",
                              "Use BFS over indices"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "It maintains a running best ending at each position."
                          },
                          {
                            "id": "Algorithm_040",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "Why is matrix exponentiation used in some DP problems (e.g., Fibonacci)?",
                            "options": [
                              "Compute linear recurrences in O(log n) via exponentiation by squaring",
                              "Reduce space to O(1) only",
                              "Guarantee stable sorting",
                              "Avoid overflow automatically"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "Fast exponentiation computes recurrence powers in logarithmic time."
                          },
                          {
                            "id": "Algorithm_041",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "In backtracking, what technique prunes the search space most directly?",
                            "options": ["Bounding / constraint checks early", "Random shuffling", "Sorting outputs only", "Using arrays instead of lists"],
                            "correctAnswerIndex": 0,
                            "explanation": "Early constraint checks prevent exploring impossible partial solutions."
                          },
                          {
                            "id": "Algorithm_042",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "What is the typical time complexity of subset enumeration over n elements?",
                            "options": ["O(2^n)", "O(n log n)", "O(n^2)", "O(log n)"],
                            "correctAnswerIndex": 0,
                            "explanation": "Each element can be in or out, giving 2^n subsets."
                          },
                          {
                            "id": "Algorithm_043",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "Which algorithm finds SCCs (strongly connected components) in O(V+E)?",
                            "options": ["Kosaraju or Tarjan", "Dijkstra", "Prim", "KMP"],
                            "correctAnswerIndex": 0,
                            "explanation": "Kosaraju and Tarjan compute SCCs in linear time."
                          },
                          {
                            "id": "Algorithm_044",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "What is the key reason topological sorting requires a DAG?",
                            "options": [
                              "Cycles make it impossible to order prerequisites consistently",
                              "DAGs always have equal in-degree nodes",
                              "Only DAGs can be stored in adjacency lists",
                              "Cycles increase memory usage to O(n^2)"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "A cycle implies circular dependencies, so no valid topological order exists."
                          },
                          {
                            "id": "Algorithm_045",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "Which string algorithm uses an LPS/partial match table to avoid re-checking characters?",
                            "options": ["KMP", "Rabin-Karp", "Boyer-Moore", "Aho-Corasick"],
                            "correctAnswerIndex": 0,
                            "explanation": "KMP uses the LPS table to skip redundant comparisons."
                          },
                          {
                            "id": "Algorithm_046",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "Why is Rabin-Karp considered randomized/probabilistic in practice?",
                            "options": [
                              "Hash collisions can cause false matches unless verified",
                              "It requires random pivots",
                              "It uses random graph walks",
                              "It cannot handle ASCII strings"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "Rolling hashes may collide; verification is needed for correctness."
                          },
                          {
                            "id": "Algorithm_047",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "What does 'meet-in-the-middle' typically reduce in exponential problems?",
                            "options": [
                              "Time from O(2^n) to roughly O(2^(n/2)) at the cost of extra space",
                              "Space from O(n) to O(1)",
                              "Time from O(n log n) to O(log n)",
                              "Worst-case from O(n^2) to O(n)"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "Splitting into halves reduces exponential search by combining partial results."
                          },
                          {
                            "id": "Algorithm_048",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "Which technique speeds up many range sum queries after preprocessing?",
                            "options": ["Prefix sums", "Binary search", "Heapify", "Backtracking"],
                            "correctAnswerIndex": 0,
                            "explanation": "Prefix sums answer range sums in O(1) after O(n) preprocessing."
                          },
                          {
                            "id": "Algorithm_049",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "In DP, what does 'state transition' describe?",
                            "options": [
                              "How a state depends on previous states to build the answer",
                              "How to sort states lexicographically",
                              "How to parallelize recursion automatically",
                              "How to store state on disk"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "Transitions define recurrence relations between states."
                          },
                          {
                            "id": "Algorithm_050",
                            "category": "Algorithm",
                            "baseDifficulty": "Hard",
                            "targetLevel": "Hard",
                            "questionText": "What is the main benefit of using a priority queue in Dijkstra’s algorithm?",
                            "options": [
                              "Extract the next closest node efficiently",
                              "Guarantee negative weights work",
                              "Reduce memory to O(1)",
                              "Avoid storing adjacency lists"
                            ],
                            "correctAnswerIndex": 0,
                            "explanation": "A min-heap makes selecting the next smallest tentative distance efficient."
                          },
                            {
                              "id": "Algorithm_051",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "What is the time complexity of accessing an element by index in an array?",
                              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                              "correctAnswerIndex": 0,
                              "explanation": "Direct indexing uses pointer arithmetic, so it's constant time."
                            },
                            {
                              "id": "Algorithm_052",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "Which traversal visits nodes in the order: left, root, right?",
                              "options": ["In-order", "Pre-order", "Post-order", "Level-order"],
                              "correctAnswerIndex": 0,
                              "explanation": "In-order traversal is left subtree → node → right subtree."
                            },
                            {
                              "id": "Algorithm_053",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Normal",
                              "questionText": "Which search strategy explores the nearest neighbors first in a graph?",
                              "options": ["BFS", "DFS", "Binary search", "Greedy best-first always"],
                              "correctAnswerIndex": 0,
                              "explanation": "BFS expands nodes level by level, exploring neighbors first."
                            },
                            {
                              "id": "Algorithm_054",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "Which Big-O best describes an algorithm that runs in constant time?",
                              "options": ["O(1)", "O(n)", "O(log n)", "O(n^2)"],
                              "correctAnswerIndex": 0,
                              "explanation": "O(1) means runtime does not grow with input size."
                            },
                            {
                              "id": "Algorithm_055",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "Which sorting algorithm repeatedly selects the minimum remaining element?",
                              "options": ["Selection sort", "Quick sort", "Merge sort", "Radix sort"],
                              "correctAnswerIndex": 0,
                              "explanation": "Selection sort finds the minimum each pass and places it next."
                            },
                            {
                              "id": "Algorithm_056",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "What does 'stable sort' mean?",
                              "options": [
                                "Equal elements keep their relative order",
                                "The sort uses O(1) extra memory",
                                "The sort always runs in O(n log n)",
                                "The sort works only on integers"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "Stability preserves the original order among equal keys."
                            },
                            {
                              "id": "Algorithm_057",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "Which technique is commonly used to reduce repeated work in recursion?",
                              "options": ["Memoization", "Partitioning", "Bucketing", "Bit masking only"],
                              "correctAnswerIndex": 0,
                              "explanation": "Memoization caches results of subproblems to avoid recomputation."
                            },
                            {
                              "id": "Algorithm_058",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Normal",
                              "questionText": "In a max-heap, where is the maximum element located?",
                              "options": ["At the root", "At the last leaf", "At an arbitrary leaf", "In the middle level"],
                              "correctAnswerIndex": 0,
                              "explanation": "Heap property guarantees the maximum is at the root of a max-heap."
                            },
                            {
                              "id": "Algorithm_059",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "What is the time complexity of checking if an array is sorted (single pass)?",
                              "options": ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
                              "correctAnswerIndex": 0,
                              "explanation": "You compare adjacent pairs once across the array."
                            },
                            {
                              "id": "Algorithm_060",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "Which term describes a function calling itself?",
                              "options": ["Recursion", "Iteration", "Memoization", "Compilation"],
                              "correctAnswerIndex": 0,
                              "explanation": "Recursion is when a function calls itself to solve subproblems."
                            },
                            {
                              "id": "Algorithm_061",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "What is the best-case time complexity of binary search?",
                              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                              "correctAnswerIndex": 0,
                              "explanation": "If the middle element matches immediately, it finishes in constant time."
                            },
                            {
                              "id": "Algorithm_062",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "Which algorithm is commonly used to find the maximum of an unsorted array?",
                              "options": ["Single linear scan", "Binary search", "Merge sort then pick last", "Heapify then extract"],
                              "correctAnswerIndex": 0,
                              "explanation": "A linear scan tracks the best seen so far in O(n)."
                            },
                            {
                              "id": "Algorithm_063",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Normal",
                              "questionText": "What does the 'pivot' do in quicksort?",
                              "options": [
                                "Partitions elements into less-than and greater-than groups",
                                "Merges two sorted halves",
                                "Builds a heap in-place",
                                "Counts digit frequencies"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "The pivot splits the array around it for recursive sorting."
                            },
                            {
                              "id": "Algorithm_064",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "Which complexity class grows fastest as n increases?",
                              "options": ["O(2^n)", "O(n^2)", "O(n log n)", "O(log n)"],
                              "correctAnswerIndex": 0,
                              "explanation": "Exponential growth dominates polynomial and logarithmic growth."
                            },
                            {
                              "id": "Algorithm_065",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "Which algorithm finds shortest paths in a weighted graph with non-negative edges?",
                              "options": ["Dijkstra's algorithm", "BFS", "DFS", "Prim's algorithm"],
                              "correctAnswerIndex": 0,
                              "explanation": "Dijkstra computes shortest paths when all edge weights are non-negative."
                            },
                            {
                              "id": "Algorithm_066",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Easy",
                              "questionText": "What is the time complexity of a single push operation on a stack?",
                              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                              "correctAnswerIndex": 0,
                              "explanation": "Stack push updates the top pointer, which is constant time."
                            },
                            {
                              "id": "Algorithm_067",
                              "category": "Algorithm",
                              "baseDifficulty": "Easy",
                              "targetLevel": "Normal",
                              "questionText": "Which technique sorts by processing digits from least/most significant position?",
                              "options": ["Radix sort", "Heap sort", "Shell sort", "Selection sort"],
                              "correctAnswerIndex": 0,
                              "explanation": "Radix sort processes digits (often using counting sort per digit)."
                            },

                            {
                              "id": "Algorithm_068",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "Which sorting algorithm guarantees O(n log n) worst-case time and is in-place?",
                              "options": ["Heap sort", "Quick sort", "Insertion sort", "Counting sort"],
                              "correctAnswerIndex": 0,
                              "explanation": "Heap sort is O(n log n) worst-case and uses O(1) extra space."
                            },
                            {
                              "id": "Algorithm_069",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "What is the purpose of a 'visited' set in graph traversal?",
                              "options": [
                                "Prevent revisiting nodes and infinite loops",
                                "Guarantee shortest path in weighted graphs",
                                "Sort adjacency lists automatically",
                                "Reduce edge weights"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "Visited tracking avoids processing the same node repeatedly."
                            },
                            {
                              "id": "Algorithm_070",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Hard",
                              "questionText": "In a directed graph, which indicates a back edge during DFS and implies a cycle?",
                              "options": [
                                "An edge to a node currently in the recursion stack",
                                "An edge to any visited node",
                                "An edge to a leaf node only",
                                "An edge that decreases topological order"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "A back edge to an 'in-progress' node signals a directed cycle."
                            },
                            {
                              "id": "Algorithm_071",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "What is the typical time complexity of counting sort (in terms of n and k)?",
                              "options": ["O(n + k)", "O(n log n)", "O(k log n)", "O(n^2)"],
                              "correctAnswerIndex": 0,
                              "explanation": "Counting sort counts occurrences across range size k, then outputs in linear time."
                            },
                            {
                              "id": "Algorithm_072",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "What is the main benefit of using prefix sums?",
                              "options": [
                                "Answer range-sum queries in O(1) after preprocessing",
                                "Sort arrays in O(n)",
                                "Find medians in O(1)",
                                "Detect cycles in O(V+E)"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "Prefix sums allow constant-time range sum queries with precomputed cumulative sums."
                            },
                            {
                              "id": "Algorithm_073",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "Which algorithm finds a minimum spanning tree by sorting edges and using union-find?",
                              "options": ["Kruskal's algorithm", "Prim's algorithm", "Dijkstra's algorithm", "Bellman-Ford"],
                              "correctAnswerIndex": 0,
                              "explanation": "Kruskal sorts edges and adds them if they don't form a cycle (union-find)."
                            },
                            {
                              "id": "Algorithm_074",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "What is the time complexity of topological sort using Kahn’s algorithm?",
                              "options": ["O(V + E)", "O(V log V)", "O(E log V)", "O(V^2)"],
                              "correctAnswerIndex": 0,
                              "explanation": "Each vertex and edge is processed a constant number of times."
                            },
                            {
                              "id": "Algorithm_075",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Hard",
                              "questionText": "Why does Kahn’s algorithm fail to output all nodes if a graph has a cycle?",
                              "options": [
                                "Some nodes never reach in-degree 0",
                                "The queue becomes too large",
                                "Edges must be negative-weighted",
                                "It requires recursion"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "In a cycle, every node keeps a positive in-degree, so they never enter the queue."
                            },
                            {
                              "id": "Algorithm_076",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "In DP, what is the main difference between tabulation and memoization?",
                              "options": [
                                "Tabulation is bottom-up; memoization is top-down",
                                "Tabulation uses recursion; memoization uses loops",
                                "Tabulation requires a heap; memoization requires a queue",
                                "They have different correctness guarantees"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "Tabulation fills a table iteratively; memoization caches recursive calls."
                            },
                            {
                              "id": "Algorithm_077",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "What is the time complexity of inserting an element into a binary heap?",
                              "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                              "correctAnswerIndex": 0,
                              "explanation": "Insertion may bubble up along the heap height (log n)."
                            },
                            {
                              "id": "Algorithm_078",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "Which technique is best for finding if two numbers sum to a target in an unsorted array (typical case)?",
                              "options": ["Hash set (complements)", "Binary search only", "Counting sort then scan", "DFS on indices"],
                              "correctAnswerIndex": 0,
                              "explanation": "Store seen values in a hash set and check complements in O(n) average time."
                            },
                            {
                              "id": "Algorithm_079",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Hard",
                              "questionText": "Why does using a hash set for 'two-sum' achieve expected O(n) time?",
                              "options": [
                                "Average O(1) lookups per element",
                                "Guaranteed O(1) worst-case hashing",
                                "It avoids storing elements",
                                "It sorts data implicitly"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "Each iteration does O(1) average insert/lookup, so total is linear on average."
                            },
                            {
                              "id": "Algorithm_080",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "What is the typical time complexity of BFS on an adjacency list graph?",
                              "options": ["O(V + E)", "O(V log V)", "O(E log V)", "O(V^2)"],
                              "correctAnswerIndex": 0,
                              "explanation": "BFS processes each vertex and edge at most once."
                            },
                            {
                              "id": "Algorithm_081",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "Which algorithmic approach is used in 'binary search on answer' problems?",
                              "options": [
                                "Binary search over a monotonic feasibility function",
                                "Binary search over array indices only",
                                "Greedy over sorted edges",
                                "DP over subsets"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "You search the answer space where feasibility changes monotonically."
                            },
                            {
                              "id": "Algorithm_082",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Hard",
                              "questionText": "What is required for 'binary search on answer' to work correctly?",
                              "options": [
                                "A monotonic predicate (feasible → feasible for larger/smaller)",
                                "A stable sorting algorithm",
                                "A connected graph",
                                "No duplicates in input"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "Binary search needs a monotonic condition to discard half the search space safely."
                            },
                            {
                              "id": "Algorithm_083",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "What is the time complexity of Euclid’s algorithm for gcd(a, b) (in terms of value size)?",
                              "options": ["O(log min(a,b))", "O(min(a,b))", "O(a+b)", "O(1)"],
                              "correctAnswerIndex": 0,
                              "explanation": "The remainder decreases quickly; the number of steps is logarithmic in the values."
                            },
                            {
                              "id": "Algorithm_084",
                              "category": "Algorithm",
                              "baseDifficulty": "Normal",
                              "targetLevel": "Normal",
                              "questionText": "Which DP problem is a classic example of 0/1 knapsack pattern?",
                              "options": ["Select items with weights/values to maximize value under capacity", "Find median of two arrays", "Detect a cycle in graph", "Sort a stream online"],
                              "correctAnswerIndex": 0,
                              "explanation": "0/1 knapsack chooses each item at most once under a capacity constraint."
                            },

                            {
                              "id": "Algorithm_085",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "Which algorithm finds shortest paths in a DAG in O(V+E)?",
                              "options": ["Topological order + edge relaxation", "Dijkstra with heap", "Bellman-Ford", "Floyd-Warshall"],
                              "correctAnswerIndex": 0,
                              "explanation": "In a DAG, relaxing edges in topological order yields shortest paths in linear time."
                            },
                            {
                              "id": "Algorithm_086",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "Why can shortest path in a DAG be faster than Dijkstra?",
                              "options": [
                                "Topological order ensures each edge relaxes once without reprocessing",
                                "DAGs always have non-negative weights",
                                "Dijkstra cannot use adjacency lists",
                                "It avoids storing distances"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "No cycles means a single pass of relaxations in order is sufficient."
                            },
                            {
                              "id": "Algorithm_087",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "What is the amortized time complexity of append on a dynamic array?",
                              "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                              "correctAnswerIndex": 0,
                              "explanation": "Resizes are rare; total cost spread across appends yields amortized O(1)."
                            },
                            {
                              "id": "Algorithm_088",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "Which algorithm solves the maximum bipartite matching problem (classic approach)?",
                              "options": ["Hopcroft–Karp", "Kruskal", "Prim", "KMP"],
                              "correctAnswerIndex": 0,
                              "explanation": "Hopcroft–Karp is a standard efficient algorithm for bipartite matching."
                            },
                            {
                              "id": "Algorithm_089",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "In interval scheduling (maximize number of non-overlapping intervals), what greedy choice is correct?",
                              "options": ["Pick the interval with earliest finish time", "Pick the longest interval", "Pick the earliest start time", "Pick the highest weight only"],
                              "correctAnswerIndex": 0,
                              "explanation": "Earliest finish leaves maximum room for the remaining intervals."
                            },
                            {
                              "id": "Algorithm_090",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "Why does 'earliest finish time' greedy work for interval scheduling (unweighted)?",
                              "options": [
                                "It has an exchange argument: any optimal solution can be transformed to use earliest finish first",
                                "It is always the locally longest interval",
                                "It minimizes the number of intervals",
                                "It requires sorting by start time only"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "You can swap the first interval in an optimal set with the earliest-finishing one without reducing optimality."
                            },
                            {
                              "id": "Algorithm_091",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "Which algorithm finds the longest increasing subsequence in O(n log n)?",
                              "options": ["Patience sorting (tails array + binary search)", "Standard DP O(n^2)", "BFS over indices", "Heapify then extract"],
                              "correctAnswerIndex": 0,
                              "explanation": "Maintain minimal tail values and binary search positions to get O(n log n)."
                            },
                            {
                              "id": "Algorithm_092",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "In the O(n log n) LIS algorithm, what does the 'tails' array represent?",
                              "options": [
                                "Minimum possible tail value for an increasing subsequence of each length",
                                "The actual LIS sequence always",
                                "Counts of each value",
                                "A prefix sum table"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "tails[len] keeps the smallest tail for subsequences of length len+1."
                            },
                            {
                              "id": "Algorithm_093",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "Which algorithm is used for range minimum queries with updates in O(log n)?",
                              "options": ["Segment tree", "Prefix sums", "Two pointers", "Floyd-Warshall"],
                              "correctAnswerIndex": 0,
                              "explanation": "Segment trees support query/update in logarithmic time."
                            },
                            {
                              "id": "Algorithm_094",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "Why is a Fenwick tree (BIT) often preferred over a segment tree for sums?",
                              "options": [
                                "Simpler implementation with O(log n) updates/queries and low constant factors",
                                "It supports arbitrary range min/max faster than O(log n)",
                                "It works only for negative numbers",
                                "It avoids using arrays"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "BIT is compact and efficient for prefix sums and point updates."
                            },
                            {
                              "id": "Algorithm_095",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "What is the main idea behind A* search?",
                              "options": [
                                "Use f(n)=g(n)+h(n) to guide search with an admissible heuristic",
                                "Always expand the deepest node first",
                                "Only works on unweighted graphs",
                                "Sort nodes by degree"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "A* uses cost-so-far plus heuristic estimate to prioritize promising nodes."
                            },
                            {
                              "id": "Algorithm_096",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "When is A* guaranteed to find an optimal path?",
                              "options": [
                                "When the heuristic is admissible (never overestimates) and edge costs are non-negative",
                                "When the heuristic always overestimates",
                                "When the graph is a tree only",
                                "When using DFS as the underlying traversal"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "An admissible heuristic ensures A* doesn't miss the optimal path."
                            },
                            {
                              "id": "Algorithm_097",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "Which algorithm computes the edit distance (Levenshtein distance) between two strings?",
                              "options": ["Dynamic programming on prefixes", "KMP", "Rabin-Karp", "Topological sort"],
                              "correctAnswerIndex": 0,
                              "explanation": "Edit distance uses DP over prefix lengths with insert/delete/replace transitions."
                            },
                            {
                              "id": "Algorithm_098",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "What is the time complexity of the classic DP edit distance algorithm for lengths n and m?",
                              "options": ["O(nm)", "O(n log m)", "O(n+m)", "O(2^(n+m))"],
                              "correctAnswerIndex": 0,
                              "explanation": "It fills an (n+1)×(m+1) table with constant work per cell."
                            },
                            {
                              "id": "Algorithm_099",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "Why can 'branch and bound' outperform plain backtracking?",
                              "options": [
                                "It uses bounds to prune subtrees that cannot beat the current best solution",
                                "It guarantees polynomial time for NP-hard problems",
                                "It replaces recursion with BFS always",
                                "It avoids exploring any invalid partial solutions"
                              ],
                              "correctAnswerIndex": 0,
                              "explanation": "Tight bounds let you skip large parts of the search space early."
                            },
                            {
                              "id": "Algorithm_100",
                              "category": "Algorithm",
                              "baseDifficulty": "Hard",
                              "targetLevel": "Hard",
                              "questionText": "Which technique is most appropriate to find articulation points in an undirected graph?",
                              "options": ["Tarjan DFS with low-link values", "BFS layers", "Kruskal edge sorting", "Binary search on vertices"],
                              "correctAnswerIndex": 0,
                              "explanation": "Low-link DFS identifies articulation points based on discovery and low times."
                            },
                              {
                                "id": "Algorithm_101",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "What is the time complexity of finding the minimum element in an unsorted array?",
                                "options": ["O(n)", "O(log n)", "O(1)", "O(n log n)"],
                                "correctAnswerIndex": 0,
                                "explanation": "You must inspect each element at least once in the worst case."
                              },
                              {
                                "id": "Algorithm_102",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "Which sorting algorithm is typically fastest in practice on average for in-memory arrays?",
                                "options": ["Quick sort (well-implemented)", "Bubble sort", "Selection sort", "Bogosort"],
                                "correctAnswerIndex": 0,
                                "explanation": "Quicksort has good cache locality and O(n log n) average time."
                              },
                              {
                                "id": "Algorithm_103",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Normal",
                                "questionText": "What is the main idea of 'divide and conquer'?",
                                "options": [
                                  "Split into smaller subproblems, solve them, then combine results",
                                  "Try all possibilities and backtrack",
                                  "Always take the best local choice",
                                  "Store results in a hash table only"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Divide-and-conquer breaks a problem down and combines solved parts."
                              },
                              {
                                "id": "Algorithm_104",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "What is the time complexity of iterating over a 2D n×n matrix once with two loops?",
                                "options": ["O(n^2)", "O(n)", "O(log n)", "O(n log n)"],
                                "correctAnswerIndex": 0,
                                "explanation": "Two nested loops each run n times, producing n² iterations."
                              },
                              {
                                "id": "Algorithm_105",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "Which traversal visits nodes level by level in a tree?",
                                "options": ["Level-order (BFS)", "In-order", "Pre-order", "Post-order"],
                                "correctAnswerIndex": 0,
                                "explanation": "Level-order traversal is BFS over the tree."
                              },
                              {
                                "id": "Algorithm_106",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "Which complexity is smaller for large n?",
                                "options": ["O(log n)", "O(n)", "O(n log n)", "O(n^2)"],
                                "correctAnswerIndex": 0,
                                "explanation": "Logarithmic growth is slower than linear and polynomial growth."
                              },
                              {
                                "id": "Algorithm_107",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "What does 'worst-case' time complexity describe?",
                                "options": [
                                  "Maximum time over all inputs of size n",
                                  "Minimum time over all inputs of size n",
                                  "Average time assuming uniform distribution",
                                  "Time for the best pivot only"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Worst-case is an upper bound over all inputs of a given size."
                              },
                              {
                                "id": "Algorithm_108",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "Which algorithm is commonly used to find an element in a sorted array?",
                                "options": ["Binary search", "Linear search", "BFS", "DFS"],
                                "correctAnswerIndex": 0,
                                "explanation": "Binary search exploits ordering to cut the search space in half each step."
                              },
                              {
                                "id": "Algorithm_109",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "Which sorting algorithm repeatedly inserts the next element into a growing sorted prefix?",
                                "options": ["Insertion sort", "Heap sort", "Merge sort", "Radix sort"],
                                "correctAnswerIndex": 0,
                                "explanation": "Insertion sort grows a sorted prefix by inserting one element at a time."
                              },
                              {
                                "id": "Algorithm_110",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Normal",
                                "questionText": "What is a key advantage of merge sort over quicksort?",
                                "options": ["Stable sorting", "Always in-place", "O(1) extra space", "No recursion needed"],
                                "correctAnswerIndex": 0,
                                "explanation": "Merge sort is stable by default; quicksort usually isn't."
                              },
                              {
                                "id": "Algorithm_111",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "What is the time complexity of a single dequeue operation in a queue (ideal implementation)?",
                                "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                "correctAnswerIndex": 0,
                                "explanation": "A proper queue removes from the front in constant time."
                              },
                              {
                                "id": "Algorithm_112",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "Which algorithmic technique is best for problems with choices that build a solution step-by-step and may need undoing?",
                                "options": ["Backtracking", "Counting sort", "Heapify", "Prefix sums"],
                                "correctAnswerIndex": 0,
                                "explanation": "Backtracking explores choices and reverts (undoes) when a path fails."
                              },
                              {
                                "id": "Algorithm_113",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "What is the typical time complexity of heap sort?",
                                "options": ["O(n log n)", "O(n)", "O(log n)", "O(n^2)"],
                                "correctAnswerIndex": 0,
                                "explanation": "Building the heap is O(n) and extracting n elements costs O(n log n)."
                              },
                              {
                                "id": "Algorithm_114",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "Which technique reduces an exponential recursion by caching subproblem results?",
                                "options": ["Dynamic programming", "Topological sorting", "Heap operations", "Bloom filtering"],
                                "correctAnswerIndex": 0,
                                "explanation": "DP (memoization/tabulation) reuses results of overlapping subproblems."
                              },
                              {
                                "id": "Algorithm_115",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "What is the time complexity of removing the minimum from a min-heap?",
                                "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                "correctAnswerIndex": 0,
                                "explanation": "Sift-down along the heap height takes logarithmic time."
                              },
                              {
                                "id": "Algorithm_116",
                                "category": "Algorithm",
                                "baseDifficulty": "Easy",
                                "targetLevel": "Easy",
                                "questionText": "Which algorithm is typically used to detect if a directed graph has a cycle?",
                                "options": ["DFS with recursion stack (colors)", "Binary search", "Counting sort", "Two pointers"],
                                "correctAnswerIndex": 0,
                                "explanation": "A back edge to an 'in-progress' node indicates a directed cycle."
                              },

                              {
                                "id": "Algorithm_117",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "What is the main reason quicksort is often faster than merge sort in practice?",
                                "options": [
                                  "Better cache locality and less auxiliary memory",
                                  "It is stable by default",
                                  "It guarantees O(n log n) worst-case",
                                  "It avoids comparisons"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "In-place partitioning and cache friendliness often win in practice."
                              },
                              {
                                "id": "Algorithm_118",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "Which algorithm finds the shortest path in a graph with non-negative weights?",
                                "options": ["Dijkstra", "Bellman-Ford", "DFS", "Topological sort only"],
                                "correctAnswerIndex": 0,
                                "explanation": "Dijkstra’s greedy property holds when edge weights are non-negative."
                              },
                              {
                                "id": "Algorithm_119",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Hard",
                                "questionText": "Why does randomized quicksort help against adversarial inputs?",
                                "options": [
                                  "It makes the pivot independent of input order, lowering worst-case probability",
                                  "It guarantees stability",
                                  "It removes recursion depth",
                                  "It makes comparisons O(1)"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Randomness prevents consistently bad partitions caused by crafted input."
                              },
                              {
                                "id": "Algorithm_120",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "What is the time complexity of searching for a key in a balanced BST?",
                                "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                "correctAnswerIndex": 0,
                                "explanation": "A balanced BST has height O(log n), so search follows that path."
                              },
                              {
                                "id": "Algorithm_121",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "Which approach is best to find the k-th smallest element in an unsorted array (expected linear time)?",
                                "options": ["Quickselect", "Merge sort then index", "Binary search", "BFS"],
                                "correctAnswerIndex": 0,
                                "explanation": "Quickselect partitions like quicksort and runs in expected O(n)."
                              },
                              {
                                "id": "Algorithm_122",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "What is the key difference between BFS and DFS space usage (typical)?",
                                "options": [
                                  "BFS can store a wide frontier; DFS stores a deep path (stack)",
                                  "DFS always stores more than BFS",
                                  "BFS uses recursion only",
                                  "They both always use O(1) space"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "BFS may hold many nodes in the queue at once; DFS holds the current path."
                              },
                              {
                                "id": "Algorithm_123",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "What is the time complexity of Dijkstra using a binary heap (adjacency list)?",
                                "options": ["O((V+E) log V)", "O(V^2)", "O(E)", "O(V log E) only"],
                                "correctAnswerIndex": 0,
                                "explanation": "Each heap operation is log V; relaxations are done across edges."
                              },
                              {
                                "id": "Algorithm_124",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "Which strategy helps reduce recursion depth issues in quicksort implementations?",
                                "options": [
                                  "Recurse on smaller partition first (tail-recursion elimination)",
                                  "Always choose first element as pivot",
                                  "Switch to bubble sort for large partitions",
                                  "Disable partitioning"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Recursing on the smaller side keeps stack depth O(log n) in practice."
                              },
                              {
                                "id": "Algorithm_125",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Hard",
                                "questionText": "In 0/1 knapsack, why is iterating capacity backward used in 1D DP?",
                                "options": [
                                  "To prevent reusing the same item multiple times in the same iteration",
                                  "To reduce time complexity to O(n)",
                                  "To make the solution stable",
                                  "To avoid integer overflow"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Backward iteration ensures each item contributes at most once."
                              },
                              {
                                "id": "Algorithm_126",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "What does a 'monotonic queue' typically optimize?",
                                "options": [
                                  "Sliding window min/max queries in amortized O(1) per step",
                                  "Binary search in O(1)",
                                  "Sorting in O(n)",
                                  "Graph shortest paths with negative edges"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "It maintains candidates in monotonic order for efficient window min/max."
                              },
                              {
                                "id": "Algorithm_127",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "Which algorithm finds shortest paths from all nodes to all nodes in a dense graph (classic DP)?",
                                "options": ["Floyd-Warshall", "Dijkstra", "Prim", "Kruskal"],
                                "correctAnswerIndex": 0,
                                "explanation": "Floyd-Warshall runs O(n^3) and is common for all-pairs shortest paths."
                              },
                              {
                                "id": "Algorithm_128",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "What is the time complexity of building a prefix sum array of length n?",
                                "options": ["O(n)", "O(log n)", "O(n log n)", "O(1)"],
                                "correctAnswerIndex": 0,
                                "explanation": "Each prefix value depends on the previous one, so it's linear to compute."
                              },
                              {
                                "id": "Algorithm_129",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "Which technique is commonly used to compute the number of ways to reach a target with steps (e.g., climbing stairs)?",
                                "options": ["Dynamic programming", "Binary search", "Heap sort", "Topological sort only"],
                                "correctAnswerIndex": 0,
                                "explanation": "The count often depends on previous counts (overlapping subproblems)."
                              },
                              {
                                "id": "Algorithm_130",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Hard",
                                "questionText": "For matrix chain multiplication, what is the DP state typically?",
                                "options": [
                                  "dp[i][j] = min cost to multiply matrices i..j",
                                  "dp[i] = max prefix sum at i",
                                  "dp[i][j] = shortest path from i to j in a graph",
                                  "dp[i] = number of nodes in subtree i"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "The classic DP considers optimal split points between i and j."
                              },
                              {
                                "id": "Algorithm_131",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "What does 'amortized analysis' typically account for?",
                                "options": [
                                  "Average cost per operation over a sequence of operations",
                                  "Worst-case per single operation only",
                                  "Only CPU cache misses",
                                  "Only probabilistic correctness"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Amortized cost spreads occasional expensive operations across many cheap ones."
                              },
                              {
                                "id": "Algorithm_132",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "Which algorithm is typically used to find if a graph is bipartite?",
                                "options": ["BFS/DFS with 2-coloring", "Dijkstra", "Kruskal", "Floyd-Warshall"],
                                "correctAnswerIndex": 0,
                                "explanation": "A 2-coloring via BFS/DFS detects odd cycles and determines bipartiteness."
                              },
                              {
                                "id": "Algorithm_133",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Hard",
                                "questionText": "Why does 2-coloring fail exactly when a graph contains an odd cycle?",
                                "options": [
                                  "An odd cycle forces a vertex to need both colors",
                                  "Even cycles force conflicts",
                                  "Trees are not colorable",
                                  "Directed edges break BFS"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Odd cycles create a parity conflict that cannot be resolved with two colors."
                              },
                              {
                                "id": "Algorithm_134",
                                "category": "Algorithm",
                                "baseDifficulty": "Normal",
                                "targetLevel": "Normal",
                                "questionText": "What is the main use of 'bitmask DP'?",
                                "options": [
                                  "DP over subsets using bit representations (often 2^n states)",
                                  "Sorting integers faster than O(n log n)",
                                  "Reducing graph edges",
                                  "Streaming median computation"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Bitmasks compactly represent subsets for DP (e.g., TSP)."
                              },

                              {
                                "id": "Algorithm_135",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "What is the worst-case time complexity of quickselect?",
                                "options": ["O(n^2)", "O(n log n)", "O(log n)", "O(n)"],
                                "correctAnswerIndex": 0,
                                "explanation": "Bad pivots can create unbalanced partitions leading to quadratic time."
                              },
                              {
                                "id": "Algorithm_136",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "Which technique improves quickselect's expected performance?",
                                "options": [
                                  "Randomized pivot selection",
                                  "Stable merging",
                                  "Using a full heap sort each time",
                                  "Switching to bubble sort for large n"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Random pivots reduce the chance of consistently poor partitions."
                              },
                              {
                                "id": "Algorithm_137",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "What is the time complexity of finding the median of two sorted arrays (optimal algorithm)?",
                                "options": ["O(log(min(n,m)))", "O(n+m)", "O(n log m)", "O((n+m) log(n+m))"],
                                "correctAnswerIndex": 0,
                                "explanation": "Binary search on partition position gives logarithmic time in the smaller array."
                              },
                              {
                                "id": "Algorithm_138",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "In Union-Find, what does path compression optimize?",
                                "options": [
                                  "Find operation by flattening trees over time",
                                  "Union operation by sorting sets",
                                  "Graph traversal by reducing edges",
                                  "DP transitions by caching states"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Path compression makes future finds faster by shortening parent chains."
                              },
                              {
                                "id": "Algorithm_139",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "With union by rank + path compression, what is the amortized time per Union-Find operation?",
                                "options": ["Nearly O(1) (inverse Ackermann)", "O(log n)", "O(n)", "O(n log n)"],
                                "correctAnswerIndex": 0,
                                "explanation": "The inverse Ackermann function grows extremely slowly, effectively constant."
                              },
                              {
                                "id": "Algorithm_140",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "Why does Bellman-Ford detect negative cycles?",
                                "options": [
                                  "An extra relaxation after V-1 rounds still improving implies a negative cycle",
                                  "It uses BFS levels",
                                  "It requires a DAG",
                                  "It sorts edges by weight"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "If distances can still decrease after V-1 relaxations, a negative cycle exists."
                              },
                              {
                                "id": "Algorithm_141",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "What is the key invariant used by Kadane’s algorithm?",
                                "options": [
                                  "bestEndingHere = max(nums[i], bestEndingHere + nums[i])",
                                  "Always keep a sorted prefix",
                                  "Always pick earliest finishing interval",
                                  "Always relax edges V times"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "The max subarray ending at i is either start fresh at i or extend previous."
                              },
                              {
                                "id": "Algorithm_142",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "Which algorithm is commonly used for maximum flow in practice with good performance on many graphs?",
                                "options": ["Dinic's algorithm", "Prim's algorithm", "KMP", "Heap sort"],
                                "correctAnswerIndex": 0,
                                "explanation": "Dinic uses level graphs + blocking flows and is fast in many scenarios."
                              },
                              {
                                "id": "Algorithm_143",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "In Dinic’s algorithm, what is the purpose of the level graph?",
                                "options": [
                                  "Restrict augmenting paths to strictly increasing levels",
                                  "Sort edges by capacity",
                                  "Detect negative cycles",
                                  "Compute MST from residual edges"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Level graph guides BFS layers so DFS finds blocking flows efficiently."
                              },
                              {
                                "id": "Algorithm_144",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "What does 'admissible heuristic' mean in A*?",
                                "options": [
                                  "It never overestimates the true remaining cost",
                                  "It always overestimates the remaining cost",
                                  "It must be exactly the true cost",
                                  "It works only on trees"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Admissibility ensures A* can guarantee optimal solutions."
                              },
                              {
                                "id": "Algorithm_145",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "What is the main idea behind 'minimax' in game search?",
                                "options": [
                                  "Assume optimal play: maximize your gain while minimizing opponent's gain",
                                  "Always pick the move with highest immediate score",
                                  "Randomly explore game states",
                                  "Use prefix sums to speed up moves"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Minimax models two-player optimal decisions across game states."
                              },
                              {
                                "id": "Algorithm_146",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "What does alpha-beta pruning optimize in minimax?",
                                "options": [
                                  "It prunes branches that cannot affect the final decision",
                                  "It guarantees a better move than minimax",
                                  "It converts exponential time to polynomial always",
                                  "It sorts moves without evaluating them"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Alpha-beta cuts off branches when bounds show they can't change the outcome."
                              },
                              {
                                "id": "Algorithm_147",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "In rolling hash (Rabin-Karp), what makes updating the hash per step efficient?",
                                "options": [
                                  "Remove outgoing char and add incoming char in O(1)",
                                  "Recompute the whole hash in O(n)",
                                  "Sort the substring each step",
                                  "Build a suffix tree per window"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Rolling hash updates incrementally with constant work per shift."
                              },
                              {
                                "id": "Algorithm_148",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "Why do collisions matter in hash-based string matching?",
                                "options": [
                                  "Different strings may share a hash, causing false matches unless verified",
                                  "Collisions make the algorithm stable",
                                  "Collisions reduce memory usage",
                                  "Collisions guarantee O(1) worst-case time"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Hash equality isn't string equality; verification avoids incorrect matches."
                              },
                              {
                                "id": "Algorithm_149",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "Which data structure enables range add / range sum queries efficiently (classic approach)?",
                                "options": ["Fenwick tree with difference/prefix trick", "Stack", "Queue", "Binary search tree only"],
                                "correctAnswerIndex": 0,
                                "explanation": "BITs can support range operations via prefix transforms (e.g., two BITs)."
                              },
                              {
                                "id": "Algorithm_150",
                                "category": "Algorithm",
                                "baseDifficulty": "Hard",
                                "targetLevel": "Hard",
                                "questionText": "What is the key idea of 'DP over DAG'?",
                                "options": [
                                  "Process nodes in topological order and compute dp from predecessors",
                                  "Process nodes in random order and retry",
                                  "Use BFS levels only",
                                  "Use union-find to merge states"
                                ],
                                "correctAnswerIndex": 0,
                                "explanation": "Topological order ensures all dependencies are computed before a node."
                              },
                                {
                                  "id": "Algorithm_151",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "Which Big-O describes an algorithm that doubles its work when n increases by 1?",
                                  "options": ["O(2^n)", "O(n^2)", "O(n log n)", "O(log n)"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Exponential algorithms grow by a constant factor per +1 input size."
                                },
                                {
                                  "id": "Algorithm_152",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "Which sorting algorithm is based on repeatedly comparing and swapping adjacent elements (best-known as simplest stable sort)?",
                                  "options": ["Bubble sort", "Heap sort", "Quick sort", "Selection sort"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Bubble sort swaps adjacent out-of-order pairs and is stable."
                                },
                                {
                                  "id": "Algorithm_153",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Normal",
                                  "questionText": "In Big-O analysis, which term dominates for large n in: 3n^2 + 10n + 5?",
                                  "options": ["n^2", "n", "log n", "1"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "The highest-order term (n^2) dominates asymptotically."
                                },
                                {
                                  "id": "Algorithm_154",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "What is the primary goal of a 'shortest path' algorithm?",
                                  "options": [
                                    "Find a minimum-cost route between nodes",
                                    "Find the largest connected component",
                                    "Find a minimum spanning tree",
                                    "Find all cycles in a graph"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Shortest path minimizes total path cost (edges/weights)."
                                },
                                {
                                  "id": "Algorithm_155",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "What is the time complexity of a single comparison operation between two integers?",
                                  "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Primitive comparisons are constant-time operations."
                                },
                                {
                                  "id": "Algorithm_156",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "Which technique is commonly used to avoid stack overflow from deep recursion?",
                                  "options": ["Convert to iteration using an explicit stack", "Use more global variables", "Increase time complexity", "Disable base cases"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Replacing recursion with an explicit stack avoids deep call stacks."
                                },
                                {
                                  "id": "Algorithm_157",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "In graph terms, what does an edge represent?",
                                  "options": ["A connection between two vertices", "A vertex degree", "A connected component", "A traversal order"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Edges connect pairs of vertices (directed or undirected)."
                                },
                                {
                                  "id": "Algorithm_158",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "Which algorithm uses a queue as its core data structure for traversal?",
                                  "options": ["BFS", "DFS", "Quick sort", "Binary search"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "BFS explores layer-by-layer using a queue."
                                },
                                {
                                  "id": "Algorithm_159",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "What is the primary use of a 'priority queue' in algorithms?",
                                  "options": [
                                    "Efficiently get/remove the highest or lowest priority element",
                                    "Store elements in insertion order",
                                    "Guarantee O(1) search for any value",
                                    "Ensure stable sorting automatically"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Priority queues support fast extract-min/max operations."
                                },
                                {
                                  "id": "Algorithm_160",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Normal",
                                  "questionText": "Which complexity is typically used to describe recursion depth for balanced divide-and-conquer?",
                                  "options": ["O(log n)", "O(n)", "O(n log n)", "O(2^n)"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Balanced splitting yields logarithmic recursion depth."
                                },
                                {
                                  "id": "Algorithm_161",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "Which algorithmic concept describes solving a problem by trying all possibilities?",
                                  "options": ["Brute force", "Greedy", "Dynamic programming", "Topological sorting"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Brute force enumerates all candidates to find the answer."
                                },
                                {
                                  "id": "Algorithm_162",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "Which is a typical sign you should consider dynamic programming?",
                                  "options": [
                                    "Overlapping subproblems",
                                    "No repeated states ever",
                                    "Purely random behavior",
                                    "Only constant-size input"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "DP helps when subproblems repeat and can be cached."
                                },
                                {
                                  "id": "Algorithm_163",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "Which technique is used to keep only the best candidates while scanning data once?",
                                  "options": ["Maintain a running best", "Full sort every step", "Rebuild the graph each step", "Restart recursion each step"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "A running best (or best-k) avoids unnecessary recomputation."
                                },
                                {
                                  "id": "Algorithm_164",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "What is the main output of a sorting algorithm?",
                                  "options": ["Elements arranged in non-decreasing order", "Only unique elements", "A graph traversal order", "A minimum spanning tree"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Sorting reorders elements based on a comparison/key order."
                                },
                                {
                                  "id": "Algorithm_165",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Normal",
                                  "questionText": "Which property is required for standard binary search to be correct?",
                                  "options": ["Monotonic order (sorted by the searched key)", "All elements distinct", "Constant spacing between values", "Prime array length"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Binary search relies on sorted order to discard half the range safely."
                                },
                                {
                                  "id": "Algorithm_166",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Easy",
                                  "targetLevel": "Easy",
                                  "questionText": "Which is a common application of a greedy algorithm?",
                                  "options": ["Interval scheduling (unweighted)", "Edit distance", "0/1 knapsack", "Longest common subsequence"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Unweighted interval scheduling is optimally solved by greedy earliest-finish selection."
                                },

                                {
                                  "id": "Algorithm_167",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "What is the typical time complexity of DFS on an adjacency list graph?",
                                  "options": ["O(V + E)", "O(V log V)", "O(E log V)", "O(V^2)"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "DFS visits each vertex and explores each edge at most once."
                                },
                                {
                                  "id": "Algorithm_168",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "In a grid shortest-path problem with uniform move cost, which approach is most appropriate?",
                                  "options": ["BFS", "Dijkstra", "Bellman-Ford", "Floyd-Warshall"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Uniform costs mean BFS finds the shortest path in number of steps."
                                },
                                {
                                  "id": "Algorithm_169",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Hard",
                                  "questionText": "Why might Dijkstra be preferred over BFS in a grid with varying terrain costs?",
                                  "options": [
                                    "Dijkstra handles non-uniform non-negative edge weights correctly",
                                    "BFS always requires negative weights",
                                    "Dijkstra uses less memory than BFS in all cases",
                                    "BFS cannot be implemented with a queue"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "When costs vary, BFS no longer guarantees optimality; Dijkstra does."
                                },
                                {
                                  "id": "Algorithm_170",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "Which algorithm finds the number of inversions in an array in O(n log n)?",
                                  "options": ["Modified merge sort", "Heap sort", "Selection sort", "Linear scan only"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Merge sort can count cross-inversions during merge in O(n log n)."
                                },
                                {
                                  "id": "Algorithm_171",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "For 'top K largest elements' in a stream, which approach is typically best?",
                                  "options": ["Maintain a min-heap of size K", "Sort after every insertion", "Use DFS", "Use prefix sums"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "A size-K min-heap keeps the K best with O(log K) per element."
                                },
                                {
                                  "id": "Algorithm_172",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "What is the time complexity per element when maintaining a min-heap of size K for top-K?",
                                  "options": ["O(log K)", "O(K)", "O(log n)", "O(1)"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Each push/pop in a heap costs logarithmic time in the heap size."
                                },
                                {
                                  "id": "Algorithm_173",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "In coin change (min coins), what does dp[x] typically represent?",
                                  "options": ["Minimum coins needed to make sum x", "Number of subsets summing to x", "Maximum coin value used", "Shortest path length to x"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "The standard DP state stores the optimal min-coins value for each sum."
                                },
                                {
                                  "id": "Algorithm_174",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "Which algorithmic technique is used by 'merge k sorted lists' efficiently?",
                                  "options": ["Min-heap over current heads", "Two pointers only", "Counting sort", "Backtracking"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "A min-heap picks the smallest head among k lists each step."
                                },
                                {
                                  "id": "Algorithm_175",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Hard",
                                  "questionText": "What is the time complexity of merging k sorted lists with total N elements using a heap?",
                                  "options": ["O(N log k)", "O(N log N)", "O(k log N)", "O(Nk)"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Each of N heap operations costs log k."
                                },
                                {
                                  "id": "Algorithm_176",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "Which property must hold to apply greedy algorithms safely?",
                                  "options": ["Greedy-choice property", "Negative edge weights", "Stable ordering", "No recursion"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "You need that a locally optimal choice can lead to a global optimum."
                                },
                                {
                                  "id": "Algorithm_177",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "Which problem is classically solved by 'two pointers on a sorted array'?",
                                  "options": ["Pair sum to target", "Edit distance", "Topological ordering", "Minimum spanning tree"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Two pointers shrink the range based on sum comparisons in sorted arrays."
                                },
                                {
                                  "id": "Algorithm_178",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "What is the typical time complexity of 'two pointers' scan on an array of length n?",
                                  "options": ["O(n)", "O(log n)", "O(n log n)", "O(n^2)"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Each pointer moves forward at most n times total."
                                },
                                {
                                  "id": "Algorithm_179",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "In DP, what is a 'transition'?",
                                  "options": [
                                    "A formula relating dp state to previous dp states",
                                    "A sorting step for dp tables",
                                    "A heap operation on dp arrays",
                                    "A graph edge direction change"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Transitions define how to compute a state from already-known states."
                                },
                                {
                                  "id": "Algorithm_180",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "Which algorithm is best to find a pattern in a text in O(n+m) time deterministically?",
                                  "options": ["KMP", "Rabin-Karp (single hash)", "Naive scan", "Bubble sort on characters"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "KMP avoids re-checks using the LPS table, achieving linear time."
                                },
                                {
                                  "id": "Algorithm_181",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Hard",
                                  "questionText": "Why can Rabin-Karp be O(n+m) expected but not strictly deterministic?",
                                  "options": [
                                    "Hash collisions can force extra verification work",
                                    "It requires negative edge weights",
                                    "It cannot handle Unicode",
                                    "It depends on recursion depth"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Collisions can cause additional comparisons unless using perfect hashing."
                                },
                                {
                                  "id": "Algorithm_182",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "Which approach is typically used to find shortest paths from a single source in a DAG?",
                                  "options": ["Topological order + relaxation", "Prim's algorithm", "Kruskal's algorithm", "Heap sort"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Topological order ensures predecessors are processed before each node."
                                },
                                {
                                  "id": "Algorithm_183",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Normal",
                                  "targetLevel": "Normal",
                                  "questionText": "What does 'relaxation' mean in shortest path algorithms?",
                                  "options": [
                                    "Try to improve a distance estimate using an edge",
                                    "Sort edges by weight",
                                    "Delete unused vertices",
                                    "Compress paths in union-find"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Relaxation updates dist[v] if going through u gives a shorter path."
                                },

                                {
                                  "id": "Algorithm_184",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "Which condition on an A* heuristic is stronger than admissibility and prevents re-expanding nodes (with appropriate implementation)?",
                                  "options": ["Consistency (monotonicity)", "Randomness", "Non-negativity only", "Stability"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Consistent heuristics satisfy triangle inequality, enabling efficient optimal search."
                                },
                                {
                                  "id": "Algorithm_185",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "What is the time complexity of a typical segment tree range query?",
                                  "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Segment tree queries traverse O(log n) nodes on each level."
                                },
                                {
                                  "id": "Algorithm_186",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "Which technique supports range updates and range queries in segment trees efficiently?",
                                  "options": ["Lazy propagation", "Path compression", "Two pointers", "Rolling hash"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Lazy propagation postpones updates to avoid touching all elements in a range."
                                },
                                {
                                  "id": "Algorithm_187",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "For 'count of distinct elements in many subarray queries' offline, which classic approach is used?",
                                  "options": ["Mo's algorithm", "KMP", "Prim's algorithm", "Bellman-Ford"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Mo's algorithm reorders queries to update a sliding range efficiently."
                                },
                                {
                                  "id": "Algorithm_188",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "Which algorithm finds bridges in an undirected graph in O(V+E)?",
                                  "options": ["Tarjan DFS with low-link values", "Kruskal with union-find", "Dijkstra with heap", "Floyd-Warshall"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Low-link DFS identifies edges whose removal disconnects the graph."
                                },
                                {
                                  "id": "Algorithm_189",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "What is the main reason 'meet-in-the-middle' reduces exponential time?",
                                  "options": [
                                    "It splits the search space into two halves and combines results",
                                    "It guarantees a greedy optimum",
                                    "It avoids sorting entirely",
                                    "It converts recursion into iteration"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Two half-exponentials (2^(n/2)) can be combined more efficiently than 2^n."
                                },
                                {
                                  "id": "Algorithm_190",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "Which algorithm solves weighted interval scheduling optimally?",
                                  "options": ["DP with binary search for previous compatible interval", "Earliest finish greedy", "BFS", "Union-Find"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Weights break the simple greedy rule; DP + binary search gives optimal results."
                                },
                                {
                                  "id": "Algorithm_191",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "In weighted interval scheduling, what does dp[i] typically represent after sorting by finish time?",
                                  "options": [
                                    "Max total weight using intervals up to i",
                                    "Min number of intervals up to i",
                                    "Shortest path to interval i",
                                    "Number of inversions up to i"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "dp[i] is the best achievable weight considering intervals 0..i."
                                },
                                {
                                  "id": "Algorithm_192",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "Why is Bellman-Ford O(VE) time?",
                                  "options": [
                                    "It relaxes all E edges for V-1 rounds",
                                    "It sorts edges each round",
                                    "It uses a heap for each vertex",
                                    "It performs DFS from every node"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "V-1 passes over E edges yields O(VE)."
                                },
                                {
                                  "id": "Algorithm_193",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "Which algorithm computes the LCA (lowest common ancestor) with binary lifting preprocessing?",
                                  "options": ["Binary lifting with O(n log n) preprocess", "KMP", "Kruskal", "Mo's algorithm"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Binary lifting stores 2^k ancestors to jump upward in log n per query."
                                },
                                {
                                  "id": "Algorithm_194",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "What is the query time complexity of LCA using binary lifting?",
                                  "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "You lift nodes by powers of two, requiring logarithmic steps."
                                },
                                {
                                  "id": "Algorithm_195",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "Which algorithm is appropriate to find the shortest path in a graph with negative edges and detect negative cycles?",
                                  "options": ["Bellman-Ford", "Dijkstra", "Prim", "BFS"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Bellman-Ford supports negative edges and can detect negative cycles."
                                },
                                {
                                  "id": "Algorithm_196",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "What is the main insight behind 'median of medians' selection?",
                                  "options": [
                                    "Choose a pivot that guarantees linear worst-case time selection",
                                    "Randomize pivots to reduce average time",
                                    "Sort the entire array first",
                                    "Use BFS to find k-th element"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "A carefully chosen pivot ensures enough elements are discarded each step."
                                },
                                {
                                  "id": "Algorithm_197",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "In k-th order statistic selection, what does median-of-medians guarantee compared to random pivot?",
                                  "options": ["O(n) worst-case time", "O(log n) worst-case time", "O(1) expected time", "O(n log n) expected time"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Median-of-medians provides deterministic linear time in the worst case."
                                },
                                {
                                  "id": "Algorithm_198",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "Which approach is typically used to sample k items uniformly from a stream of unknown length?",
                                  "options": ["Reservoir sampling", "Quickselect", "Kahn's algorithm", "Radix sort"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Reservoir sampling maintains a uniform sample with O(1) memory per item."
                                },
                                {
                                  "id": "Algorithm_199",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "Why does reservoir sampling produce a uniform sample?",
                                  "options": [
                                    "Each item i replaces existing ones with probability proportional to 1/i",
                                    "It always keeps the first k items",
                                    "It sorts the stream online",
                                    "It uses a min-heap of size k"
                                  ],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Carefully chosen replacement probabilities ensure equal final selection chance."
                                },
                                {
                                  "id": "Algorithm_200",
                                  "category": "Algorithm",
                                  "baseDifficulty": "Hard",
                                  "targetLevel": "Hard",
                                  "questionText": "Which algorithm is commonly used to find a topological order and also detect cycles in a directed graph iteratively?",
                                  "options": ["Kahn's algorithm (in-degree queue)", "Prim's algorithm", "Quick sort", "Rabin-Karp"],
                                  "correctAnswerIndex": 0,
                                  "explanation": "Kahn’s algorithm processes zero in-degree nodes; leftover nodes imply a cycle."
                                },
                                  {
                                    "id": "DataStructure_001",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "What is the time complexity of accessing an element by index in an array?",
                                    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Arrays provide constant-time random access via index."
                                  },
                                  {
                                    "id": "DataStructure_002",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "Which data structure follows FIFO (First-In, First-Out)?",
                                    "options": ["Queue", "Stack", "Binary heap", "Hash table"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Queues remove elements in the same order they were added."
                                  },
                                  {
                                    "id": "DataStructure_003",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "Which data structure follows LIFO (Last-In, First-Out)?",
                                    "options": ["Stack", "Queue", "Deque", "Priority queue"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Stacks pop the most recently pushed element."
                                  },
                                  {
                                    "id": "DataStructure_004",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "In a singly linked list, what does each node typically store?",
                                    "options": ["Value and next pointer", "Value and parent pointer", "Only value", "Only index"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Singly linked list nodes point to the next node."
                                  },
                                  {
                                    "id": "DataStructure_005",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Normal",
                                    "questionText": "What is the main advantage of a linked list over an array for insertions at the head?",
                                    "options": ["O(1) insertion without shifting elements", "O(1) random access", "Better cache locality", "Always less memory usage"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Head insertion is constant time because only pointers change."
                                  },
                                  {
                                    "id": "DataStructure_006",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "Which structure is best for checking membership in average O(1) time?",
                                    "options": ["Hash table", "Array", "Linked list", "Binary tree (unbalanced)"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Hash tables provide average constant-time lookup."
                                  },
                                  {
                                    "id": "DataStructure_007",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "In a binary search tree (BST), what is true for the left subtree of a node?",
                                    "options": ["All keys are less than the node’s key", "All keys are greater than the node’s key", "Keys are random", "Keys are equal to the node’s key"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "BST invariant: left < node < right (for strict BST)."
                                  },
                                  {
                                    "id": "DataStructure_008",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "Which traversal of a BST yields keys in sorted order?",
                                    "options": ["In-order", "Pre-order", "Post-order", "Level-order"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "In-order visits left, node, right producing sorted sequence."
                                  },
                                  {
                                    "id": "DataStructure_009",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "What is the maximum number of children a binary tree node can have?",
                                    "options": ["2", "1", "3", "Unlimited"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Binary means at most two children: left and right."
                                  },
                                  {
                                    "id": "DataStructure_010",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "Which data structure is commonly used to implement BFS?",
                                    "options": ["Queue", "Stack", "Hash table", "Binary heap"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "BFS explores level-by-level using a queue."
                                  },
                                  {
                                    "id": "DataStructure_011",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "Which data structure is commonly used to implement DFS iteratively?",
                                    "options": ["Stack", "Queue", "Deque only", "Hash set"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "DFS uses a stack (explicitly or via recursion call stack)."
                                  },
                                  {
                                    "id": "DataStructure_012",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Normal",
                                    "questionText": "What is the average time complexity of inserting into a hash table (good hash, low load factor)?",
                                    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Hashing gives expected constant-time insertion with good distribution."
                                  },
                                  {
                                    "id": "DataStructure_013",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "What does a 'collision' mean in a hash table?",
                                    "options": ["Two keys map to the same bucket/index", "A key is not found", "The table is empty", "A key maps to two buckets"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Collisions happen when multiple keys produce the same hash index."
                                  },
                                  {
                                    "id": "DataStructure_014",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "Which data structure is best for retrieving the minimum element repeatedly?",
                                    "options": ["Min-heap", "Stack", "Queue", "Singly linked list"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "A min-heap supports efficient extract-min operations."
                                  },
                                  {
                                    "id": "DataStructure_015",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "What is the typical time complexity of push and pop in a stack?",
                                    "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Stack operations update the top pointer in constant time."
                                  },
                                  {
                                    "id": "DataStructure_016",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Easy",
                                    "questionText": "Which structure represents relationships using vertices and edges?",
                                    "options": ["Graph", "Heap", "Stack", "Hash table"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Graphs model entities (vertices) and connections (edges)."
                                  },
                                  {
                                    "id": "DataStructure_017",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Easy",
                                    "targetLevel": "Normal",
                                    "questionText": "In a doubly linked list, what extra pointer does each node have compared to singly?",
                                    "options": ["prev pointer", "parent pointer", "root pointer", "hash pointer"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Doubly linked nodes point to both next and previous nodes."
                                  },

                                  {
                                    "id": "DataStructure_018",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "What is the time complexity of searching for a value in an unsorted singly linked list?",
                                    "options": ["O(n)", "O(1)", "O(log n)", "O(n log n)"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "You may need to traverse all nodes to find the value."
                                  },
                                  {
                                    "id": "DataStructure_019",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "What is the main tradeoff of a linked list compared to an array for iteration speed?",
                                    "options": [
                                      "Poor cache locality due to pointer chasing",
                                      "Cannot support insertions",
                                      "Cannot store duplicates",
                                      "Always uses less memory"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Linked lists often iterate slower because nodes are scattered in memory."
                                  },
                                  {
                                    "id": "DataStructure_020",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Hard",
                                    "questionText": "What problem does a 'load factor' in hash tables help reason about?",
                                    "options": [
                                      "When to resize to keep average O(1) performance",
                                      "How to guarantee no collisions",
                                      "How to sort keys by hash value",
                                      "How to make hashing deterministic across processes"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Higher load factor increases collisions; resizing keeps operations fast."
                                  },
                                  {
                                    "id": "DataStructure_021",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "Which collision resolution stores multiple entries in the same bucket as a list?",
                                    "options": ["Separate chaining", "Open addressing", "Cuckoo hashing", "Perfect hashing"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Separate chaining uses a secondary structure (often a linked list) per bucket."
                                  },
                                  {
                                    "id": "DataStructure_022",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "In open addressing, what happens when a collision occurs?",
                                    "options": ["Probe for another slot", "Create a linked list", "Rehash entire table immediately", "Reject the insertion"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Open addressing finds an alternate slot via probing (linear/quadratic/double hash)."
                                  },
                                  {
                                    "id": "DataStructure_023",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "What is the worst-case time complexity for lookup in a hash table?",
                                    "options": ["O(n)", "O(1)", "O(log n)", "O(n log n)"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "In worst case (many collisions), it degenerates to scanning many entries."
                                  },
                                  {
                                    "id": "DataStructure_024",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "What is the typical time complexity of inserting into a balanced BST (e.g., AVL/Red-Black)?",
                                    "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Balanced BST height is O(log n), so insertion and rebalancing are logarithmic."
                                  },
                                  {
                                    "id": "DataStructure_025",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Hard",
                                    "questionText": "Why can an unbalanced BST degrade to O(n) operations?",
                                    "options": [
                                      "It can become a skewed chain, making height O(n)",
                                      "It forces collisions like hash tables",
                                      "It cannot store duplicates",
                                      "It always rebalances incorrectly"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "If nodes insert in sorted order, the tree can become a linked list."
                                  },
                                  {
                                    "id": "DataStructure_026",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "Which tree guarantees O(log n) height by enforcing color properties?",
                                    "options": ["Red-Black tree", "Trie", "Binary heap", "B-tree only"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Red-Black trees maintain near-balance using coloring constraints."
                                  },
                                  {
                                    "id": "DataStructure_027",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "What is a common use case for a trie?",
                                    "options": ["Prefix search (autocomplete)", "Sorting integers in-place", "Finding MST", "Detecting negative cycles"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Tries efficiently store strings for prefix queries."
                                  },
                                  {
                                    "id": "DataStructure_028",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "What does a binary heap guarantee about its structure?",
                                    "options": [
                                      "It is a complete binary tree",
                                      "It is a perfect binary tree",
                                      "It is always a BST",
                                      "All leaves are at the same depth"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Heaps maintain completeness (filled levels left to right)."
                                  },
                                  {
                                    "id": "DataStructure_029",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Hard",
                                    "questionText": "Why can a heap not support efficient arbitrary search like a BST?",
                                    "options": [
                                      "Heap only enforces partial order (parent vs children), not global ordering",
                                      "Heap nodes cannot store keys",
                                      "Heap is not a tree",
                                      "Heap has cycles"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Only the root min/max is guaranteed; other nodes have no total ordering."
                                  },
                                  {
                                    "id": "DataStructure_030",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "Which graph representation is typically more memory efficient for sparse graphs?",
                                    "options": ["Adjacency list", "Adjacency matrix", "Edge matrix", "Full distance matrix"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Adjacency lists store only existing edges, saving space on sparse graphs."
                                  },
                                  {
                                    "id": "DataStructure_031",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "What is the space complexity of an adjacency matrix for V vertices?",
                                    "options": ["O(V^2)", "O(V+E)", "O(E)", "O(V log V)"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Matrix stores V×V entries regardless of number of edges."
                                  },
                                  {
                                    "id": "DataStructure_032",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "In a graph, what does 'degree' mean for an undirected graph node?",
                                    "options": ["Number of incident edges", "Number of vertices", "Length of shortest path", "Number of components"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Degree counts how many edges touch the node."
                                  },
                                  {
                                    "id": "DataStructure_033",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Hard",
                                    "questionText": "What is the key reason to use a deque for sliding window problems?",
                                    "options": [
                                      "O(1) amortized push/pop at both ends while maintaining candidates",
                                      "Guaranteed O(1) random access",
                                      "Automatic sorting of elements",
                                      "It prevents duplicates by design"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Deque supports efficient front/back operations needed for monotonic queues."
                                  },
                                  {
                                    "id": "DataStructure_034",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Normal",
                                    "targetLevel": "Normal",
                                    "questionText": "What is the main advantage of using a hash set instead of an array for membership checks?",
                                    "options": ["Expected O(1) lookup", "Sorted iteration", "Lower memory always", "No collisions possible"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Hash sets provide average constant-time membership checks."
                                  },

                                  {
                                    "id": "DataStructure_035",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "In open addressing hash tables, why are tombstones used?",
                                    "options": [
                                      "To allow search to continue past deleted slots without breaking probe chains",
                                      "To avoid resizing the table forever",
                                      "To eliminate collisions completely",
                                      "To compress the table into O(1) space"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Tombstones preserve probe sequences so lookups still find items inserted later."
                                  },
                                  {
                                    "id": "DataStructure_036",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "What is the main drawback of linear probing in open addressing?",
                                    "options": ["Primary clustering", "It cannot delete keys", "It requires linked lists", "It guarantees O(log n) lookup"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Contiguous filled blocks form, increasing probe lengths (clustering)."
                                  },
                                  {
                                    "id": "DataStructure_037",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "Why does separate chaining remain correct even with many collisions?",
                                    "options": [
                                      "All colliding keys are stored in the bucket’s chain, so none are lost",
                                      "The hash function becomes perfect automatically",
                                      "Buckets are resized per key",
                                      "Chains guarantee sorted order by hash"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Collisions are handled by storing multiple entries per bucket."
                                  },
                                  {
                                    "id": "DataStructure_038",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "What is the main benefit of using a B-tree over a BST for disk-based storage?",
                                    "options": [
                                      "Fewer disk seeks due to high branching factor",
                                      "Guaranteed O(1) lookup",
                                      "No rebalancing needed ever",
                                      "Keys are stored only in leaves always"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "B-trees are optimized for block storage by reducing I/O operations."
                                  },
                                  {
                                    "id": "DataStructure_039",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "In a trie, what typically determines memory usage growth?",
                                    "options": [
                                      "Alphabet size and number of nodes created for prefixes",
                                      "Only the number of stored words",
                                      "Only the longest word length",
                                      "Only the number of duplicates"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Tries can be memory-heavy due to branching per character and many nodes."
                                  },
                                  {
                                    "id": "DataStructure_040",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "What problem does 'union by rank/size' address in Union-Find?",
                                    "options": [
                                      "Prevent tall trees by attaching smaller tree under larger one",
                                      "Detect negative cycles",
                                      "Reduce hash collisions",
                                      "Make BFS iterative"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Union by rank keeps the forest shallow, improving find performance."
                                  },
                                  {
                                    "id": "DataStructure_041",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "Why is an adjacency list often preferred for running BFS/DFS on sparse graphs?",
                                    "options": [
                                      "Iterating neighbors is O(deg(v)) rather than scanning all V possible edges",
                                      "It guarantees sorted traversal order",
                                      "It uses O(V^2) space to speed lookups",
                                      "It prevents cycles"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Adjacency lists iterate only actual edges, avoiding wasted scans."
                                  },
                                  {
                                    "id": "DataStructure_042",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "What is the key invariant of a monotonic stack used for 'next greater element'?",
                                    "options": [
                                      "Elements are stored in decreasing order (by value) from bottom to top",
                                      "Elements are stored in random order",
                                      "Elements are stored sorted ascending by index only",
                                      "Elements are stored by hash value"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "A monotonic stack keeps a monotone sequence to answer next greater efficiently."
                                  },
                                  {
                                    "id": "DataStructure_043",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "Why is a graph with an adjacency matrix inefficient for sparse graphs?",
                                    "options": [
                                      "It uses O(V^2) space regardless of E",
                                      "It cannot represent directed edges",
                                      "It makes BFS impossible",
                                      "It forces negative weights"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Sparse graphs have few edges, but the matrix stores all possible pairs."
                                  },
                                  {
                                    "id": "DataStructure_044",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "What does 'heapify' do when building a heap from an array?",
                                    "options": [
                                      "Rearranges elements to satisfy heap property in O(n)",
                                      "Sorts the array fully in O(n log n)",
                                      "Balances a BST in O(n)",
                                      "Creates a hash table from the array"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Heapify builds a valid heap structure from an unsorted array efficiently."
                                  },
                                  {
                                    "id": "DataStructure_045",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "In a binary heap stored as an array, what are the child indices for i (0-based)?",
                                    "options": ["2i+1 and 2i+2", "i-1 and i+1", "2i and 2i+1", "i/2 and i/3"],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Array-heap mapping (0-based): left=2i+1, right=2i+2."
                                  },
                                  {
                                    "id": "DataStructure_046",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "What is the primary purpose of a 'sentinel node' in linked lists?",
                                    "options": [
                                      "Simplify edge cases for insertion/deletion at head/tail",
                                      "Guarantee O(1) random access",
                                      "Eliminate memory allocation",
                                      "Make the list circular automatically"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "A dummy/sentinel node reduces special-case branching in operations."
                                  },
                                  {
                                    "id": "DataStructure_047",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "Why can recursion-based DFS overflow the stack on large graphs?",
                                    "options": [
                                      "Deep recursion depth can exceed call stack limits",
                                      "DFS requires negative weights",
                                      "Recursion prevents visiting nodes",
                                      "DFS uses a queue internally"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Very deep paths cause many nested calls, risking stack overflow."
                                  },
                                  {
                                    "id": "DataStructure_048",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "What does a 'hash function' aim to achieve for good hash table performance?",
                                    "options": [
                                      "Uniform distribution of keys across buckets",
                                      "Sorted keys across buckets",
                                      "No memory allocation",
                                      "Guaranteed collision-free mapping"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Uniform distribution minimizes collisions and keeps operations fast on average."
                                  },
                                  {
                                    "id": "DataStructure_049",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "What is a key advantage of using a deque instead of a queue for some algorithms?",
                                    "options": [
                                      "O(1) amortized insertion/removal at both ends",
                                      "Guaranteed O(1) membership checks",
                                      "Automatic sorting by value",
                                      "No need for pointers or indices"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "A deque supports push/pop at both front and back efficiently."
                                  },
                                  {
                                    "id": "DataStructure_050",
                                    "category": "Data Structure",
                                    "baseDifficulty": "Hard",
                                    "targetLevel": "Hard",
                                    "questionText": "In a BST, why can deleting a node with two children be complex?",
                                    "options": [
                                      "You must replace it with inorder successor/predecessor to preserve ordering",
                                      "BST deletion is always O(1)",
                                      "You must rebuild the entire tree",
                                      "Two-child nodes cannot be deleted"
                                    ],
                                    "correctAnswerIndex": 0,
                                    "explanation": "Replacing with successor/predecessor keeps the BST invariant intact."
                                  },
                                    {
                                      "id": "DataStructure_051",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "Which operation removes the front element of a queue?",
                                      "options": ["Dequeue", "Enqueue", "Pop", "Peek"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Dequeue removes the oldest (front) element in a FIFO queue."
                                    },
                                    {
                                      "id": "DataStructure_052",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "What is the time complexity of peeking the top of a stack?",
                                      "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Peek reads the top element without reordering the stack."
                                    },
                                    {
                                      "id": "DataStructure_053",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "In a tree, what is a leaf node?",
                                      "options": ["A node with no children", "A node with two children", "The root node", "A node with a parent only in graphs"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Leaf nodes are terminal nodes with zero children."
                                    },
                                    {
                                      "id": "DataStructure_054",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "In an undirected graph, how are edges represented between two vertices?",
                                      "options": ["As a bidirectional connection", "As a one-way connection only", "As a parent-child relationship", "As a hash bucket link"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Undirected edges imply connectivity in both directions."
                                    },
                                    {
                                      "id": "DataStructure_055",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Normal",
                                      "questionText": "What is a common implementation of a stack?",
                                      "options": ["Dynamic array", "Adjacency matrix", "Binary search tree only", "Disjoint set union only"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Stacks are commonly implemented with arrays (or linked lists) supporting O(1) push/pop."
                                    },
                                    {
                                      "id": "DataStructure_056",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "What does 'enqueue' do in a queue?",
                                      "options": ["Adds an element to the back", "Removes an element from the back", "Removes an element from the front", "Returns the minimum element"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Enqueue inserts at the tail/back of the queue."
                                    },
                                    {
                                      "id": "DataStructure_057",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "Which graph traversal is typically implemented with a stack (or recursion)?",
                                      "options": ["DFS", "BFS", "Dijkstra", "Prim"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "DFS explores depth-first using a stack (explicit or call stack)."
                                    },
                                    {
                                      "id": "DataStructure_058",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "What is the height of a tree with only one node (the root)?",
                                      "options": ["0", "1", "2", "Depends on degree"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "By common definition, a single-node tree has height 0 edges."
                                    },
                                    {
                                      "id": "DataStructure_059",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "Which data structure stores key-value pairs?",
                                      "options": ["Hash map", "Stack", "Queue", "Binary heap"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Hash maps (hash tables) map keys to values."
                                    },
                                    {
                                      "id": "DataStructure_060",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "In a directed graph, what does an edge (u → v) mean?",
                                      "options": ["A one-way connection from u to v", "A two-way connection", "u is always the parent of v in a tree", "u and v must be adjacent in memory"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Directed edges have an orientation: from source to destination."
                                    },
                                    {
                                      "id": "DataStructure_061",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "What is the time complexity of checking the size of a typical stack implementation?",
                                      "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Most stacks track size as an integer counter."
                                    },
                                    {
                                      "id": "DataStructure_062",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "Which structure is best suited for 'undo' functionality?",
                                      "options": ["Stack", "Queue", "Min-heap", "Adjacency list"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Undo reverts the most recent action (LIFO)."
                                    },
                                    {
                                      "id": "DataStructure_063",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Normal",
                                      "questionText": "What is the main reason arrays are fast for iteration?",
                                      "options": ["Contiguous memory improves cache locality", "They avoid comparisons", "They have no indices", "They are always smaller than lists"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Contiguous layouts leverage CPU caches better than pointer-chasing structures."
                                    },
                                    {
                                      "id": "DataStructure_064",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "What is a 'root' in a tree?",
                                      "options": ["The topmost node with no parent", "Any leaf node", "A node with exactly two children", "A node with the highest degree in a graph"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "The root is the unique node without a parent."
                                    },
                                    {
                                      "id": "DataStructure_065",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "Which data structure is used to represent a set of unique values (typical hash-based)?",
                                      "options": ["Hash set", "Array", "Stack", "Binary heap"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "A hash set stores unique keys with fast average lookup."
                                    },
                                    {
                                      "id": "DataStructure_066",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "What does 'pop' do on a stack?",
                                      "options": ["Removes and returns the top element", "Adds an element to the top", "Removes and returns the bottom element", "Returns the minimum element"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Pop removes the most recently pushed element."
                                    },
                                    {
                                      "id": "DataStructure_067",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Easy",
                                      "targetLevel": "Easy",
                                      "questionText": "What is the typical time complexity of appending to a dynamic array (amortized)?",
                                      "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Resizes are occasional; average cost per append is constant."
                                    },

                                    {
                                      "id": "DataStructure_068",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "What is the time complexity of inserting at the front of an array (dynamic array)?",
                                      "options": ["O(n)", "O(1)", "O(log n)", "O(n log n)"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "All elements must shift right by one position."
                                    },
                                    {
                                      "id": "DataStructure_069",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "What is the time complexity of deleting a node from a singly linked list when you already have a pointer to its previous node?",
                                      "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "You relink prev.next to skip the removed node."
                                    },
                                    {
                                      "id": "DataStructure_070",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Hard",
                                      "questionText": "Why can't you delete a node in O(1) from a singly linked list if you only have a pointer to that node (and not the previous)?",
                                      "options": [
                                        "You can't update the previous node’s next pointer without finding it",
                                        "Because linked lists require sorting before deletion",
                                        "Because nodes are immutable by design",
                                        "Because deletion requires rebuilding the entire list"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Singly lists point forward only; finding previous requires traversal."
                                    },
                                    {
                                      "id": "DataStructure_071",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "Which data structure supports O(1) average insert, delete, and membership check?",
                                      "options": ["Hash set", "Sorted array", "Balanced BST", "Min-heap"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Hash sets have expected O(1) operations under good hashing."
                                    },
                                    {
                                      "id": "DataStructure_072",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "In a BST, what is the time complexity of search when the tree is balanced?",
                                      "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Balanced BST height is logarithmic."
                                    },
                                    {
                                      "id": "DataStructure_073",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "What is the primary use of a 'disjoint set union' (Union-Find)?",
                                      "options": ["Track connectivity / components", "Maintain sorted order", "Find shortest paths", "Compute prefix sums"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Union-Find efficiently merges sets and checks if elements are connected."
                                    },
                                    {
                                      "id": "DataStructure_074",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "What is the time complexity of checking if an edge (u,v) exists in an adjacency matrix?",
                                      "options": ["O(1)", "O(log V)", "O(V)", "O(E)"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Matrix lookup at [u][v] is constant time."
                                    },
                                    {
                                      "id": "DataStructure_075",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "Which representation makes iterating all neighbors of a vertex v efficient?",
                                      "options": ["Adjacency list", "Adjacency matrix", "Edge incidence matrix", "Hash table of vertices only"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Adjacency lists store only v’s actual neighbors."
                                    },
                                    {
                                      "id": "DataStructure_076",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "What is the typical time complexity of inserting into a min-heap?",
                                      "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Insertion may bubble up along the heap height."
                                    },
                                    {
                                      "id": "DataStructure_077",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Hard",
                                      "questionText": "In a hash map with separate chaining, what happens as the load factor increases?",
                                      "options": [
                                        "Average chain length grows, slowing operations",
                                        "Collisions disappear due to rehashing automatically",
                                        "Lookup becomes O(log n) guaranteed",
                                        "Memory usage strictly decreases"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "More keys per bucket increases traversal work per operation."
                                    },
                                    {
                                      "id": "DataStructure_078",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "What is a 'complete binary tree' property used by heaps?",
                                      "options": [
                                        "All levels filled except possibly last, filled left to right",
                                        "Every node has exactly two children",
                                        "All leaves at same depth",
                                        "In-order traversal yields sorted order"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Completeness enables compact array storage for heaps."
                                    },
                                    {
                                      "id": "DataStructure_079",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "Which operation is NOT typically efficient in a singly linked list?",
                                      "options": ["Random access by index", "Insert at head", "Delete after a node", "Traverse sequentially"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Linked lists do not support O(1) indexing; traversal is required."
                                    },
                                    {
                                      "id": "DataStructure_080",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "What is the typical time complexity of checking if a value exists in a sorted array using binary search?",
                                      "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Binary search halves the search space each step."
                                    },
                                    {
                                      "id": "DataStructure_081",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "Which data structure is best suited for implementing a LRU cache (classic approach)?",
                                      "options": ["Hash map + doubly linked list", "Stack + queue", "Min-heap + array", "Trie + adjacency list"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Hash map gives O(1) access; doubly list supports O(1) move-to-front and eviction."
                                    },
                                    {
                                      "id": "DataStructure_082",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Hard",
                                      "questionText": "Why is a doubly linked list preferred over singly linked list for LRU caches?",
                                      "options": [
                                        "It supports O(1) removal of an arbitrary node when you have its pointer",
                                        "It provides O(1) random access by index",
                                        "It eliminates the need for hashing",
                                        "It guarantees no duplicates automatically"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "LRU needs fast removal/move of any node; prev pointers enable O(1) unlink."
                                    },
                                    {
                                      "id": "DataStructure_083",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "In a trie, what does each edge typically represent?",
                                      "options": ["A character transition", "A heap priority", "A graph weight", "A hash collision"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Trie edges correspond to characters (or tokens) forming prefixes."
                                    },
                                    {
                                      "id": "DataStructure_084",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Normal",
                                      "targetLevel": "Normal",
                                      "questionText": "What is the time complexity of looking up a word of length L in a trie?",
                                      "options": ["O(L)", "O(log n)", "O(n)", "O(n log n)"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Lookup follows one edge per character."
                                    },

                                    {
                                      "id": "DataStructure_085",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "In open addressing hash tables, why does deletion require special handling (e.g., tombstones)?",
                                      "options": [
                                        "Removing a slot can break probe chains and cause false negatives",
                                        "Open addressing cannot ever delete keys",
                                        "Deletion forces O(n log n) rebalancing",
                                        "Deletion requires sorting remaining keys"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Probe sequences must remain intact so lookups can continue past deleted slots."
                                    },
                                    {
                                      "id": "DataStructure_086",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "Which hashing technique reduces primary clustering compared to linear probing?",
                                      "options": ["Quadratic probing", "Linear probing", "Separate chaining only", "Array indexing"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Quadratic probing spreads probes out, reducing contiguous clusters."
                                    },
                                    {
                                      "id": "DataStructure_087",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "What is the main advantage of double hashing in open addressing?",
                                      "options": [
                                        "It reduces clustering by using a second hash for step size",
                                        "It guarantees collision-free insertion",
                                        "It makes lookups O(1) worst-case",
                                        "It removes the need for resizing"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "A second hash creates better probe distributions than a fixed step."
                                    },
                                    {
                                      "id": "DataStructure_088",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "Why do balanced BSTs (AVL/Red-Black) perform rotations?",
                                      "options": [
                                        "To restore height balance and keep operations O(log n)",
                                        "To convert the tree into a heap",
                                        "To eliminate duplicates automatically",
                                        "To make in-order traversal O(1)"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Rotations restructure locally to maintain balance guarantees."
                                    },
                                    {
                                      "id": "DataStructure_089",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "What is the key benefit of using an adjacency matrix for dense graphs?",
                                      "options": [
                                        "O(1) edge existence checks",
                                        "O(1) neighbor iteration",
                                        "O(V+E) space usage",
                                        "Automatic shortest path computation"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Matrices allow constant-time checks of whether (u,v) is an edge."
                                    },
                                    {
                                      "id": "DataStructure_090",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "In a binary heap array (0-based), what is the parent index of i (i > 0)?",
                                      "options": ["(i - 1) / 2", "2i + 1", "2i + 2", "i + 1"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Parent mapping for 0-based heap is floor((i-1)/2)."
                                    },
                                    {
                                      "id": "DataStructure_091",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "Which structure is most suitable for implementing 'min stack' with O(1) min query?",
                                      "options": ["Stack with auxiliary min stack", "Queue with sorting", "BST without balance", "Hash set"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Track current minimums alongside values to answer min in O(1)."
                                    },
                                    {
                                      "id": "DataStructure_092",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "Why is a graph's 'visited' set necessary in BFS/DFS on general graphs?",
                                      "options": [
                                        "To prevent revisiting nodes and infinite traversal in cycles",
                                        "To sort nodes by value",
                                        "To ensure edge weights are non-negative",
                                        "To convert the graph into a tree"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Cycles can cause repeated visits without visited tracking."
                                    },
                                    {
                                      "id": "DataStructure_093",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "What is the main limitation of using recursion for DFS in production systems?",
                                      "options": [
                                        "Potential stack overflow on deep/large graphs",
                                        "It cannot mark visited nodes",
                                        "It cannot traverse directed graphs",
                                        "It forces O(V^2) memory"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Deep recursion can exceed call stack limits; iterative DFS avoids this."
                                    },
                                    {
                                      "id": "DataStructure_094",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "Which data structure supports ordered iteration with O(log n) insert/delete/search?",
                                      "options": ["Balanced BST (e.g., TreeMap)", "Hash map", "Stack", "Queue"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Balanced BSTs maintain sorted order and logarithmic operations."
                                    },
                                    {
                                      "id": "DataStructure_095",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "Why can a hash map be faster than a balanced BST for lookups in practice?",
                                      "options": [
                                        "Expected O(1) lookups vs O(log n), with fewer comparisons",
                                        "Hash maps are always collision-free",
                                        "BSTs cannot store strings",
                                        "Hash maps guarantee sorted iteration"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Hashing avoids logarithmic tree traversal on average (assuming good hashing)."
                                    },
                                    {
                                      "id": "DataStructure_096",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "What is the key drawback of hash maps compared to balanced BSTs?",
                                      "options": [
                                        "No inherent ordering for range queries",
                                        "Cannot delete keys efficiently",
                                        "Cannot handle collisions",
                                        "Require O(V^2) memory"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Hash maps don't preserve order; range queries need ordered structures."
                                    },
                                    {
                                      "id": "DataStructure_097",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "In a trie, why can deleting a word be tricky?",
                                      "options": [
                                        "You must remove nodes only if they are not shared by other words",
                                        "You must rehash all nodes",
                                        "You must rotate nodes like AVL trees",
                                        "You must rebuild the entire trie"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Prefix nodes can be shared; deleting must preserve other words’ paths."
                                    },
                                    {
                                      "id": "DataStructure_098",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "Which structure is best for representing weighted graphs for algorithms like Dijkstra?",
                                      "options": ["Adjacency list with (neighbor, weight) pairs", "Adjacency matrix only", "Stack of edges", "Hash set of vertices only"],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Neighbor+weight pairs allow efficient neighbor iteration with weights."
                                    },
                                    {
                                      "id": "DataStructure_099",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "Why are B-trees widely used in database indexes?",
                                      "options": [
                                        "They minimize disk I/O by storing many keys per node",
                                        "They guarantee O(1) search",
                                        "They eliminate the need for caching",
                                        "They only work for integer keys"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "High branching reduces tree height, cutting expensive page reads."
                                    },
                                    {
                                      "id": "DataStructure_100",
                                      "category": "Data Structure",
                                      "baseDifficulty": "Hard",
                                      "targetLevel": "Hard",
                                      "questionText": "What is the key performance characteristic of a deque (double-ended queue)?",
                                      "options": [
                                        "Efficient insertion and removal at both ends",
                                        "Guaranteed O(1) random access",
                                        "Automatic sorting by key",
                                        "No memory overhead vs arrays"
                                      ],
                                      "correctAnswerIndex": 0,
                                      "explanation": "Deques support push/pop front and back efficiently."
                                    },
                                      {
                                        "id": "DataStructure_101",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "What does 'peek' typically do in a queue?",
                                        "options": ["Returns the front element without removing it", "Removes the front element", "Adds an element to the back", "Returns the last element and removes it"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Peek reads the next element to be dequeued without modifying the queue."
                                      },
                                      {
                                        "id": "DataStructure_102",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "Which data structure is typically used to represent hierarchical data?",
                                        "options": ["Tree", "Stack", "Queue", "Hash set"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Trees naturally model parent-child hierarchies."
                                      },
                                      {
                                        "id": "DataStructure_103",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Normal",
                                        "questionText": "In an array, what is the typical time complexity to update a value at a known index?",
                                        "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "You can directly write to that index in constant time."
                                      },
                                      {
                                        "id": "DataStructure_104",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "What is a common advantage of using a circular queue?",
                                        "options": ["Efficient use of fixed-size buffer space", "O(1) random access", "Automatic sorting", "No need to track head/tail"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Circular queues reuse freed slots in a fixed-size array buffer."
                                      },
                                      {
                                        "id": "DataStructure_105",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "Which structure is best for processing items in the exact order received?",
                                        "options": ["Queue", "Stack", "Binary heap", "Hash table"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Queues preserve insertion order (FIFO)."
                                      },
                                      {
                                        "id": "DataStructure_106",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "In a binary tree, what is a common term for nodes at the same depth?",
                                        "options": ["Level", "Chain", "Bucket", "Cluster"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Nodes at the same depth are on the same level."
                                      },
                                      {
                                        "id": "DataStructure_107",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Normal",
                                        "questionText": "Which data structure is commonly used to model function call frames?",
                                        "options": ["Stack", "Queue", "Heap", "Trie"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "The call stack stores frames in LIFO order."
                                      },
                                      {
                                        "id": "DataStructure_108",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "What is the key requirement for keys in a hash set?",
                                        "options": ["They must be hashable and comparable for equality", "They must be sorted", "They must be unique across all programs", "They must be numeric"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Hash sets rely on hash value + equality to locate and compare keys."
                                      },
                                      {
                                        "id": "DataStructure_109",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "What does 'isEmpty' typically check in a collection data structure?",
                                        "options": ["Whether it contains zero elements", "Whether it is sorted", "Whether it has duplicates", "Whether it is balanced"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "isEmpty is true when the size/count is 0."
                                      },
                                      {
                                        "id": "DataStructure_110",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "What is the typical time complexity of checking if a value exists in a hash set (average case)?",
                                        "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Good hashing gives expected constant-time membership checks."
                                      },
                                      {
                                        "id": "DataStructure_111",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "What is the term for a tree where each node has at most two children?",
                                        "options": ["Binary tree", "Trie", "B-tree", "DAG"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Binary trees restrict nodes to at most two children."
                                      },
                                      {
                                        "id": "DataStructure_112",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Normal",
                                        "questionText": "What is the typical time complexity of removing the last element from a dynamic array (e.g., ArrayList) without shrinking?",
                                        "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Removing the end element avoids shifting."
                                      },
                                      {
                                        "id": "DataStructure_113",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "Which data structure is best for tracking unique visited nodes in graph traversal?",
                                        "options": ["Hash set", "Stack", "Queue", "Binary heap"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "A hash set supports fast membership checks to avoid revisits."
                                      },
                                      {
                                        "id": "DataStructure_114",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "In a linked list, what does 'head' usually point to?",
                                        "options": ["The first node", "The last node", "The middle node", "The largest node"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Head is the entry point to the list (first node)."
                                      },
                                      {
                                        "id": "DataStructure_115",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Normal",
                                        "questionText": "What is a common benefit of using a doubly linked list over singly for certain operations?",
                                        "options": ["O(1) backward traversal and removal with node pointer", "O(1) random access", "Always uses less memory", "Guaranteed sorted order"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Prev pointers enable constant-time unlink when you have the node."
                                      },
                                      {
                                        "id": "DataStructure_116",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Easy",
                                        "targetLevel": "Easy",
                                        "questionText": "What is the primary purpose of a hash table?",
                                        "options": ["Fast key-based lookup", "Maintain sorted order", "Store items in FIFO order", "Store items in LIFO order"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Hash tables map keys to buckets for fast retrieval."
                                      },

                                      {
                                        "id": "DataStructure_117",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "What is the time complexity of inserting into an array at an arbitrary index (not end)?",
                                        "options": ["O(n)", "O(1)", "O(log n)", "O(n log n)"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Elements must shift to make space at that index."
                                      },
                                      {
                                        "id": "DataStructure_118",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Hard",
                                        "questionText": "In a linked list, why is finding the middle node commonly done with slow/fast pointers?",
                                        "options": [
                                          "It finds the midpoint in one pass with O(1) extra space",
                                          "It sorts the list while scanning",
                                          "It guarantees O(log n) time",
                                          "It avoids null checks"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Fast moves 2x; when fast ends, slow is at the middle."
                                      },
                                      {
                                        "id": "DataStructure_119",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "What is the time complexity of checking if a key exists in a balanced BST?",
                                        "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Balanced BST height is O(log n), so search follows that path."
                                      },
                                      {
                                        "id": "DataStructure_120",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "Which data structure supports efficient range queries (e.g., find all keys between a and b)?",
                                        "options": ["Balanced BST", "Hash table", "Stack", "Queue"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Ordered trees allow range scans; hash tables do not preserve order."
                                      },
                                      {
                                        "id": "DataStructure_121",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "What is the typical time complexity of extracting min from a min-heap?",
                                        "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "After removing root, sift-down restores heap property in log n."
                                      },
                                      {
                                        "id": "DataStructure_122",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Hard",
                                        "questionText": "Why do hash maps typically require resizing (rehashing)?",
                                        "options": [
                                          "To keep load factor bounded and maintain average O(1) operations",
                                          "To eliminate the need for equality checks",
                                          "To ensure keys remain sorted",
                                          "To reduce CPU cache usage"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "As entries grow, collisions increase unless capacity grows too."
                                      },
                                      {
                                        "id": "DataStructure_123",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "In a graph, what is the difference between in-degree and out-degree (directed graph)?",
                                        "options": [
                                          "In-degree counts incoming edges; out-degree counts outgoing edges",
                                          "In-degree counts vertices; out-degree counts edges",
                                          "In-degree counts undirected edges only",
                                          "They are always equal for all nodes"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Direction matters: incoming vs outgoing edge counts."
                                      },
                                      {
                                        "id": "DataStructure_124",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "What is the space complexity of an adjacency list representation?",
                                        "options": ["O(V + E)", "O(V^2)", "O(E^2)", "O(log V)"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "You store a list per vertex plus one entry per edge."
                                      },
                                      {
                                        "id": "DataStructure_125",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "Which structure is best to implement a priority queue?",
                                        "options": ["Binary heap", "Singly linked list", "Array without sorting", "Stack"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Binary heaps support efficient insert and extract-min/max."
                                      },
                                      {
                                        "id": "DataStructure_126",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Hard",
                                        "questionText": "Why is it hard to do 'delete arbitrary element' in O(log n) in a heap without extra indexing?",
                                        "options": [
                                          "You first need to find the element, which is O(n) in a heap",
                                          "Heaps cannot delete elements at all",
                                          "Heaps require stable ordering across all nodes",
                                          "Deleting breaks completeness and cannot be repaired"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Heaps don't support fast search by value; finding the node is the bottleneck."
                                      },
                                      {
                                        "id": "DataStructure_127",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "In a queue implemented by an array, what problem does a circular buffer solve?",
                                        "options": [
                                          "Avoids shifting elements by wrapping head/tail indices",
                                          "Guarantees sorted output",
                                          "Eliminates collisions",
                                          "Ensures O(1) random access to the middle"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Wrapping indices reuses freed slots without moving elements."
                                      },
                                      {
                                        "id": "DataStructure_128",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "Which data structure is ideal for representing a sparse set of integer keys with fast prefix queries?",
                                        "options": ["Trie (bitwise/prefix tree)", "Stack", "Queue", "Binary heap"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Prefix trees support prefix-based queries efficiently."
                                      },
                                      {
                                        "id": "DataStructure_129",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "What is the typical time complexity of inserting into a hash map with separate chaining (average case)?",
                                        "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Expected constant time with good hashing and bounded load factor."
                                      },
                                      {
                                        "id": "DataStructure_130",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Hard",
                                        "questionText": "Why does open addressing performance degrade sharply as load factor approaches 1?",
                                        "options": [
                                          "Probe sequences get long because few empty slots remain",
                                          "Buckets become linked lists",
                                          "The table becomes collision-free",
                                          "Hashing becomes deterministic"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "With fewer empty slots, finding an available/target slot requires many probes."
                                      },
                                      {
                                        "id": "DataStructure_131",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "What is a common technique to detect cycles in a linked list?",
                                        "options": ["Floyd’s tortoise and hare", "Binary search", "Heapify", "Topological sort"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Two pointers at different speeds meet if a cycle exists."
                                      },
                                      {
                                        "id": "DataStructure_132",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Normal",
                                        "questionText": "What is the typical time complexity of Floyd’s cycle detection?",
                                        "options": ["O(n)", "O(log n)", "O(1)", "O(n log n)"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Pointers traverse at most linear distance before meeting or terminating."
                                      },
                                      {
                                        "id": "DataStructure_133",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Normal",
                                        "targetLevel": "Hard",
                                        "questionText": "In a graph adjacency list, what is the time to iterate all neighbors of a vertex v?",
                                        "options": ["O(deg(v))", "O(V)", "O(E)", "O(1)"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "You traverse exactly the neighbor list of v."
                                      },

                                      {
                                        "id": "DataStructure_134",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "In a Red-Black tree, what invariant ensures the tree height stays O(log n)?",
                                        "options": [
                                          "No path from root to leaf has more than twice as many black nodes as any other",
                                          "All nodes have exactly two children",
                                          "In-order traversal visits nodes by insertion order",
                                          "All red nodes have red children"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Black-height constraints bound the longest path length."
                                      },
                                      {
                                        "id": "DataStructure_135",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "Why is a BST not ideal for indexing on disk compared to a B-tree?",
                                        "options": [
                                          "BSTs have small fan-out, causing more disk page reads due to greater height",
                                          "BSTs cannot store duplicate keys",
                                          "BSTs cannot be balanced",
                                          "BSTs require hashing"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "B-trees pack many keys per node, reducing I/O by lowering height."
                                      },
                                      {
                                        "id": "DataStructure_136",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "What is the key advantage of a hash map + array list combination in an 'insert/delete/getRandom O(1)' set design?",
                                        "options": [
                                          "Array provides O(1) random access; hash map stores index for O(1) deletes via swap",
                                          "Array provides sorted iteration; hash map ensures stability",
                                          "Hash map eliminates the need for resizing",
                                          "Array prevents collisions"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Swap-delete keeps array compact while map tracks indices."
                                      },
                                      {
                                        "id": "DataStructure_137",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "In a min-heap, why is 'decrease-key' important for Dijkstra?",
                                        "options": [
                                          "It efficiently updates a node’s priority when a shorter path is found",
                                          "It ensures the heap is always a BST",
                                          "It prevents negative edges",
                                          "It eliminates the need for visited sets"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Relaxation lowers distance; decrease-key updates heap order efficiently."
                                      },
                                      {
                                        "id": "DataStructure_138",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "Why do many Dijkstra implementations use 'push new distance' instead of true decrease-key?",
                                        "options": [
                                          "Binary heaps often lack efficient decrease-key without handles, so duplicates are filtered by a visited/dist check",
                                          "Decrease-key is incorrect for non-negative edges",
                                          "It guarantees fewer heap elements",
                                          "It makes complexity O(1)"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Without node handles, decrease-key is inconvenient; pushing duplicates is simpler and still correct."
                                      },
                                      {
                                        "id": "DataStructure_139",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "What is the main reason a Bloom filter can have false positives?",
                                        "options": [
                                          "Multiple items set overlapping bits, making an absent item appear present",
                                          "It stores actual keys and compares them",
                                          "It uses perfect hashing",
                                          "It always underflows on large inputs"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Bit collisions across hash functions can make membership appear true when it’s not."
                                      },
                                      {
                                        "id": "DataStructure_140",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "Which statement about Bloom filters is correct?",
                                        "options": [
                                          "They can have false positives but not false negatives (if implemented correctly)",
                                          "They can have false negatives but not false positives",
                                          "They store full keys to avoid collisions",
                                          "They support deletion without extra structures by default"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "A set bit pattern can only over-approximate membership, causing false positives."
                                      },
                                      {
                                        "id": "DataStructure_141",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "In a graph, what does it mean for a node to be 'reachable' from a source?",
                                        "options": [
                                          "There exists a path from the source to that node",
                                          "There is a direct edge from the source",
                                          "They share the same degree",
                                          "They are in the same adjacency matrix row index"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Reachable means some path (possibly multi-edge) exists from the source."
                                      },
                                      {
                                        "id": "DataStructure_142",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "Why is a deque often implemented as a circular buffer (array) in systems code?",
                                        "options": [
                                          "It provides O(1) amortized operations at both ends with good cache locality",
                                          "It guarantees sorted order",
                                          "It avoids using indices",
                                          "It eliminates the need for memory allocation"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Circular buffers support both-end ops and remain cache-friendly."
                                      },
                                      {
                                        "id": "DataStructure_143",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "What is the main memory advantage of an adjacency list over matrix for sparse graphs?",
                                        "options": [
                                          "Stores only existing edges, using O(V+E) space",
                                          "Stores all possible edges, using O(V^2) space",
                                          "Eliminates visited sets",
                                          "Guarantees O(1) neighbor iteration"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Sparse graphs have E << V^2, so lists save significant space."
                                      },
                                      {
                                        "id": "DataStructure_144",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "What is the key reason 'array-based stack' is often preferred over linked-list stack?",
                                        "options": [
                                          "Better cache locality and less per-node allocation overhead",
                                          "It guarantees no overflow ever",
                                          "It supports O(1) arbitrary deletes",
                                          "It automatically becomes thread-safe"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Arrays avoid pointer chasing and per-node allocations."
                                      },
                                      {
                                        "id": "DataStructure_145",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "In a linked list, what does 'pointer chasing' primarily affect?",
                                        "options": ["CPU cache performance", "Hash collision probability", "Graph connectivity", "Heap property correctness"],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Non-contiguous nodes cause more cache misses, slowing traversal."
                                      },
                                      {
                                        "id": "DataStructure_146",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "What is the key benefit of a skip list compared to a linked list?",
                                        "options": [
                                          "Expected O(log n) search via layered forward pointers",
                                          "Guaranteed O(1) random access",
                                          "No extra memory overhead",
                                          "Always beats balanced BSTs in worst case"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Skip lists add probabilistic levels to speed up search to logarithmic expected time."
                                      },
                                      {
                                        "id": "DataStructure_147",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "Why can a skip list be attractive in concurrent systems?",
                                        "options": [
                                          "It can be simpler to implement with fine-grained locking than balanced trees",
                                          "It is always lock-free by definition",
                                          "It eliminates the need for memory barriers",
                                          "It guarantees O(1) search"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Skip lists often allow simpler concurrent updates than strict rotation-based trees."
                                      },
                                      {
                                        "id": "DataStructure_148",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "In a hash table, what property must be consistent for keys used in buckets?",
                                        "options": [
                                          "If two keys are equal, they must have the same hash value",
                                          "If two keys have the same hash value, they must be equal",
                                          "Hash must be unique per key across runs",
                                          "Hash value must be strictly increasing"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Hashing requires equality implies same hash; the reverse is not required due to collisions."
                                      },
                                      {
                                        "id": "DataStructure_149",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "What is the main reason adjacency matrices can speed up some algorithms on dense graphs?",
                                        "options": [
                                          "Constant-time edge checks and contiguous memory access patterns",
                                          "They use less space than lists",
                                          "They remove the need for weights",
                                          "They guarantee no cycles"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Dense graphs benefit from O(1) checks and cache-friendly scans."
                                      },
                                      {
                                        "id": "DataStructure_150",
                                        "category": "Data Structure",
                                        "baseDifficulty": "Hard",
                                        "targetLevel": "Hard",
                                        "questionText": "Why does a priority queue implemented with an unsorted array have slow extract-min?",
                                        "options": [
                                          "You must scan all elements to find the minimum",
                                          "Array indexing becomes O(log n)",
                                          "It cannot store duplicates",
                                          "It must rehash on every operation"
                                        ],
                                        "correctAnswerIndex": 0,
                                        "explanation": "Without ordering, finding the min requires a full scan (O(n))."
                                      },
                                        {
                                          "id": "DataStructure_151",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "In a stack, what does 'push' do?",
                                          "options": ["Adds an element to the top", "Removes the top element", "Adds an element to the bottom", "Removes the bottom element"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Push inserts a new element at the top of the stack."
                                        },
                                        {
                                          "id": "DataStructure_152",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "What is the typical time complexity of inserting at the head of a singly linked list?",
                                          "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "You only update the new node's next and the head pointer."
                                        },
                                        {
                                          "id": "DataStructure_153",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Normal",
                                          "questionText": "Which structure is commonly used to represent an unweighted graph in memory efficiently?",
                                          "options": ["Adjacency list", "Adjacency matrix", "Binary heap", "Trie"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Adjacency lists store only existing edges and scale with V+E."
                                        },
                                        {
                                          "id": "DataStructure_154",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "What is the minimum number of edges in a tree with n nodes?",
                                          "options": ["n - 1", "n", "n + 1", "2n"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "A tree is connected and acyclic, which implies exactly n-1 edges."
                                        },
                                        {
                                          "id": "DataStructure_155",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "Which property best describes a tree?",
                                          "options": ["Connected and acyclic", "Disconnected and cyclic", "Connected and cyclic", "Disconnected and acyclic"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "A tree has no cycles and all nodes are connected."
                                        },
                                        {
                                          "id": "DataStructure_156",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "In a max-heap, what is guaranteed about the root element?",
                                          "options": ["It is the maximum element", "It is the minimum element", "It is always the median", "It is always the most recently inserted"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Heap property ensures parent is >= children, so root is max."
                                        },
                                        {
                                          "id": "DataStructure_157",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "Which structure is typically used to implement recursion manually?",
                                          "options": ["Stack", "Queue", "Hash map", "Adjacency matrix"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Recursion uses call stack; explicit stacks can simulate it."
                                        },
                                        {
                                          "id": "DataStructure_158",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Normal",
                                          "questionText": "What is the average time complexity of removing a key from a hash set (good hashing)?",
                                          "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Expected constant time under a good hash distribution and bounded load factor."
                                        },
                                        {
                                          "id": "DataStructure_159",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "What is the term for the number of edges on the longest path from root to a leaf?",
                                          "options": ["Height", "Degree", "Level", "Weight"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Tree height is the max number of edges from root to any leaf."
                                        },
                                        {
                                          "id": "DataStructure_160",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "Which data structure best models a 'waiting line' in real life?",
                                          "options": ["Queue", "Stack", "Set", "Heap"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "A waiting line is FIFO: first to arrive is served first."
                                        },
                                        {
                                          "id": "DataStructure_161",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "In a BST, where are values greater than a node typically stored?",
                                          "options": ["Right subtree", "Left subtree", "Both subtrees", "Only at leaves"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "BST invariant places larger keys in the right subtree."
                                        },
                                        {
                                          "id": "DataStructure_162",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Normal",
                                          "questionText": "Which structure can efficiently support 'contains' checks while preserving insertion order?",
                                          "options": ["Hash set + array/list", "Stack", "Queue", "Binary heap"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Hash set enables O(1) membership; list preserves insertion order for iteration."
                                        },
                                        {
                                          "id": "DataStructure_163",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "What is the typical time complexity of moving from a node to its next node in a linked list?",
                                          "options": ["O(1)", "O(log n)", "O(n)", "O(n log n)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Following a next pointer is a constant-time operation."
                                        },
                                        {
                                          "id": "DataStructure_164",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "Which data structure uses buckets indexed by a hash function?",
                                          "options": ["Hash table", "Binary tree", "Stack", "Queue"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Hash tables map hashes to bucket indices for storage."
                                        },
                                        {
                                          "id": "DataStructure_165",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Easy",
                                          "questionText": "What is the time complexity of getting the size of a typical queue implementation?",
                                          "options": ["O(1)", "O(n)", "O(log n)", "O(n log n)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Queues usually track count as a variable."
                                        },
                                        {
                                          "id": "DataStructure_166",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Easy",
                                          "targetLevel": "Normal",
                                          "questionText": "Why is a hash set often preferred over a list for duplicate detection?",
                                          "options": ["Fast membership checks reduce duplicate checks", "It preserves sorted order", "It uses no memory", "It prevents collisions"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Expected O(1) membership makes detecting duplicates efficient."
                                        },

                                        {
                                          "id": "DataStructure_167",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "What is the time complexity of removing the first element from an array-backed list (like Swift Array)?",
                                          "options": ["O(n)", "O(1)", "O(log n)", "O(n log n)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Removing index 0 shifts all remaining elements left."
                                        },
                                        {
                                          "id": "DataStructure_168",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "Which data structure gives O(1) average lookup but cannot efficiently answer 'give me all keys between a and b'?",
                                          "options": ["Hash map", "Balanced BST", "Skip list", "Sorted array"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Hash maps don’t preserve key order, making range queries inefficient."
                                        },
                                        {
                                          "id": "DataStructure_169",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Hard",
                                          "questionText": "In a hash table with separate chaining, what is the expected lookup time in terms of load factor α?",
                                          "options": ["O(1 + α)", "O(log n)", "O(n)", "O(α^2)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Expected cost is constant plus expected chain length (≈ α)."
                                        },
                                        {
                                          "id": "DataStructure_170",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "What is the time complexity of inserting into a sorted array while keeping it sorted?",
                                          "options": ["O(n)", "O(1)", "O(log n)", "O(n log n)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "You may find position in O(log n) but shifting costs O(n)."
                                        },
                                        {
                                          "id": "DataStructure_171",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "Which traversal uses a queue and visits nodes level by level?",
                                          "options": ["Level-order traversal", "In-order traversal", "Pre-order traversal", "Post-order traversal"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Level-order is BFS on a tree, implemented with a queue."
                                        },
                                        {
                                          "id": "DataStructure_172",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "What is the worst-case time complexity of searching in a sorted array with binary search?",
                                          "options": ["O(log n)", "O(1)", "O(n)", "O(n log n)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Binary search halves the remaining range each step."
                                        },
                                        {
                                          "id": "DataStructure_173",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Hard",
                                          "questionText": "Why is a balanced BST better than an unbalanced BST for worst-case guarantees?",
                                          "options": [
                                            "It enforces height O(log n), preventing degenerate chains",
                                            "It avoids all comparisons",
                                            "It eliminates the need for pointers",
                                            "It guarantees O(1) lookup"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Balancing prevents height from becoming O(n), preserving log-time ops."
                                        },
                                        {
                                          "id": "DataStructure_174",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "In a graph, what does a connected component represent (undirected)?",
                                          "options": [
                                            "A maximal set of nodes reachable from each other",
                                            "A single node with degree 0",
                                            "A cycle of length 2",
                                            "A node with maximum degree"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Within a component, every node is reachable from every other node."
                                        },
                                        {
                                          "id": "DataStructure_175",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "What does 'top' mean in a priority queue (min-priority queue)?",
                                          "options": ["The smallest priority element", "The most recently inserted element", "The largest element always", "A random element"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "In a min-priority queue, the top is the minimum element."
                                        },
                                        {
                                          "id": "DataStructure_176",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "What is the typical time complexity of checking if an undirected graph is connected using BFS/DFS?",
                                          "options": ["O(V + E)", "O(V^2)", "O(E log V)", "O(log V)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Traversal visits each vertex/edge once in adjacency-list form."
                                        },
                                        {
                                          "id": "DataStructure_177",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Hard",
                                          "questionText": "In a doubly linked list, why is deleting a node with only its pointer O(1)?",
                                          "options": [
                                            "You can update prev.next and next.prev directly",
                                            "You can compute its index in O(1)",
                                            "You can avoid memory deallocation",
                                            "You can reorder the list without pointers"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Both neighbors are directly accessible via prev and next pointers."
                                        },
                                        {
                                          "id": "DataStructure_178",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "What is the space complexity of storing N elements in a singly linked list (excluding payload size)?",
                                          "options": ["O(N)", "O(1)", "O(log N)", "O(N log N)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "You store N nodes and N pointers (linear space)."
                                        },
                                        {
                                          "id": "DataStructure_179",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "Which data structure is typically used to store adjacency lists for fast neighbor iteration?",
                                          "options": ["Array/List of lists", "Single stack", "Single queue", "One hash set only"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "A list per vertex stores its neighbors efficiently."
                                        },
                                        {
                                          "id": "DataStructure_180",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Hard",
                                          "questionText": "Why do tries make prefix queries fast compared to hash maps?",
                                          "options": [
                                            "They share prefixes structurally, so prefix traversal is O(prefix length)",
                                            "They store keys in sorted arrays only",
                                            "They avoid character comparisons entirely",
                                            "They guarantee no memory overhead"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Prefix search is just walking edges for each character in the prefix."
                                        },
                                        {
                                          "id": "DataStructure_181",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Normal",
                                          "targetLevel": "Normal",
                                          "questionText": "What is the typical time complexity to check if a BST is valid (given a tree structure)?",
                                          "options": ["O(n)", "O(log n)", "O(1)", "O(n log n)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "You must visit nodes (e.g., in-order or min/max bounds) once."
                                        },

                                        {
                                          "id": "DataStructure_182",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "In open addressing, why must the table keep at least one empty slot to guarantee insertion terminates?",
                                          "options": [
                                            "Probing needs an empty slot to stop; a full table can loop indefinitely",
                                            "Because hashing requires sorted keys",
                                            "Because tombstones are forbidden",
                                            "Because probes only work with prime table sizes"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Insertion must find an empty bucket; if none exist, probing cannot succeed."
                                        },
                                        {
                                          "id": "DataStructure_183",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "What is the key advantage of a Fenwick tree (BIT) over a plain array for prefix sums with updates?",
                                          "options": [
                                            "Supports point updates and prefix sum queries in O(log n)",
                                            "Supports O(1) range updates and range queries always",
                                            "Stores values without extra memory",
                                            "Eliminates integer overflow"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "BIT trades O(log n) time for fast updates/queries vs O(n) rebuild for arrays."
                                        },
                                        {
                                          "id": "DataStructure_184",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "Which property of a segment tree enables range queries in O(log n)?",
                                          "options": [
                                            "Hierarchical partitioning of the array into intervals",
                                            "All nodes store only single values",
                                            "It is a complete graph",
                                            "It uses hashing for intervals"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Intervals are decomposed into O(log n) nodes covering the query range."
                                        },
                                        {
                                          "id": "DataStructure_185",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "In a segment tree with lazy propagation, what does the 'lazy' value represent?",
                                          "options": [
                                            "A pending update to be applied to children later",
                                            "A probability of collision",
                                            "A visited marker for BFS",
                                            "A parent pointer shortcut"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Lazy values defer propagation so range updates don’t touch all descendants immediately."
                                        },
                                        {
                                          "id": "DataStructure_186",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "Why can AVL trees be slower than Red-Black trees in insert-heavy workloads?",
                                          "options": [
                                            "Stricter balancing can cause more rotations/rebalancing work",
                                            "AVL trees cannot search in O(log n)",
                                            "Red-Black trees require more memory per node always",
                                            "AVL trees do not support deletion"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "AVL maintains tighter balance, often requiring more rotations on updates."
                                        },
                                        {
                                          "id": "DataStructure_187",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "In a Red-Black tree, which rule prevents long chains of red nodes?",
                                          "options": [
                                            "No red node can have a red child",
                                            "All leaves must be red",
                                            "Root must be red",
                                            "Every node must have two children"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "This rule limits how skewed the tree can become."
                                        },
                                        {
                                          "id": "DataStructure_188",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "What is the main reason a hash map can be vulnerable to worst-case O(n) lookups under attack?",
                                          "options": [
                                            "Adversarial keys can force many collisions into one bucket/probe sequence",
                                            "Hash maps cannot resize",
                                            "Hash maps cannot store strings",
                                            "Hash maps require sorted keys"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "If many keys collide, operations degrade to scanning long chains/probes."
                                        },
                                        {
                                          "id": "DataStructure_189",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "Which mitigation helps prevent hash-collision DoS in many runtimes?",
                                          "options": [
                                            "Randomized hashing / per-process hash seeds",
                                            "Disabling equality checks",
                                            "Using only adjacency matrices",
                                            "Switching all buckets to stacks"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Randomized hashing makes it hard to craft colliding keys reliably."
                                        },
                                        {
                                          "id": "DataStructure_190",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "In a heap, what is the complexity of building a heap from an array using bottom-up heapify?",
                                          "options": ["O(n)", "O(n log n)", "O(log n)", "O(n^2)"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Bottom-up heapify runs linear time due to decreasing sift-down work at lower levels."
                                        },
                                        {
                                          "id": "DataStructure_191",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "What data structure is best for 'k-way merge' when you repeatedly need the smallest current element among k sources?",
                                          "options": ["Min-heap of size k", "Stack", "Queue", "Hash set"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "A min-heap efficiently selects the smallest head among k streams."
                                        },
                                        {
                                          "id": "DataStructure_192",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "Why do 'handles' (node references) matter for decrease-key in heaps?",
                                          "options": [
                                            "You need to locate the node inside the heap array to adjust and sift",
                                            "They eliminate collisions in hash tables",
                                            "They make the heap a BST",
                                            "They prevent resizing"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Without a handle/index, you can’t find the heap position to decrease efficiently."
                                        },
                                        {
                                          "id": "DataStructure_193",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "In a trie, why can prefix compression (radix tree) improve memory usage?",
                                          "options": [
                                            "It merges single-child chains into one edge labeled by a string segment",
                                            "It removes the need for hashing",
                                            "It guarantees O(1) lookup for all strings",
                                            "It turns the trie into a heap"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Compressing chains reduces node count and pointer overhead."
                                        },
                                        {
                                          "id": "DataStructure_194",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "What is the key difference between a DAG and a general directed graph?",
                                          "options": ["A DAG has no directed cycles", "A DAG must be connected", "A DAG must be weighted", "A DAG must be undirected"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "DAG stands for Directed Acyclic Graph."
                                        },
                                        {
                                          "id": "DataStructure_195",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "Why is a topological order guaranteed to exist only for DAGs?",
                                          "options": [
                                            "Cycles create circular dependencies that prevent a linear ordering",
                                            "Disconnected graphs cannot be ordered",
                                            "Undirected edges break sorting",
                                            "Weights prevent ordering"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "A cycle implies no node can come before itself in a valid ordering."
                                        },
                                        {
                                          "id": "DataStructure_196",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "What is the primary use of an 'in-degree array' in Kahn’s topological sort?",
                                          "options": [
                                            "Track nodes with zero incoming edges to process next",
                                            "Track shortest paths",
                                            "Track hash collisions",
                                            "Track tree height"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Kahn’s algorithm repeatedly removes zero in-degree nodes."
                                        },
                                        {
                                          "id": "DataStructure_197",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "In a graph, what is an articulation point (cut vertex) in an undirected graph?",
                                          "options": [
                                            "A vertex whose removal increases the number of connected components",
                                            "A vertex with degree 1",
                                            "A vertex on every cycle",
                                            "A vertex with maximum in-degree"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Removing an articulation point disconnects part of the graph."
                                        },
                                        {
                                          "id": "DataStructure_198",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "Which data structure is best for 'dynamic connectivity' queries offline (edge additions) in many cases?",
                                          "options": ["Union-Find (DSU)", "Stack", "Trie", "Adjacency matrix only"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "DSU supports fast unions and connectivity checks across components."
                                        },
                                        {
                                          "id": "DataStructure_199",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "Why does Union-Find not directly support efficient edge deletions?",
                                          "options": [
                                            "Union operations are irreversible without rebuilding or advanced structures",
                                            "Because it requires sorting edges",
                                            "Because it uses recursion",
                                            "Because it cannot represent components"
                                          ],
                                          "correctAnswerIndex": 0,
                                          "explanation": "DSU merges sets but doesn’t maintain history to split sets on deletions."
                                        },
                                        {
                                          "id": "DataStructure_200",
                                          "category": "Data Structure",
                                          "baseDifficulty": "Hard",
                                          "targetLevel": "Hard",
                                          "questionText": "What is the typical technique to support deletions in a Bloom-filter-like structure?",
                                          "options": ["Counting Bloom filter", "Perfect hashing", "AVL rotations", "Adjacency matrix pruning"],
                                          "correctAnswerIndex": 0,
                                          "explanation": "Counting Bloom filters store counters instead of bits to allow decrement on delete."
                                        }
]

